{
  "categories": [
    {
      "id": "python",
      "name": "Python",
      "description": "Вопросы по Python.",
      "questions": [
        {
          "text": "Что такое последовательность?",
          "options": [
            "Итерабельный объект с доступом по индексам",
            "Тип данных для хранения чисел",
            "Строка символов",
            "Массив фиксированной длины"
          ],
          "correctAnswer": "Итерабельный объект с доступом по индексам",
          "explanation": "Последовательностью в Python называется итерабельный объект, который поддерживает эффективный доступ к элементам с использованием целочисленных индексов."
        },
        {
          "text": "Какие операции поддерживают большинство последовательностей?",
          "options": [
            "len(s), min(s), max(s)",
            "append(x), remove(x), pop()",
            "count(x), index(x)",
            "Все вышеперечисленные"
          ],
          "correctAnswer": "Все вышеперечисленные",
          "explanation": "Большинство последовательностей поддерживают операции, такие как len(s), min(s), max(s), а также методы append, remove и pop."
        },
        {
          "text": "Можно ли изменить отдельный символ внутри строки?",
          "options": [
            "Да, строки изменяемы",
            "Нет, строки неизменяемы",
            "Да, но только с помощью метода",
            "Нет, но можно создать новую строку"
          ],
          "correctAnswer": "Нет, строки неизменяемы",
          "explanation": "Строки в Python неизменяемы, операции замены возвращают новую строку."
        },
        {
          "text": "Как соединить список строк в одну?",
          "options": [
            "С помощью метода .join()",
            "С помощью метода .split()",
            "С помощью метода .append()",
            "С помощью метода .extend()"
          ],
          "correctAnswer": "С помощью метода .join()",
          "explanation": "Чтобы соединить список строк в одну, используется метод .join()."
        },
        {
          "text": "Как кодировать и декодировать строки?",
          "options": [
            "Кодировать – перевести Юникод в байтовую строку",
            "Декодировать – восстановить строку из цепочки байт",
            "Оба варианта верны",
            "Ни один из вариантов не верен"
          ],
          "correctAnswer": "Оба варианта верны",
          "explanation": "Кодировать – перевести Юникод в байтовую строку, декодировать – восстановить строку из цепочки байт."
        },
        {
          "text": "Чем список отличается от кортежа?",
          "options": [
            "Списки изменяемы, кортежи неизменяемы",
            "Списки хранят однотипные данные, кортежи – разнотипные",
            "Списки имеют фиксированную длину, кортежи – нет",
            "Все вышеперечисленные"
          ],
          "correctAnswer": "Все вышеперечисленные",
          "explanation": "Списки изменяемы, кортежи неизменяемы, списки обычно используются для хранения однотипных данных, а кортежи – для разнотипных."
        },
        {
          "text": "Как сделать список уникальным (без повторяющихся элементов)?",
          "options": [
            "Использовать set()",
            "Использовать OrderedDict",
            "Использовать цикл",
            "Все вышеперечисленные"
          ],
          "correctAnswer": "Все вышеперечисленные",
          "explanation": "Можно использовать множество, OrderedDict или цикл для удаления дубликатов из списка."
        },
        {
          "text": "Как сравниваются последовательности?",
          "options": [
            "Поэлементно",
            "По длине",
            "По типу",
            "По значению"
          ],
          "correctAnswer": "Поэлементно",
          "explanation": "Две последовательности равны, если они имеют одинаковый тип, равную длину и соответствующие элементы равны."
        },
        {
          "text": "Как разбить строку на список строк?",
          "options": [
            "С помощью метода .split()",
            "С помощью метода .join()",
            "С помощью метода .append()",
            "С помощью метода .extend()"
          ],
          "correctAnswer": "С помощью метода .split()",
          "explanation": "Чтобы разбить строку на список строк, используется метод .split()."
        },
        {
          "text": "Что такое диапазон?",
          "options": [
            "Неизменяемая последовательность чисел",
            "Изменяемая последовательность чисел",
            "Тип данных для хранения строк",
            "Тип данных для хранения списков"
          ],
          "correctAnswer": "Неизменяемая последовательность чисел",
          "explanation": "Диапазоны – это неизменяемые последовательности чисел, которые задаются началом, концом и шагом."
        },
        {
          "text": "Есть кортеж из трех элементов. Назначить переменным a, b, c его значения.",
          "options": [
            "a, b, c = tuple",
            "a, b, c = (1, 2, 3)",
            "a, b, c = [1, 2, 3]",
            "a, b, c = {1, 2, 3}"
          ],
          "correctAnswer": "a, b, c = (1, 2, 3)",
          "explanation": "Чтобы назначить значения кортежа переменным, используется синтаксис a, b, c = (1, 2, 3)."
        },
        {
          "text": "Как понять хешируемый ли объект?",
          "options": [
            "Если он изменяемый",
            "Если он имеет метод __hash__()",
            "Если он имеет метод __eq__()",
            "Все вышеперечисленные"
          ],
          "correctAnswer": "Если он имеет метод __hash__()",
          "explanation": "Объект называется хешируемым, если он имеет хеш-значение, которое никогда не изменяется на протяжении его жизненного цикла."
        },
        {
          "text": "Что такое множество?",
          "options": [
            "Упорядоченная коллекция",
            "Неупорядоченная коллекция хешируемых объектов",
            "Изменяемая коллекция",
            "Невозможная коллекция"
          ],
          "correctAnswer": "Неупорядоченная коллекция хешируемых объектов",
          "explanation": "Множество – это неупорядоченная коллекция хешируемых объектов, которые не повторяются."
        },
        {
          "text": "Для чего применяются множества?",
          "options": [
            "Для проверки вхождения элемента",
            "Для удаления повторений",
            "Для выполнения операций объединения и пересечения",
            "Все вышеперечисленные"
          ],
          "correctAnswer": "Все вышеперечисленные",
          "explanation": "Множества обычно используются для проверки элемента на вхождение, удаления повторений и выполнения операций объединения и пересечения."
        },
        {
          "text": "Какие операции можно производить над множествами?",
          "options": [
            "len(s), x in s",
            "s.union(t), s.intersection(t)",
            "s.add(element), s.remove(element)",
            "Все вышеперечисленные"
          ],
          "correctAnswer": "Все вышеперечисленные",
          "explanation": "Существует множество операций, которые можно производить над множествами, включая создание, проверку и модификацию."
        },
        {
          "text": "Что такое отображение?",
          "options": [
            "Объект-контейнер, поддерживающий произвольный доступ по ключам",
            "Список элементов",
            "Множество элементов",
            "Ничто из вышеперечисленного"
          ],
          "correctAnswer": "Объект-контейнер, поддерживающий произвольный доступ по ключам",
          "explanation": "Отображение – это объект-контейнер, который поддерживает произвольный доступ к элементам по ключам."
        },
        {
          "text": "Какие операции можно производить над отображениями?",
          "options": [
            "len(d), d[key], d.get(key)",
            "d.items(), d.keys(), d.values()",
            "d.update(mapping), d.pop(key)",
            "Все вышеперечисленные"
          ],
          "correctAnswer": "Все вышеперечисленные",
          "explanation": "Существует множество операций, которые можно производить над отображениями, включая получение, изменение и удаление элементов."
        },
        {
          "text": "Как отсортировать список словарей по определенному полю?",
          "options": [
            "Использовать метод sort() с параметром key",
            "Использовать функцию sorted() с параметром key",
            "Оба варианта верны",
            "Ни один из вариантов не верен"
          ],
          "correctAnswer": "Оба варианта верны",
          "explanation": "Метод sort() и функция sorted() принимают параметр key для сортировки списка словарей."
        },
        {
          "text": "Как происходит проверка множеств на равенство?",
          "options": [
            "Поэлементно",
            "По длине",
            "По типу",
            "По значению"
          ],
          "correctAnswer": "Поэлементно",
          "explanation": "Проверка множеств на равенство происходит поэлементно, независимо от типов множеств."
        },
        {
          "text": "Какие нюансы есть в использовании чисел как ключей?",
          "options": [
            "int(1) и float(1.0) считаются одинаковым ключом",
            "Числа не могут быть ключами",
            "Числа всегда уникальны",
            "Числа могут быть только положительными"
          ],
          "correctAnswer": "int(1) и float(1.0) считаются одинаковым ключом",
          "explanation": "Числовые ключи в словарях подчиняются правилам сравнения чисел."
        },
        {
          "text": "Что возвращает метод items?",
          "options": [
            "Список ключей",
            "Список значений",
            "Объекты представления словаря",
            "Ничего не возвращает"
          ],
          "correctAnswer": "Объекты представления словаря",
          "explanation": "Методы items(), keys() и values() возвращают объекты представления словаря."
        },
        {
          "text": "Что может являться ключом словаря? Что не может? Почему?",
          "options": [
            "Хешируемые неизменяемые объекты",
            "Изменяемые объекты",
            "Любые объекты",
            "Только строки"
          ],
          "correctAnswer": "Хешируемые неизменяемые объекты",
          "explanation": "Ключом словаря может быть любой хешируемый неизменяемый объект: число, строка, datetime, функция и даже модуль."
        },
        {
          "text": "Есть два списка – ключи и значения. Как составить из них словарь?",
          "options": [
            "Использовать dict()",
            "Использовать zip() и dict()",
            "Использовать list()",
            "Использовать set()"
          ],
          "correctAnswer": "Использовать zip() и dict()",
          "explanation": "Функция zip отдает список пар N-ых элементов, а конструктор dict принимает список пар."
        },
        {
          "text": "Как работает хэш-таблица?",
          "options": [
            "Это массив с фиксированным размером",
            "Это разреженный массив",
            "Это список",
            "Это множество"
          ],
          "correctAnswer": "Это разреженный массив",
          "explanation": "Хэш-таблица – это разреженный массив, в котором имеются незаполненные позиции."
        },
        {
          "text": "Что такое коллизия?",
          "options": [
            "Когда хеш-функция возвращает один и тот же ответ для разных данных",
            "Когда два объекта равны",
            "Когда объект не может быть хеширован",
            "Когда хэш-таблица переполнена"
          ],
          "correctAnswer": "Когда хеш-функция возвращает один и тот же ответ для разных данных",
          "explanation": "Коллизия происходит, когда разные данные имеют одинаковое хеш-значение."
        },
        {
          "text": "Где будет быстрее поиск, а где перебор и почему: dict, list, set, tuple?",
          "options": [
            "В dict и set, потому что это хэш-таблицы",
            "В list и tuple, потому что они быстрее",
            "Везде одинаково",
            "В dict, но не в set"
          ],
          "correctAnswer": "В dict и set, потому что это хэш-таблицы",
          "explanation": "Поиск будет быстрее в dict и set, потому что доступ к элементу выполняется за O(1)."
        },
        {
          "text": "Можно ли объявлять функцию внутри другой функции? Где она будет видна?",
          "options": [
            "Да, она будет видна только внутри первой функции",
            "Нет, она будет видна во всей программе",
            "Да, она будет видна в других функциях",
            "Нет, она не может быть объявлена"
          ],
          "correctAnswer": "Да, она будет видна только внутри первой функции",
          "explanation": "Вложенные функции видны только в области видимости внешней функции."
        },
        {
          "text": "Как передаются значения аргументов в функцию или метод?",
          "options": [
            "По ссылке",
            "По значению",
            "По значению и по ссылке",
            "Никак, они не передаются"
          ],
          "correctAnswer": "По значению и по ссылке",
          "explanation": "В Python используется механизм связывания имени переменной с объектом, что позволяет передавать значения по значению и по ссылке."
        },
        {
          "text": "Что такое замыкание?",
          "options": [
            "Функция, находящаяся в теле другой функции",
            "Функция, которая не может быть вызвана",
            "Функция, которая возвращает другую функцию",
            "Функция, которая не имеет доступа к переменным"
          ],
          "correctAnswer": "Функция, находящаяся в теле другой функции",
          "explanation": "Замыкание – это функция, которая содержит ссылки на локальные переменные внешней функции."
        },
        {
          "text": "Что такое контейнер?",
          "options": [
            "Тип данных, который инкапсулирует значения других типов",
            "Тип данных, который не может хранить значения",
            "Тип данных, который хранит только числа",
            "Тип данных, который хранит только строки"
          ],
          "correctAnswer": "Тип данных, который инкапсулирует значения других типов",
          "explanation": "Контейнеры, такие как списки, кортежи, множества и словари, инкапсулируют значения других типов."
        },
        {
          "text": "Что такое итерабельный объект?",
          "options": [
            "Объект, который может возвращать значения по одному за раз",
            "Объект, который нельзя итерировать",
            "Объект, который хранит только числа",
            "Объект, который хранит только строки"
          ],
          "correctAnswer": "Объект, который может возвращать значения по одному за раз",
          "explanation": "Итерабельный объект – это объект, который может возвращать значения по одному за раз, например, списки и строки."
        },
        {
          "text": "Что такое итератор?",
          "options": [
            "Объект, который представляет поток данных",
            "Объект, который хранит данные",
            "Объект, который не может быть итерирован",
            "Объект, который хранит только числа"
          ],
          "correctAnswer": "Объект, который представляет поток данных",
          "explanation": "Итератор – это объект, который представляет поток данных и имеет метод __next__() для получения следующего элемента."
        },
        {
          "text": "Что такое генератор?",
          "options": [
            "Функция, которая возвращает итератор",
            "Объект, который хранит данные",
            "Функция, которая не может быть вызвана",
            "Объект, который не может быть итерирован"
          ],
          "correctAnswer": "Функция, которая возвращает итератор",
          "explanation": "Генератор – это функция, которая возвращает итератор и может использовать ключевое слово yield."
        },
        {
          "text": "Что такое генераторная функция?",
          "options": [
            "Функция, в теле которой встречается ключевое слово yield",
            "Функция, которая возвращает список",
            "Функция, которая не может быть вызвана",
            "Функция, которая всегда возвращает одно значение"
          ],
          "correctAnswer": "Функция, в теле которой встречается ключевое слово yield",
          "explanation": "Генераторная функция – это функция, в теле которой встречается ключевое слово yield, возвращающая объект-генератор."
        },
        {
          "text": "Что делает yield?",
          "options": [
            "Возвращает текущее значение и замораживает состояние функции",
            "Завершает выполнение функции",
            "Создает новый объект",
            "Ничего не делает"
          ],
          "correctAnswer": "Возвращает текущее значение и замораживает состояние функции",
          "explanation": "Yield замораживает состояние функции-генератора и возвращает текущее значение."
        },
        {
          "text": "В чем отличие [x for x in y] от (x for x in y)?",
          "options": [
            "Первое возвращает список, второе – генератор",
            "Оба возвращают список",
            "Оба возвращают генератор",
            "Первое возвращает множество, второе – список"
          ],
          "correctAnswer": "Первое возвращает список, второе – генератор",
          "explanation": "[x for x in y] – это списковое включение, а (x for x in y) – это генераторное выражение."
        },
        {
          "text": "Что особенного в генераторе?",
          "options": [
            "Хранит все элементы в памяти",
            "Хранит только внутреннее состояние для вычисления очередного элемента",
            "Можно пройти генератор несколько раз",
            "Генератор не может быть итерирован"
          ],
          "correctAnswer": "Хранит только внутреннее состояние для вычисления очередного элемента",
          "explanation": "Генератор хранит в памяти не все элементы, а только внутреннее состояние для вычисления очередного элемента."
        },
        {
          "text": "Как объявить генератор?",
          "options": [
            "Использовать синтаксис (x for x in seq)",
            "Использовать оператор yield в теле функции",
            "Использовать встроенную функцию iter",
            "Все вышеперечисленные"
          ],
          "correctAnswer": "Все вышеперечисленные",
          "explanation": "Генератор можно объявить с помощью всех перечисленных способов."
        },
        {
          "text": "Как получить из генератора список?",
          "options": [
            "Передать его в конструктор списка",
            "Использовать метод list()",
            "Использовать цикл for",
            "Невозможно получить список из генератора"
          ],
          "correctAnswer": "Передать его в конструктор списка",
          "explanation": "Чтобы получить список из генератора, нужно передать его в конструктор списка: list(x for x in some_seq)."
        },
        {
          "text": "Что такое подгенератор?",
          "options": [
            "Генератор, который возвращает другой генератор",
            "Генератор, который использует yield from",
            "Генератор, который не может быть вызван",
            "Генератор, который возвращает список"
          ],
          "correctAnswer": "Генератор, который использует yield from",
          "explanation": "Подгенератор – это генератор, который делегирует доступ к другому генератору с помощью yield from."
        },
        {
          "text": "Какие методы есть у генераторов?",
          "options": [
            "__next__(), send(), throw(), close()",
            "start(), stop(), next()",
            "append(), remove()",
            "get(), set()"
          ],
          "correctAnswer": "__next__(), send(), throw(), close()",
          "explanation": "Генераторы имеют методы __next__(), send(), throw() и close()."
        },
        {
          "text": "Можно ли извлечь элемент генератора по индексу?",
          "options": [
            "Да, это возможно",
            "Нет, будет ошибка",
            "Только в Python 3",
            "Только в Python 2"
          ],
          "correctAnswer": "Нет, будет ошибка",
          "explanation": "Генератор не поддерживает метод __getitem__(), поэтому извлечение по индексу невозможно."
        },
        {
          "text": "Что возвращает итерация по словарю?",
          "options": [
            "Значение",
            "Ключ",
            "Порядок",
            "Индекс"
          ],
          "correctAnswer": "Ключ",
          "explanation": "Итерация по словарю возвращает ключи, порядок следования которых не гарантируется."
        },
        {
          "text": "Как итерировать словарь по парам ключ-значение?",
          "options": [
            "Использовать метод .items()",
            "Использовать метод .keys()",
            "Использовать метод .values()",
            "Использовать метод .iter()"
          ],
          "correctAnswer": "Использовать метод .items()",
          "explanation": "Метод словаря .items() возвращает генератор кортежей (key, value)."
        },
        {
          "text": "Что такое сопрограмма?",
          "options": [
            "Компонент программы с одной точкой входа",
            "Компонент программы с множеством входных точек",
            "Функция, которая не может быть вызвана",
            "Функция, которая всегда возвращает значение"
          ],
          "correctAnswer": "Компонент программы с множеством входных точек",
          "explanation": "Сопрограмма поддерживает множество входных точек и позволяет остановку и продолжение выполнения."
        },
        {
          "text": "Как получить список атрибутов объекта?",
          "options": [
            "Использовать функцию dir()",
            "Использовать функцию list()",
            "Использовать функцию get()",
            "Использовать функцию keys()"
          ],
          "correctAnswer": "Использовать функцию dir()",
          "explanation": "Функция dir() возвращает список строк – полей объекта."
        },
        {
          "text": "Что такое магические методы, для чего нужны?",
          "options": [
            "Методы, которые вызываются явно",
            "Методы, имена которых начинаются и заканчиваются двойным подчеркиванием",
            "Методы, которые не могут быть переопределены",
            "Методы, которые всегда возвращают значение"
          ],
          "correctAnswer": "Методы, имена которых начинаются и заканчиваются двойным подчеркиванием",
          "explanation": "Магические методы вызываются встроенными функциями или синтаксическими конструкциями."
        },
        {
          "text": "Как в классе сослаться на родительский класс?",
          "options": [
            "Использовать функцию parent()",
            "Использовать функцию super()",
            "Использовать функцию base()",
            "Использовать функцию class()"
          ],
          "correctAnswer": "Использовать функцию super()",
          "explanation": "Функция super() позволяет ссылаться на родительский класс и его методы."
        },
        {
          "text": "Прокомментировать выражение `object() == object()`.",
          "options": [
            "Всегда истина",
            "Всегда ложь",
            "Зависит от контекста",
            "Вызывает ошибку"
          ],
          "correctAnswer": "Всегда ложь",
          "explanation": "Выражение всегда возвращает ложь, так как объекты сравниваются по адресу в памяти, если не переопределен метод __eq__."
        },
        {
          "text": "Что такое __slots__? Плюсы и минусы.",
          "options": [
            "Способ хранения полей класса",
            "Способ создания методов",
            "Способ управления памятью",
            "Способ работы с файлами"
          ],
          "correctAnswer": "Способ хранения полей класса",
          "explanation": "__slots__ фиксирует набор полей класса, что позволяет экономить память и ускорять доступ к полям."
        },
        {
          "text": "В чем смысл параметров _value, __value?",
          "options": [
            "Они обозначают приватные поля",
            "Они обозначают публичные поля",
            "Они обозначают статические поля",
            "Они обозначают методы класса"
          ],
          "correctAnswer": "Они обозначают приватные поля",
          "explanation": "Параметры с одним подчеркиванием доступны извне, а с двойным – нет, благодаря механизму name mangling."
        },
        {
          "text": "Что такое __new__? Чем он отличается от __init__?",
          "options": [
            "__new__ создает объект, __init__ инициализирует его",
            "__new__ и __init__ делают одно и то же",
            "__new__ вызывается только для классов, __init__ для объектов",
            "__new__ не существует в Python"
          ],
          "correctAnswer": "__new__ создает объект, __init__ инициализирует его",
          "explanation": "__new__ вызывается при создании экземпляра, а __init__ – при его инициализации."
        },
        {
          "text": "Что такое old-style и new-style classes?",
          "options": [
            "Разные версии Python",
            "Разные типы классов",
            "Разные способы наследования",
            "Разные способы работы с памятью"
          ],
          "correctAnswer": "Разные типы классов",
          "explanation": "New-style classes были введены для унификации типов и классов, и они наследуют от встроенного класса object."
        },
        {
          "text": "Что такое утиная типизация?",
          "options": [
            "Типизация, основанная на наследовании",
            "Типизация, основанная на методах и свойствах объекта",
            "Статическая типизация",
            "Типизация, основанная на классах"
          ],
          "correctAnswer": "Типизация, основанная на методах и свойствах объекта",
          "explanation": "Утиная типизация определяет совместимость объекта по его методам и свойствам, а не по его классу."
        },
        {
          "text": "Что такое модуль?",
          "options": [
            "Часть программы, оформленная в виде отдельного файла",
            "Класс, который содержит методы",
            "Функция, которая выполняет задачу",
            "Переменная, хранящая данные"
          ],
          "correctAnswer": "Часть программы, оформленная в виде отдельного файла",
          "explanation": "Модуль – это функционально законченный фрагмент программы, оформленный в виде отдельного файла с исходным кодом."
        },
        {
          "text": "Как можно получить имя модуля?",
          "options": [
            "Использовать переменную __name__",
            "Использовать функцию get_module_name()",
            "Использовать переменную module_name",
            "Имя модуля нельзя получить"
          ],
          "correctAnswer": "Использовать переменную __name__",
          "explanation": "Имя модуля доступно в его глобальной переменной __name__."
        },
        {
          "text": "Что такое модульное программирование?",
          "options": [
            "Программирование с использованием классов",
            "Организация программы как совокупности независимых блоков",
            "Программирование с использованием функций",
            "Программирование, основанное на статической типизации"
          ],
          "correctAnswer": "Организация программы как совокупности независимых блоков",
          "explanation": "Модульное программирование позволяет разбивать программу на небольшие независимые модули."
        },
        {
          "text": "Как Python ищет модули при импорте?",
          "options": [
            "В стандартных директориях и архивах",
            "Только в текущей директории",
            "Только в директории с исполняемым файлом",
            "В директориях, указанных в переменной окружения"
          ],
          "correctAnswer": "В стандартных директориях и архивах",
          "explanation": "При импорте Python ищет модули в директориях и архивах, указанных в переменной sys.path."
        },
        {
          "text": "Что такое пакет?",
          "options": [
            "Объединение модулей в пространства имён",
            "Отдельный файл с кодом",
            "Класс, который содержит методы",
            "Переменная, хранящая данные"
          ],
          "correctAnswer": "Объединение модулей в пространства имён",
          "explanation": "Пакеты служат как пространства имён для модулей и позволяют структурировать их."
        },
        {
          "text": "Что вы можете сказать о конструкции import package.item?",
          "options": [
            "item должен быть модулем или пакетом",
            "item может быть только модулем",
            "item может быть только классом",
            "item не может быть пакетом"
          ],
          "correctAnswer": "item должен быть модулем или пакетом",
          "explanation": "При использовании import package.item, item должен быть модулем или пакетом."
        },
        {
          "text": "Что такое обработка исключений?",
          "options": [
            "Механизм для обработки ошибок времени выполнения",
            "Механизм для обработки синтаксических ошибок",
            "Механизм для обработки логических ошибок",
            "Механизм для обработки ошибок компиляции"
          ],
          "correctAnswer": "Механизм для обработки ошибок времени выполнения",
          "explanation": "Обработка исключений – это механизм, предназначенный для описания реакции программы на ошибки времени выполнения."
        },
        {
          "text": "Для чего могут применять конструкцию try finally без except?",
          "options": [
            "Для выполнения cleanup-кода",
            "Для обработки исключений",
            "Для создания новых исключений",
            "Для завершения программы"
          ],
          "correctAnswer": "Для выполнения cleanup-кода",
          "explanation": "Блок finally будет выполнен независимо от того, произошла ли ошибка в блоке try."
        },
        {
          "text": "Как правильно по-разному обрабатывать исключения?",
          "options": [
            "Сначала указывать более общие исключения",
            "Сначала указывать менее общие исключения",
            "Обрабатывать все исключения одинаково",
            "Не обрабатывать исключения"
          ],
          "correctAnswer": "Сначала указывать менее общие исключения",
          "explanation": "Блоки except обрабатываются сверху вниз, поэтому сначала нужно указывать обработчики менее общих исключений."
        },
        {
          "text": "Что будет, если ошибку не обработает блок except?",
          "options": [
            "Программа завершится с ошибкой",
            "Ошибка будет перехвачена внешним блоком try/except",
            "Ошибка будет проигнорирована",
            "Программа продолжит выполнение"
          ],
          "correctAnswer": "Программа завершится с ошибкой",
          "explanation": "Если ни один блок except не перехватывает исключение, программа завершится, и информация об исключении будет выведена."
        },
        {
          "text": "Что делать, если нужно перехватить исключение, выполнить действия и опять возбудить это же исключение?",
          "options": [
            "Использовать raise без параметров",
            "Использовать raise с параметрами",
            "Использовать pass",
            "Использовать continue"
          ],
          "correctAnswer": "Использовать raise без параметров",
          "explanation": "Для повторного возбуждения того же исключения используется raise без параметров."
        },
        {
          "text": "Что такое сцепление исключений?",
          "options": [
            "Связывание нескольких исключений в одну цепь",
            "Обработка исключений в одном блоке",
            "Замена старого исключения новым",
            "Игнорирование исключений"
          ],
          "correctAnswer": "Связывание нескольких исключений в одну цепь",
          "explanation": "Сцепление исключений позволяет сохранять старое исключение в атрибуте __context__ при возбуждении нового."
        },
        {
          "text": "Зачем нужен блок else?",
          "options": [
            "Для обработки исключений",
            "Для выполнения кода, если исключений не возникло",
            "Для завершения программы",
            "Для создания новых исключений"
          ],
          "correctAnswer": "Для выполнения кода, если исключений не возникло",
          "explanation": "Блок else выполняется, если в блоке try не возникло исключений."
        },
        {
          "text": "Что можно передать в конструктор исключения?",
          "options": [
            "Только строку",
            "Любые неименованные аргументы",
            "Только числа",
            "Только списки"
          ],
          "correctAnswer": "Любые неименованные аргументы",
          "explanation": "Исключения могут принимать любые неименованные аргументы, которые помещаются в атрибут args."
        },
        {
          "text": "Какие есть классы исключений?",
          "options": [
            "BaseException, Exception, StandardError",
            "Error, Warning, Exception",
            "RuntimeError, SyntaxError, ValueError",
            "Все вышеперечисленные"
          ],
          "correctAnswer": "Все вышеперечисленные",
          "explanation": "Существует множество классов исключений, включая BaseException, Exception и другие."
        },
        {
          "text": "В каких случаях можно обработать SyntaxError?",
          "options": [
            "При возникновении в главном модуле",
            "В импортируемом модуле",
            "При выполнении eval или exec",
            "Все вышеперечисленные"
          ],
          "correctAnswer": "В импортируемом модуле",
          "explanation": "SyntaxError может быть обработан, если он возникает в импортируемом модуле или при выполнении eval или exec."
        },
        {
          "text": "Можно ли создавать собственные исключения?",
          "options": [
            "Да, наследуя от Exception",
            "Нет, это невозможно",
            "Да, но только от BaseException",
            "Да, но только от StandardError"
          ],
          "correctAnswer": "Да, наследуя от Exception",
          "explanation": "Можно создавать собственные исключения, наследуя от класса Exception."
        },
        {
          "text": "Для чего нужны предупреждения (warnings)?",
          "options": [
            "Для обработки ошибок",
            "Для уведомления пользователя о потенциальных проблемах",
            "Для завершения программы",
            "Для создания исключений"
          ],
          "correctAnswer": "Для уведомления пользователя о потенциальных проблемах",
          "explanation": "Предупреждения выводятся, когда не гарантируется ошибочное поведение, но пользователя следует уведомить."
        },
        {
          "text": "Для чего нужен модуль warnings?",
          "options": [
            "Для работы с исключениями",
            "Для работы с предупреждениями",
            "Для работы с ошибками",
            "Для работы с логированием"
          ],
          "correctAnswer": "Для работы с предупреждениями",
          "explanation": "Модуль warnings содержит функции для работы с предупреждениями, включая функцию warn."
        },
        {
          "text": "Что такое декораторы?",
          "options": [
            "Паттерн проектирования, изменяющий поведение объекта",
            "Функции, которые не принимают аргументы",
            "Классы, которые не могут быть вызваны",
            "Методы, которые всегда возвращают значение"
          ],
          "correctAnswer": "Паттерн проектирования, изменяющий поведение объекта",
          "explanation": "Декоратор – это функция, которая принимает другую функцию и изменяет её поведение."
        },
        {
          "text": "Что может быть декоратором?",
          "options": [
            "Только функции",
            "Только классы",
            "Любой вызываемый объект",
            "Только методы"
          ],
          "correctAnswer": "Любой вызываемый объект",
          "explanation": "Декоратором может быть любая вызываемая сущность: функция, лямбда, класс или экземпляр класса."
        },
        {
          "text": "Что будет, если декоратор не возвращает ничего?",
          "options": [
            "Вернется None",
            "Вернется пустая строка",
            "Возникнет ошибка",
            "Функция останется неизменной"
          ],
          "correctAnswer": "Вернется None",
          "explanation": "Если декоратор не возвращает значение, декорируемая функция станет None, и вызов приведет к ошибке."
        },
        {
          "text": "В чем отличие @foobar от @foobar()?",
          "options": [
            "Первое – обычное декорирование, второе – параметрическое",
            "Оба варианта одинаковы",
            "Первое – это функция, второе – это класс",
            "Первое – это метод, второе – это функция"
          ],
          "correctAnswer": "Первое – обычное декорирование, второе – параметрическое",
          "explanation": "@foobar – это обычное декорирование, а @foobar() – это вызов функции, которая возвращает декоратор."
        },
        {
          "text": "Что такое фабрика декораторов?",
          "options": [
            "Функция, которая возвращает декоратор",
            "Класс, который создает декораторы",
            "Метод, который обрабатывает декораторы",
            "Функция, которая не может быть вызвана"
          ],
          "correctAnswer": "Функция, которая возвращает декоратор",
          "explanation": "Фабрика декораторов – это функция, которая создает и возвращает декоратор с параметрами."
        },
        {
          "text": "Зачем нужен wraps?",
          "options": [
            "Для создания новых функций",
            "Для назначения атрибутов функции-враппера",
            "Для обработки исключений",
            "Для работы с классами"
          ],
          "correctAnswer": "Для назначения атрибутов функции-враппера",
          "explanation": "wraps назначает функции-врапперу те же поля __name__, __module__, __doc__, что и у исходной функции."
        },
        {
          "text": "Что такое метаклассы?",
          "options": [
            "Классы, которые создают объекты",
            "Классы, которые создают другие классы",
            "Функции, которые обрабатывают исключения",
            "Модули, которые содержат функции"
          ],
          "correctAnswer": "Классы, которые создают другие классы",
          "explanation": "Метаклассы – это классы, которые создают другие классы."
        },
        {
          "text": "Что такое type?",
          "options": [
            "Метакласс, используемый для создания классов",
            "Функция для создания объектов",
            "Класс для обработки ошибок",
            "Модуль для работы с данными"
          ],
          "correctAnswer": "Метакласс, используемый для создания классов",
          "explanation": "type – это метакласс, который Python использует для создания всех классов."
        },
        {
          "text": "Как работают метаклассы?",
          "options": [
            "Перехватывают создание класса и изменяют его",
            "Создают объекты",
            "Обрабатывают исключения",
            "Работают только с функциями"
          ],
          "correctAnswer": "Перехватывают создание класса и изменяют его",
          "explanation": "Метаклассы могут перехватывать создание класса, изменять его и возвращать модифицированный класс."
        },
        {
          "text": "Зачем вообще использовать метаклассы?",
          "options": [
            "Для создания API",
            "Для обработки данных",
            "Для работы с файлами",
            "Для создания исключений"
          ],
          "correctAnswer": "Для создания API",
          "explanation": "Метаклассы часто используются для создания API, как в случае с Django ORM."
        },
        {
          "text": "Что такое файловый объект?",
          "options": [
            "Объект, предоставляющий файл-ориентированный API",
            "Объект, который хранит данные",
            "Объект, который не может быть вызван",
            "Объект, который не имеет методов"
          ],
          "correctAnswer": "Объект, предоставляющий файл-ориентированный API",
          "explanation": "Файловый объект предоставляет методы для доступа к ресурсам, такие как read() и write()."
        },
        {
          "text": "Какие есть виды файловых объектов?",
          "options": [
            "Текстовые и бинарные",
            "Только текстовые",
            "Только бинарные",
            "Текстовые, обычные и буферизированные"
          ],
          "correctAnswer": "Текстовые, обычные и буферизированные",
          "explanation": "В Python 3 существуют текстовые файлы, обычные бинарные файлы и буферизированные бинарные файлы."
        },
        {
          "text": "В чем отличие текстовых и бинарных файлов?",
          "options": [
            "Текстовые файлы не требуют кодировки",
            "Бинарные файлы не выполняют преобразования",
            "Текстовые файлы всегда больше",
            "Бинарные файлы всегда меньше"
          ],
          "correctAnswer": "Бинарные файлы не выполняют преобразования",
          "explanation": "Текстовые файлы автоматически выполняют преобразования кодировок и концов строк, в то время как бинарные файлы работают с данными в их исходном виде."
        },
        {
          "text": "Как пользоваться функцией open?",
          "options": [
            "open(file, mode)",
            "open(file, mode, encoding)",
            "open(file, mode, buffering)",
            "Все вышеперечисленные"
          ],
          "correctAnswer": "Все вышеперечисленные",
          "explanation": "Функция open может принимать различные параметры, включая имя файла, режим открытия и кодировку."
        },
        {
          "text": "Для чего необходимо закрывать файлы?",
          "options": [
            "Чтобы освободить ресурсы",
            "Чтобы избежать потери данных",
            "Чтобы предотвратить блокировку файла",
            "Все вышеперечисленные"
          ],
          "correctAnswer": "Все вышеперечисленные",
          "explanation": "Закрытие файлов освобождает ресурсы, предотвращает потерю данных и блокировку файла для других процессов."
        },
        {
          "text": "Что делают методы tell и seek?",
          "options": [
            "tell возвращает позицию, seek устанавливает её",
            "tell устанавливает позицию, seek возвращает её",
            "Оба метода возвращают позицию",
            "Оба метода устанавливают позицию"
          ],
          "correctAnswer": "tell возвращает позицию, seek устанавливает её",
          "explanation": "Метод tell() возвращает текущую позицию считывания/записи, а метод seek(offset, whence) устанавливает её."
        },
        {
          "text": "Что делают StringIO и BytesIO?",
          "options": [
            "Представляют собой потоки для работы с файлами",
            "Представляют собой потоки для работы с строками и байтовыми строками в памяти",
            "Используются для сериализации",
            "Используются для десериализации"
          ],
          "correctAnswer": "Представляют собой потоки для работы с строками и байтовыми строками в памяти",
          "explanation": "Классы io.StringIO и io.BytesIO позволяют работать с текстовыми и бинарными данными в памяти."
        },
        {
          "text": "Являются ли файловые объекты контекстными менеджерами?",
          "options": [
            "Да",
            "Нет",
            "Только в Python 3",
            "Только в Python 2"
          ],
          "correctAnswer": "Да",
          "explanation": "Файловые объекты являются контекстными менеджерами и могут использоваться с оператором with."
        },
        {
          "text": "Что такое сериализация?",
          "options": [
            "Процесс сохранения объектов в двоичном или строковом виде",
            "Процесс загрузки объектов из файла",
            "Процесс создания объектов",
            "Процесс удаления объектов"
          ],
          "correctAnswer": "Процесс сохранения объектов в двоичном или строковом виде",
          "explanation": "Сериализация – это процесс сохранения объектов для хранения или передачи."
        },
        {
          "text": "Что делают json.dumps и json.dump?",
          "options": [
            "Сохраняют JSON-представление объекта в строку и в файл соответственно",
            "Загружают объект из строки и из файла соответственно",
            "Сериализуют и десериализуют объекты",
            "Создают и удаляют объекты"
          ],
          "correctAnswer": "Сохраняют JSON-представление объекта в строку и в файл соответственно",
          "explanation": "json.dumps сохраняет JSON в строку, а json.dump – в текстовый файл."
        },
        {
          "text": "Что делать, если нужно сериализовать данные, которые не поддерживаются стандартным модулем json?",
          "options": [
            "Использовать pickle",
            "Расширить классы JSONEncoder и JSONDecoder",
            "Оба варианта верны",
            "Невозможно сериализовать такие данные"
          ],
          "correctAnswer": "Оба варианта верны",
          "explanation": "Можно использовать модуль pickle или расширить классы JSONEncoder и JSONDecoder для сериализации нестандартных данных."
        },
        {
          "text": "Что делают функции pickle.dumps и pickle.dump?",
          "options": [
            "Сериализуют объекты в строку и в файл соответственно",
            "Десериализуют объекты из строки и из файла соответственно",
            "Работают только с текстовыми данными",
            "Работают только с бинарными данными"
          ],
          "correctAnswer": "Сериализуют объекты в строку и в файл соответственно",
          "explanation": "Функции dump и dumps модуля pickle аналогичны функциям модуля JSON, но работают с байтовыми строками и бинарными файлами."
        },
        {
          "text": "Что такое пирамида тестирования?",
          "options": [
            "Метод тестирования",
            "Структура тестов",
            "Тип тестирования",
            "Неизвестный термин"
          ],
          "correctAnswer": "Структура тестов",
          "explanation": "Пирамида тестирования – это концепция, описывающая структуру тестов в проекте."
        },
        {
          "text": "Что такое mocking?",
          "options": [
            "Имитация объектов для тестирования",
            "Создание реальных объектов",
            "Удаление объектов",
            "Изменение объектов"
          ],
          "correctAnswer": "Имитация объектов для тестирования",
          "explanation": "Mocking – это процесс создания имитаций объектов для тестирования, позволяющий избежать зависимости от внешних ресурсов."
        },
        {
          "text": "Что делать, если тестируемая функция занимает много времени на выполнение повторяющихся операций?",
          "options": [
            "Уменьшить количество операций",
            "Замокать ресурсоёмкие функции и проверить параметры",
            "Изменить алгоритм",
            "Все вышеперечисленные"
          ],
          "correctAnswer": "Все вышеперечисленные",
          "explanation": "Можно уменьшить количество операций, замокать ресурсоёмкие функции и подготовить быстрый набор данных."
        },
        {
          "text": "Какие вы знаете виды тестов?",
          "options": [
            "Модульные, интеграционные, функциональные",
            "Только модульные",
            "Только интеграционные",
            "Только функциональные"
          ],
          "correctAnswer": "Модульные, интеграционные, функциональные",
          "explanation": "Существуют различные виды тестов, включая модульные, интеграционные и функциональные тесты."
        },
        {
          "text": "Что такое unit-тесты?",
          "options": [
            "Тесты, проверяющие взаимодействие между модулями",
            "Тесты, проверяющие отдельные модули кода",
            "Тесты, проверяющие функциональность приложения",
            "Тесты, проверяющие производительность"
          ],
          "correctAnswer": "Тесты, проверяющие отдельные модули кода",
          "explanation": "Unit-тесты проверяют, правильно ли работает каждый отдельный модуль вашего кода."
        },
        {
          "text": "Что такое интеграционные тесты?",
          "options": [
            "Тесты, проверяющие отдельные модули",
            "Тесты, проверяющие взаимодействие между модулями",
            "Тесты, проверяющие производительность",
            "Тесты, проверяющие функциональность"
          ],
          "correctAnswer": "Тесты, проверяющие взаимодействие между модулями",
          "explanation": "Интеграционные тесты проверяют взаимодействие между двумя или более модулями вашего кода."
        },
        {
          "text": "Что такое функциональное тестирование?",
          "options": [
            "Тестирование отдельных функций модулей",
            "Тестирование производительности",
            "Тестирование взаимодействия между модулями",
            "Тестирование безопасности"
          ],
          "correctAnswer": "Тестирование отдельных функций модулей",
          "explanation": "Функциональное тестирование проверяет функциональность программного продукта на индивидуальном уровне."
        },
        {
          "text": "Чем интеграционное тестирование отличается от функционального?",
          "options": [
            "Интеграционное тестирование проверяет взаимодействие, функциональное – отдельные функции",
            "Они идентичны",
            "Функциональное тестирование всегда быстрее",
            "Интеграционное тестирование всегда медленнее"
          ],
          "correctAnswer": "Интеграционное тестирование проверяет взаимодействие, функциональное – отдельные функции",
          "explanation": "Интеграционное тестирование фокусируется на взаимодействии между модулями, а функциональное – на тестировании отдельных функций."
        },
        {
          "text": "Что такое функциональное программирование?",
          "options": [
            "Парадигма программирования, основанная на вычислении значений функций",
            "Процесс изменения состояний",
            "Метод тестирования",
            "Тип программирования, основанный на объектах"
          ],
          "correctAnswer": "Парадигма программирования, основанная на вычислении значений функций",
          "explanation": "Функциональное программирование трактует процесс вычисления как вычисление значений функций."
        },
        {
          "text": "Как у Python с поддержкой функционального программирования?",
          "options": [
            "Python полностью поддерживает функциональное программирование",
            "Python частично поддерживает функциональное программирование",
            "Python не поддерживает функциональное программирование",
            "Python поддерживает только императивное программирование"
          ],
          "correctAnswer": "Python частично поддерживает функциональное программирование",
          "explanation": "Python позволяет писать код в функциональном стиле и поддерживает некоторые функциональные возможности."
        },
        {
          "text": "Что такое объект первого класса?",
          "options": [
            "Объект, который можно передать как параметр или вернуть из функции",
            "Объект, который нельзя сохранить в переменной",
            "Объект, который не может быть создан во время выполнения",
            "Объект, который не имеет имени"
          ],
          "correctAnswer": "Объект, который можно передать как параметр или вернуть из функции",
          "explanation": "Объект первого класса может быть передан в функцию, возвращен из функции и сохранен в переменной."
        },
        {
          "text": "Что такое функция высшего порядка?",
          "options": [
            "Функция, принимающая другие функции как аргументы",
            "Функция, возвращающая значение",
            "Функция, которая не принимает аргументы",
            "Функция, которая всегда возвращает другую функцию"
          ],
          "correctAnswer": "Функция, принимающая другие функции как аргументы",
          "explanation": "Функция высшего порядка принимает в качестве аргументов другие функции или возвращает другую функцию."
        },
        {
          "text": "Что такое каррирование?",
          "options": [
            "Преобразование функции от многих аргументов в набор функций от одного аргумента",
            "Процесс создания функций",
            "Метод тестирования",
            "Тип функции"
          ],
          "correctAnswer": "Преобразование функции от многих аргументов в набор функций от одного аргумента",
          "explanation": "Каррирование позволяет передавать часть аргументов в функцию и получать новую функцию, ожидающую остальные аргументы."
        },
        {
          "text": "Опишите функции map, reduce, filter модуля functools.",
          "options": [
            "map применяет функцию к каждому элементу, filter оставляет элементы, reduce сворачивает последовательность",
            "map возвращает список, filter возвращает кортеж, reduce возвращает строку",
            "map и filter работают только с числами, reduce работает с любыми типами",
            "Все функции работают только в Python 2"
          ],
          "correctAnswer": "map применяет функцию к каждому элементу, filter оставляет элементы, reduce сворачивает последовательность",
          "explanation": "Функции map, filter и reduce выполняют операции над последовательностями, применяя заданные функции."
        },
        {
          "text": "Какие еще вы знаете функции из модуля functools?",
          "options": [
            "lru_cache и partial",
            "map и filter",
            "reduce и zip",
            "all и any"
          ],
          "correctAnswer": "lru_cache и partial",
          "explanation": "Модуль functools содержит функции высшего порядка, такие как lru_cache и partial."
        },
        {
          "text": "Какие функции вы знаете из модуля itertools?",
          "options": [
            "product, permutations, combinations",
            "map, filter, reduce",
            "zip, all, any",
            "sorted, reversed, list"
          ],
          "correctAnswer": "product, permutations, combinations",
          "explanation": "Модуль itertools содержит функции для работы с итераторами, такие как product, permutations и combinations."
        },
        {
          "text": "Для чего нужен модуль operator?",
          "options": [
            "Для работы с файлами",
            "Для работы с операторами",
            "Для работы с потоками",
            "Для работы с базами данных"
          ],
          "correctAnswer": "Для работы с операторами",
          "explanation": "Модуль operator содержит функции, соответствующие стандартным операторам, например, operator.add."
        },
        {
          "text": "Что такое GIL?",
          "options": [
            "Global Interpreter Lock",
            "Global Input Lock",
            "Generalized Interruption Lock",
            "Global Instance Lock"
          ],
          "correctAnswer": "Global Interpreter Lock",
          "explanation": "GIL — это механизм, который позволяет выполнять только один поток Python в любой момент времени."
        },
        {
          "text": "Каковы проблемы GIL?",
          "options": [
            "Снижает производительность при CPU-bound задачах",
            "Упрощает интеграцию non thread safe библиотек",
            "Не влияет на I/O операции",
            "Все вышеперечисленные"
          ],
          "correctAnswer": "Все вышеперечисленные",
          "explanation": "GIL может снижать производительность при CPU-bound задачах, но упрощает интеграцию библиотек и не влияет на I/O операции."
        },
        {
          "text": "Работали ли вы с asyncio? В чем его особенность?",
          "options": [
            "Asyncio позволяет создавать потоки",
            "Asyncio использует корутины для асинхронного программирования",
            "Asyncio не поддерживает многопоточность",
            "Asyncio работает только с Python 3"
          ],
          "correctAnswer": "Asyncio использует корутины для асинхронного программирования",
          "explanation": "Asyncio позволяет писать асинхронный код, используя корутины, что позволяет эффективно обрабатывать множество соединений."
        },
        {
          "text": "Что такое async/await?",
          "options": [
            "Ключевые слова для создания асинхронных функций",
            "Ключевые слова для создания потоков",
            "Ключевые слова для работы с файлами",
            "Ключевые слова для работы с базами данных"
          ],
          "correctAnswer": "Ключевые слова для создания асинхронных функций",
          "explanation": "async/await используются для написания асинхронного кода, который не блокирует поток выполнения."
        },
        {
          "text": "Как в Python реализуется многопоточность?",
          "options": [
            "С помощью модуля threading",
            "С помощью модуля multiprocessing",
            "С помощью модуля asyncio",
            "С помощью модуля concurrent"
          ],
          "correctAnswer": "С помощью модуля threading",
          "explanation": "Модуль threading позволяет реализовать многопоточность в Python, используя нативные POSIX-треды."
        },
        {
          "text": "В чем отличие тредов от мультипроцессинга?",
          "options": [
            "Треды имеют общее адресное пространство, процессы - независимые",
            "Процессы работают быстрее, чем треды",
            "Треды используют больше памяти, чем процессы",
            "Процессы всегда блокируют выполнение"
          ],
          "correctAnswer": "Треды имеют общее адресное пространство, процессы - независимые",
          "explanation": "Процессы имеют раздельные адресные пространства, в то время как треды работают в общем адресном пространстве."
        },
        {
          "text": "Какие задачи хорошо параллелятся?",
          "options": [
            "Задачи с долгим вводом-выводом",
            "Задачи с интенсивными вычислениями",
            "Задачи, требующие много памяти",
            "Задачи, не требующие ввода-вывода"
          ],
          "correctAnswer": "Задачи с долгим вводом-выводом",
          "explanation": "Задачи, которые требуют долгого ожидания ввода-вывода, хорошо параллелятся, так как треды могут переключаться."
        },
        {
          "text": "Нужно посчитать 100 уравнений. Делать это в тредах или нет?",
          "options": [
            "Да, это хорошо подходит для тредов",
            "Нет, это неэффективно для тредов",
            "Да, это ускорит выполнение",
            "Нет, это всегда блокирует выполнение"
          ],
          "correctAnswer": "Нет, это неэффективно для тредов",
          "explanation": "Для задач, не требующих ввода-вывода, лучше использовать процессы, так как треды будут тратить время на переключение."
        },
        {
          "text": "Треды в Питоне — это нативные треды или нет?",
          "options": [
            "Да, это нативные треды",
            "Нет, это виртуальные треды",
            "Да, это только в Windows",
            "Нет, это только в Linux"
          ],
          "correctAnswer": "Да, это нативные треды",
          "explanation": "Треды в Python являются нативными Posix-совместимыми тредами, которые исполняются на уровне операционной системы."
        },
        {
          "text": "Что такое гринлеты?",
          "options": [
            "Легковесные треды внутри виртуальной машины",
            "Треды, управляемые операционной системой",
            "Процессы, работающие параллельно",
            "Функции, которые не возвращают значения"
          ],
          "correctAnswer": "Легковесные треды внутри виртуальной машины",
          "explanation": "Гринлеты — это легковесные треды, которые управляются виртуальной машиной и не видны операционной системе."
        },
        {
          "text": "Какие варианты реализации шаблона Singleton на питоне?",
          "options": [
            "Декоратор, базовый класс, метаклассы",
            "Только декоратор",
            "Только базовый класс",
            "Только метаклассы"
          ],
          "correctAnswer": "Декоратор, базовый класс, метаклассы",
          "explanation": "Существует несколько способов реализации шаблона Singleton, включая декораторы, базовые классы и метаклассы."
        },
        {
          "text": "Какие вы знаете инструменты для проверки кодстиля?",
          "options": [
            "Pycodestyle, Pylint, Flake8",
            "Only Pylint",
            "Only Flake8",
            "Only Pycodestyle"
          ],
          "correctAnswer": "Pycodestyle, Pylint, Flake8",
          "explanation": "Существует множество инструментов для проверки кодстиля, включая Pycodestyle, Pylint и Flake8."
        },
        {
          "text": "Что такое list/dict comprehension?",
          "options": [
            "Выражение для создания списков и словарей",
            "Метод для сортировки списков",
            "Функция для работы с файлами",
            "Класс для работы с данными"
          ],
          "correctAnswer": "Выражение для создания списков и словарей",
          "explanation": "List и dict comprehension позволяют создавать списки и словари с использованием выражений и циклов."
        },
        {
          "text": "Какая разница между одинарным и двойным подчеркиванием?",
          "options": [
            "Одинарное подчеркивание используется для приватных переменных, двойное - для специальных",
            "Одинарное подчеркивание используется для публичных переменных, двойное - для приватных",
            "Одинарное подчеркивание - это ошибка, двойное - это стандарт",
            "Нет никакой разницы"
          ],
          "correctAnswer": "Одинарное подчеркивание используется для приватных переменных, двойное - для специальных",
          "explanation": "Одинарное подчеркивание указывает на приватные переменные, а двойное - на специальные методы и атрибуты."
        },
        {
          "text": "Отличие copy() от deepcopy()?",
          "options": [
            "copy() создает поверхностную копию, deepcopy() - глубокую",
            "copy() создает глубокую копию, deepcopy() - поверхностную",
            "Они идентичны",
            "copy() работает быстрее, чем deepcopy()"
          ],
          "correctAnswer": "copy() создает поверхностную копию, deepcopy() - глубокую",
          "explanation": "copy() создает новую ссылку на объект, а deepcopy() создает новый объект с копированием всех вложенных объектов."
        },
        {
          "text": "Что такое garbage collector?",
          "options": [
            "Сборщик мусора, освобождающий память",
            "Инструмент для анализа кода",
            "Метод для работы с файлами",
            "Функция для сортировки данных"
          ],
          "correctAnswer": "Сборщик мусора, освобождающий память",
          "explanation": "Garbage collector управляет памятью, удаляя объекты, которые больше не используются."
        },
        {
          "text": "Что такое интроспекция?",
          "options": [
            "Способность программы исследовать тип или свойства объекта во время работы",
            "Метод для работы с файлами",
            "Процесс создания объектов",
            "Способность программы изменять свои методы"
          ],
          "correctAnswer": "Способность программы исследовать тип или свойства объекта во время работы",
          "explanation": "Интроспекция позволяет узнать тип объекта и его атрибуты во время выполнения программы."
        },
        {
          "text": "Что такое рефлексия?",
          "options": [
            "Способность программы изменять свои методы и свойства во время выполнения",
            "Метод для работы с файлами",
            "Способность программы исследовать тип объекта",
            "Процесс создания объектов"
          ],
          "correctAnswer": "Способность программы изменять свои методы и свойства во время выполнения",
          "explanation": "Рефлексия позволяет вызывать методы и изменять объекты во время выполнения программы."
        }
      ]
    },
    {
      "id": "django",
      "name": "Django",
      "description": "Вопросы по Django.",
      "questions": [
        {
          "text": "Что такое Middleware и для чего он нужен?",
          "options": [
            "Объект, который изменяет входящий запрос или исходящий ответ",
            "Объект, который обрабатывает только входящие запросы",
            "Объект, который отвечает за работу с базой данных",
            "Объект, который управляет сессиями пользователей"
          ],
          "correctAnswer": "Объект, который изменяет входящий запрос или исходящий ответ",
          "explanation": "Middleware обрабатывает все запросы приложения, изменяя их или добавляя заголовки."
        },
        {
          "text": "Назовите основные мидлвари и их назначение.",
          "options": [
            "SessionMiddleware, CsrfViewMiddleware, AuthenticationMiddleware, MessageMiddleware",
            "Only SessionMiddleware",
            "Only CsrfViewMiddleware",
            "Only AuthenticationMiddleware"
          ],
          "correctAnswer": "SessionMiddleware, CsrfViewMiddleware, AuthenticationMiddleware, MessageMiddleware",
          "explanation": "Основные мидлвари включают поддержку сессий, проверку CSRF, авторизацию пользователей и передачу сообщений."
        },
        {
          "text": "Опишите алгоритм работы CSRF middleware.",
          "options": [
            "Генерация токена и проверка его на совпадение",
            "Создание сессии для каждого пользователя",
            "Проверка всех запросов на наличие ошибок",
            "Отправка уведомлений пользователям"
          ],
          "correctAnswer": "Генерация токена и проверка его на совпадение",
          "explanation": "CSRF middleware генерирует уникальный токен для каждого запроса и проверяет его при отправке формы."
        },
        {
          "text": "Что такое сигналы в Django?",
          "options": [
            "События, которые оповещают приложение о произошедших действиях",
            "Методы для работы с базой данных",
            "Функции для обработки запросов",
            "Классы для создания моделей"
          ],
          "correctAnswer": "События, которые оповещают приложение о произошедших действиях",
          "explanation": "Сигналы позволяют различным частям приложения реагировать на события, такие как начало и окончание запроса."
        },
        {
          "text": "Как реализуется связь m2m на уровне базы данных?",
          "options": [
            "Создается таблица-мост с ключами на обе модели",
            "Создается отдельная таблица для каждой модели",
            "Связь реализуется через внешние ключи",
            "Связь не поддерживается в Django"
          ],
          "correctAnswer": "Создается таблица-мост с ключами на обе модели",
          "explanation": "Связь многие ко многим реализуется через таблицу-мост, которая хранит ключи на обе модели."
        },
        {
          "text": "Чем лучше отправлять форму — GET или POST?",
          "options": [
            "GET, так как он быстрее",
            "POST, так как он безопаснее для передачи данных",
            "Оба метода одинаковы",
            "GET, так как он проще в реализации"
          ],
          "correctAnswer": "POST, так как он безопаснее для передачи данных",
          "explanation": "POST-запросы не кешируются и не сохраняются в истории браузера, что делает их более безопасными для передачи конфиденциальной информации."
        },
        {
          "text": "Как работает Serializer в Django REST Framework?",
          "options": [
            "Преобразует данные в формат, который можно передать через API",
            "Создает новые модели в базе данных",
            "Обрабатывает запросы к базе данных",
            "Управляет сессиями пользователей"
          ],
          "correctAnswer": "Преобразует данные в формат, который можно передать через API",
          "explanation": "Serializer преобразует данные из модели Django в формат JSON для передачи через API и обратно."
        },
        {
          "text": "Что такое Meta в классах Django?",
          "options": [
            "Класс, который управляет метаданными модели",
            "Класс, который отвечает за обработку запросов",
            "Класс, который создает другие классы",
            "Класс, который управляет сессиями"
          ],
          "correctAnswer": "Класс, который управляет метаданными модели",
          "explanation": "Meta используется для определения параметров модели, таких как имя таблицы и порядок сортировки."
        },
        {
          "text": "За что отвечает Meta в сериализаторе?",
          "options": [
            "Определяет модель и поля, которые будут включены",
            "Управляет сессиями пользователей",
            "Создает новые экземпляры модели",
            "Обрабатывает запросы к базе данных"
          ],
          "correctAnswer": "Определяет модель и поля, которые будут включены",
          "explanation": "Meta в сериализаторе позволяет указать, какие поля модели будут сериализованы и какие будут исключены."
        },
        {
          "text": "Какая разница в быстродействии между Django и Flask?",
          "options": [
            "Django быстрее, так как он более оптимизирован",
            "Flask быстрее, так как он легче и проще",
            "Оба фреймворка имеют одинаковую производительность",
            "Django всегда медленнее, чем Flask"
          ],
          "correctAnswer": "Flask быстрее, так как он легче и проще",
          "explanation": "Flask предоставляет больше гибкости и меньше накладных расходов, что делает его более быстрым для небольших приложений."
        }
      ]
    },
    {
      "id": "web_development",
      "name": "Веб-разработка",
      "description": "Вопросы по веб-разработке.",
      "questions": [
        {
          "text": "Что такое CGI?",
          "options": [
            "Common Gateway Interface",
            "Common Graphics Interface",
            "Common General Interface",
            "Common Gateway Integration"
          ],
          "correctAnswer": "Common Gateway Interface",
          "explanation": "CGI — это соглашение о том, как веб-сервер взаимодействует с программой, написанной на каком-то языке."
        },
        {
          "text": "Каковы плюсы CGI?",
          "options": [
            "Протокол не накладывает условия на язык, простота, отсутствие состояния",
            "Высокая скорость обработки запросов",
            "Поддержка всех языков программирования",
            "Безопасность данных"
          ],
          "correctAnswer": "Протокол не накладывает условия на язык, простота, отсутствие состояния",
          "explanation": "Плюсы CGI включают в себя отсутствие ограничений на язык, простоту протокола и отсутствие состояния программы."
        },
        {
          "text": "Каковы минусы CGI?",
          "options": [
            "Медленный запуск процесса на каждый запрос",
            "Сложность в отладке",
            "Отсутствие поддержки языков",
            "Невозможность работы с данными"
          ],
          "correctAnswer": "Медленный запуск процесса на каждый запрос",
          "explanation": "Минусы CGI включают медленный запуск процесса операционной системы на каждый запрос и медленную передачу данных через stdout."
        },
        {
          "text": "Какая разница между аутентификацией и авторизацией?",
          "options": [
            "Аутентификация определяет, кто вы, авторизация определяет, что вы можете делать",
            "Аутентификация и авторизация - это одно и то же",
            "Аутентификация - это проверка пароля, авторизация - это проверка имени",
            "Аутентификация происходит после авторизации"
          ],
          "correctAnswer": "Аутентификация определяет, кто вы, авторизация определяет, что вы можете делать",
          "explanation": "Аутентификация проверяет личность пользователя, а авторизация определяет его права доступа."
        },
        {
          "text": "Что такое идентификация?",
          "options": [
            "Процесс проверки полномочий пользователя",
            "Процесс присвоения идентификатора субъектам и объектам",
            "Процесс проверки пароля",
            "Процесс предоставления доступа к ресурсам"
          ],
          "correctAnswer": "Процесс присвоения идентификатора субъектам и объектам",
          "explanation": "Идентификация - это процесс присвоения идентификатора и сравнение его с перечнем присвоенных идентификаторов."
        },
        {
          "text": "Каковы три основные процедуры аутентификации и авторизации?",
          "options": [
            "Идентификация, аутентификация, авторизация",
            "Аутентификация, авторизация, проверка пароля",
            "Идентификация, проверка пароля, предоставление доступа",
            "Аутентификация, идентификация, проверка прав"
          ],
          "correctAnswer": "Идентификация, аутентификация, авторизация",
          "explanation": "Процессы взаимосвязаны: сначала идентификация, затем аутентификация и, наконец, авторизация."
        },
        {
          "text": "Что такое XSS?",
          "options": [
            "Межсайтовые запросы",
            "Межсайтовый скриптинг",
            "Межсайтовая безопасность",
            "Межсайтовая сессия"
          ],
          "correctAnswer": "Межсайтовый скриптинг",
          "explanation": "XSS (Cross-Site Scripting) — это уязвимость, позволяющая злоумышленникам внедрять скрипты на веб-страницы."
        },
        {
          "text": "Как можно защитить приложение от XSS?",
          "options": [
            "Экранирование небезопасных символов и санация HTML-тегов",
            "Использование HTTPS",
            "Регулярные обновления системы",
            "Ограничение доступа к API"
          ],
          "correctAnswer": "Экранирование небезопасных символов и санация HTML-тегов",
          "explanation": "Защита от XSS включает экранирование небезопасных символов и очистку HTML-тегов перед их отображением."
        },
        {
          "text": "Какой пример XSS уязвимости?",
          "options": [
            "Внедрение скрипта в комментарий",
            "Отправка формы без проверки",
            "Использование устаревших библиотек",
            "Отсутствие HTTPS"
          ],
          "correctAnswer": "Внедрение скрипта в комментарий",
          "explanation": "Примером XSS является внедрение JavaScript-кода в комментарий, который затем исполняется браузером других пользователей."
        },
        {
          "text": "Что такое REST?",
          "options": [
            "Протокол для обмена сообщениями",
            "Архитектурный стиль для проектирования веб-сервисов",
            "Стандарт для работы с базами данных",
            "Метод аутентификации"
          ],
          "correctAnswer": "Архитектурный стиль для проектирования веб-сервисов",
          "explanation": "REST (Representational State Transfer) — это архитектурный стиль, который определяет, как строить веб-сервисы."
        },
        {
          "text": "Каковы основные методы HTTP, используемые в REST?",
          "options": [
            "GET, POST, PUT, DELETE, PATCH, HEAD",
            "GET, POST, SOAP, DELETE",
            "PUT, PATCH, DELETE, OPTIONS",
            "GET, POST, PUT, SOAP"
          ],
          "correctAnswer": "GET, POST, PUT, DELETE, PATCH, HEAD",
          "explanation": "Основные методы HTTP, используемые в REST, включают GET, POST, PUT, DELETE, PATCH и HEAD."
        },
        {
          "text": "Каковы архитектурные ограничения REST?",
          "options": [
            "Единообразие интерфейса, клиент-сервер, отсутствие состояния, кэширование, слои, код по требованию",
            "Только клиент-сервер и кэширование",
            "Только отсутствие состояния и кэширование",
            "Нет никаких ограничений"
          ],
          "correctAnswer": "Единообразие интерфейса, клиент-сервер, отсутствие состояния, кэширование, слои, код по требованию",
          "explanation": "REST определяет шесть архитектурных ограничений, которые помогают создать настоящий RESTful API."
        },
        {
          "text": "Что такое SOAP?",
          "options": [
            "Протокол для обмена структурированными сообщениями",
            "Метод аутентификации",
            "Формат данных для веб-сервисов",
            "Архитектурный стиль для проектирования веб-сервисов"
          ],
          "correctAnswer": "Протокол для обмена структурированными сообщениями",
          "explanation": "SOAP (Simple Object Access Protocol) — это протокол для обмена структурированными сообщениями в распределённых вычислительных средах."
        },
        {
          "text": "В чем разница между REST и SOAP?",
          "options": [
            "REST поддерживает различные форматы, SOAP - только XML",
            "REST работает только по HTTP, SOAP - по любым протоколам",
            "REST работает с ресурсами, SOAP - с операциями",
            "Все вышеперечисленное"
          ],
          "correctAnswer": "Все вышеперечисленное",
          "explanation": "REST и SOAP имеют множество различий, включая поддержку форматов, протоколов и подход к работе с ресурсами."
        },
        {
          "text": "Что такое SOAP?",
          "options": [
            "Протокол обмена структурированными сообщениями",
            "Метод аутентификации",
            "Формат данных для веб-сервисов",
            "Архитектурный стиль для проектирования веб-сервисов"
          ],
          "correctAnswer": "Протокол обмена структурированными сообщениями",
          "explanation": "SOAP (Simple Object Access Protocol) — это протокол для обмена структурированными сообщениями в распределённых вычислительных средах."
        },
        {
          "text": "Какова основная цель SOAP?",
          "options": [
            "Обмен произвольными сообщениями в формате XML",
            "Создание веб-страниц",
            "Управление базами данных",
            "Аутентификация пользователей"
          ],
          "correctAnswer": "Обмен произвольными сообщениями в формате XML",
          "explanation": "SOAP изначально предназначался для реализации удалённого вызова процедур, но теперь используется для обмена произвольными сообщениями в формате XML."
        },
        {
          "text": "С какими протоколами может использоваться SOAP?",
          "options": [
            "HTTP, HTTPS, SMTP, FTP",
            "Только HTTP",
            "Только FTP",
            "Только HTTPS"
          ],
          "correctAnswer": "HTTP, HTTPS, SMTP, FTP",
          "explanation": "SOAP может использоваться с любым протоколом прикладного уровня, включая HTTP, HTTPS, SMTP и FTP."
        },
        {
          "text": "В чем разница между REST и SOAP веб-сервисами?",
          "options": [
            "REST поддерживает различные форматы, SOAP - только XML",
            "REST работает только по HTTP, SOAP - по любым протоколам",
            "REST работает с ресурсами, SOAP - с операциями",
            "Все вышеперечисленное"
          ],
          "correctAnswer": "Все вышеперечисленное",
          "explanation": "REST и SOAP имеют множество различий, включая поддержку форматов, протоколов и подход к работе с ресурсами."
        },
        {
          "text": "Какой из следующих форматов поддерживает REST?",
          "options": [
            "Только XML",
            "Только JSON",
            "Только текст",
            "JSON, XML, текст"
          ],
          "correctAnswer": "JSON, XML, текст",
          "explanation": "REST поддерживает различные форматы, включая JSON, XML и текст."
        },
        {
          "text": "Какой из следующих протоколов не поддерживает SOAP?",
          "options": [
            "HTTP",
            "HTTPS",
            "FTP",
            "REST"
          ],
          "correctAnswer": "REST",
          "explanation": "SOAP может работать с различными протоколами, но REST не является протоколом, а архитектурным стилем."
        },
        {
          "text": "Можно ли отправлять SOAP сообщения с вложением?",
          "options": [
            "Да, это возможно",
            "Нет, это невозможно",
            "Только текстовые сообщения",
            "Только изображения"
          ],
          "correctAnswer": "Да, это возможно",
          "explanation": "SOAP сообщения могут содержать вложения различных форматов, включая PDF и изображения, с использованием расширения MIME."
        },
        {
          "text": "Какой формат вложений поддерживает SOAP?",
          "options": [
            "Только текст",
            "Только изображения",
            "PDF, изображения и другие двоичные данные",
            "Только XML"
          ],
          "correctAnswer": "PDF, изображения и другие двоичные данные",
          "explanation": "SOAP поддерживает вложения различных форматов, включая PDF и изображения, с использованием расширения MIME."
        },
        {
          "text": "Как бы вы решили, какой из REST или SOAP веб-сервисов использовать?",
          "options": [
            "REST для простоты, SOAP для стандарта",
            "SOAP для простоты, REST для стандарта",
            "Оба одинаковы",
            "Ни один из них не подходит"
          ],
          "correctAnswer": "REST для простоты, SOAP для стандарта",
          "explanation": "REST предлагает скорость и расширяемость, в то время как SOAP предоставляет больше возможностей по безопасности и транзакционной безопасности."
        },
        {
          "text": "Каковы основные преимущества REST?",
          "options": [
            "Скорость, расширяемость, поддержка многих форматов",
            "Безопасность и транзакционная безопасность",
            "Только поддержка XML",
            "Только работа по HTTP"
          ],
          "correctAnswer": "Скорость, расширяемость, поддержка многих форматов",
          "explanation": "REST предлагает высокую скорость, расширяемость и поддержку различных форматов данных."
        },
        {
          "text": "Каковы основные преимущества SOAP?",
          "options": [
            "Скорость и простота",
            "Безопасность (WS-security) и транзакционная безопасность (ACID)",
            "Поддержка только JSON",
            "Работа только по HTTP"
          ],
          "correctAnswer": "Безопасность (WS-security) и транзакционная безопасность (ACID)",
          "explanation": "SOAP предлагает более высокие уровни безопасности и поддержку транзакционной безопасности."
        }
      ]
    },
    {
      "id": "http",
      "name": "HTTP",
      "description": "Вопросы по протоколу HTTP.",
      "questions": [
        {
          "text": "Как устроен протокол HTTP?",
          "options": [
            "Это текстовый протокол, работающий поверх TCP/IP",
            "Это бинарный протокол, работающий поверх UDP",
            "Это протокол, работающий только с текстовыми данными",
            "Это протокол, который не использует заголовки"
          ],
          "correctAnswer": "Это текстовый протокол, работающий поверх TCP/IP",
          "explanation": "HTTP — это текстовый протокол, который работает поверх TCP/IP и состоит из запроса и ответа."
        },
        {
          "text": "Что включает в себя стартовая строка запроса HTTP?",
          "options": [
            "Метод, путь и версия протокола",
            "Только метод и путь",
            "Только путь и версия",
            "Метод и заголовки"
          ],
          "correctAnswer": "Метод, путь и версия протокола",
          "explanation": "Стартовая строка запроса состоит из метода, пути и версии протокола, например, `GET /index.html HTTP/1.1`."
        },
        {
          "text": "Что такое заголовки в HTTP?",
          "options": [
            "Набор пар ключ-значение, передающих метаданные запроса",
            "Тело ответа",
            "Стартовая строка ответа",
            "Метод запроса"
          ],
          "correctAnswer": "Набор пар ключ-значение, передающих метаданные запроса",
          "explanation": "Заголовки в HTTP — это набор пар ключ-значение, которые передают метаданные запроса, такие как `User-Agent` и `Content-Type`."
        },
        {
          "text": "Как отделяется тело ответа от заголовков в HTTP?",
          "options": [
            "С помощью пустой строки",
            "С помощью двоеточия",
            "С помощью запятой",
            "С помощью пробела"
          ],
          "correctAnswer": "С помощью пустой строки",
          "explanation": "Тело ответа отделяется от заголовков пустой строкой."
        },
        {
          "text": "Как выглядит raw запрос к главной странице Яндекса?",
          "options": [
            "GET / HTTP/1.1\nHost: ya.ru",
            "POST / HTTP/1.1\nHost: ya.ru",
            "GET ya.ru HTTP/1.1",
            "HEAD / HTTP/1.1\nHost: ya.ru"
          ],
          "correctAnswer": "GET / HTTP/1.1\nHost: ya.ru",
          "explanation": "Raw запрос к главной странице Яндекса выглядит как `GET / HTTP/1.1` с заголовком `Host: ya.ru`."
        },
        {
          "text": "Что означает метод GET в HTTP?",
          "options": [
            "Получить данные с сервера",
            "Отправить данные на сервер",
            "Удалить данные с сервера",
            "Обновить данные на сервере"
          ],
          "correctAnswer": "Получить данные с сервера",
          "explanation": "Метод GET используется для получения данных с сервера."
        },
        {
          "text": "Какой заголовок обязателен в HTTP запросе?",
          "options": [
            "User-Agent",
            "Host",
            "Content-Type",
            "Authorization"
          ],
          "correctAnswer": "Host",
          "explanation": "Заголовок `Host` должен быть всегда присутствовать в HTTP запросе."
        },
        {
          "text": "Как клиенту понять, удался запрос или нет?",
          "options": [
            "Проверить статус ответа",
            "Проверить заголовки ответа",
            "Проверить тело ответа",
            "Проверить время ответа"
          ],
          "correctAnswer": "Проверить статус ответа",
          "explanation": "Клиент может понять, удался ли запрос, проверив статус ответа, который делится на группы с различной семантикой."
        },
        {
          "text": "Что означает статус 2xx в HTTP?",
          "options": [
            "Запрос прошел успешно",
            "Ошибка по вине пользователя",
            "Ошибка по вине сервера",
            "Перенаправление на другой ресурс"
          ],
          "correctAnswer": "Запрос прошел успешно",
          "explanation": "Статусы 2xx указывают на то, что запрос был успешно обработан."
        },
        {
          "text": "Какой статус указывает на ошибку по вине пользователя?",
          "options": [
            "1xx",
            "2xx",
            "3xx",
            "4xx"
          ],
          "correctAnswer": "4xx",
          "explanation": "Статусы 4xx указывают на ошибки, произошедшие по вине пользователя, например, отсутствие прав доступа."
        },
        {
          "text": "Какой статус указывает на ошибку по вине сервера?",
          "options": [
            "3xx",
            "4xx",
            "5xx",
            "2xx"
          ],
          "correctAnswer": "5xx",
          "explanation": "Статусы 5xx указывают на ошибки, произошедшие по вине сервера, такие как ошибки в коде или конфигурации."
        },
        {
          "text": "Что нужно отправить браузеру, чтобы перенаправить на другую страницу?",
          "options": [
            "Статус 200 и заголовок Location",
            "Статус 301 или 302 и заголовок Location",
            "Только заголовок Location",
            "Статус 404 и заголовок Location"
          ],
          "correctAnswer": "Статус 301 или 302 и заголовок Location",
          "explanation": "Минимальный ответ для перенаправления должен содержать статус 301 или 302 и заголовок Location с адресом нового ресурса."
        },
        {
          "text": "Что указывает заголовок Location в HTTP ответе?",
          "options": [
            "Адрес ресурса, на который следует перейти",
            "Тип контента",
            "Статус ответа",
            "Время ответа"
          ],
          "correctAnswer": "Адрес ресурса, на который следует перейти",
          "explanation": "Заголовок Location указывает адрес ресурса, на который браузер должен перенаправить пользователя."
        },
        {
          "text": "Что можно разместить в теле ответа при перенаправлении?",
          "options": [
            "HTML со ссылкой на новый ресурс",
            "Только текст",
            "JSON данные",
            "Ничего, тело должно быть пустым"
          ],
          "correctAnswer": "HTML со ссылкой на новый ресурс",
          "explanation": "В теле ответа можно разместить HTML со ссылкой на новый ресурс для пользователей старых браузеров."
        },
        {
          "text": "Как управлять кешированием в HTTP?",
          "options": [
            "С помощью заголовков Cache и Cache-Control",
            "С помощью заголовков Content-Type",
            "С помощью заголовков User-Agent",
            "Кеширование невозможно в HTTP"
          ],
          "correctAnswer": "С помощью заголовков Cache и Cache-Control",
          "explanation": "Заголовки Cache и Cache-Control регулируют время жизни, политику обновления и поведение прокси-сервера."
        },
        {
          "text": "Что делают заголовки Last-Modified и If-Modified-Since?",
          "options": [
            "Регулируют кеширование по времени",
            "Указывают тип контента",
            "Определяют статус ответа",
            "Управляют авторизацией"
          ],
          "correctAnswer": "Регулируют кеширование по времени",
          "explanation": "Эти заголовки задают кеширование в зависимости от даты обновления документа."
        },
        {
          "text": "Что такое Etag в HTTP?",
          "options": [
            "Заголовок для кеширования документа по его уникальному хешу",
            "Заголовок для указания типа контента",
            "Заголовок для управления сессиями",
            "Заголовок для авторизации"
          ],
          "correctAnswer": "Заголовок для кеширования документа по его уникальному хешу",
          "explanation": "Etag используется для кеширования документа, позволяя серверу определить, изменился ли документ."
        },
        {
          "text": "Как кэшируются файлы на уровне протокола?",
          "options": [
            "С помощью заголовка Etag и MD5-хеша файла",
            "С помощью заголовка Cache-Control",
            "С помощью заголовка Last-Modified",
            "Кэширование невозможно на уровне протокола"
          ],
          "correctAnswer": "С помощью заголовка Etag и MD5-хеша файла",
          "explanation": "Когда Nginx отдает статичный файл, он добавляет заголовок Etag, который содержит MD5-хеш файла."
        },
        {
          "text": "Что происходит, если хеш файла не совпадает при запросе?",
          "options": [
            "Сервер отвечает с кодом 200 и отправляет актуальный файл",
            "Сервер отвечает с кодом 304 Not Modified",
            "Сервер игнорирует запрос",
            "Сервер отправляет ошибку 404"
          ],
          "correctAnswer": "Сервер отвечает с кодом 200 и отправляет актуальный файл",
          "explanation": "Если хеши не совпадают, сервер отвечает с кодом 200 и отправляет актуальный файл с новым хешем."
        },
        {
          "text": "Что происходит, если хеши равны при запросе файла?",
          "options": [
            "Сервер отвечает с кодом 200 и отправляет актуальный файл",
            "Сервер отвечает с кодом 304 Not Modified с пустым телом",
            "Сервер отправляет ошибку 404",
            "Сервер игнорирует запрос"
          ],
          "correctAnswer": "Сервер отвечает с кодом 304 Not Modified с пустым телом",
          "explanation": "Если хеши равны, сервер отвечает с кодом 304 Not Modified, и браузер использует локальную копию файла."
        },
        {
          "text": "Что такое HTTP?",
          "options": [
            "Протокол передачи гипертекста",
            "Протокол передачи данных",
            "Протокол для обмена сообщениями",
            "Все вышеперечисленное"
          ],
          "correctAnswer": "Все вышеперечисленное",
          "explanation": "HTTP (HyperText Transfer Protocol) — это широко распространённый протокол передачи данных, предназначенный для передачи гипертекстовых документов."
        },
        {
          "text": "На каком уровне модели OSI находится протокол HTTP?",
          "options": [
            "На прикладном (7-м) уровне",
            "На транспортном (4-м) уровне",
            "На сетевом (3-м) уровне",
            "На канальном (2-м) уровне"
          ],
          "correctAnswer": "На прикладном (7-м) уровне",
          "explanation": "HTTP является протоколом прикладного уровня в соответствии со спецификацией OSI."
        },
        {
          "text": "Какова основная задача протокола HTTP?",
          "options": [
            "Обмен данными между клиентом и сервером",
            "Передача файлов",
            "Управление сессиями",
            "Шифрование данных"
          ],
          "correctAnswer": "Обмен данными между клиентом и сервером",
          "explanation": "Основная задача HTTP — обмен данными между клиентским приложением (например, веб-браузером) и веб-сервером."
        },
        {
          "text": "Какую версию протокола описывает спецификация RFC 2616?",
          "options": [
            "HTTP 1.0",
            "HTTP 1.1",
            "HTTP 2.0",
            "HTTP 3.0"
          ],
          "correctAnswer": "HTTP 1.1",
          "explanation": "Спецификация RFC 2616 описывает актуальную на данный момент версию протокола HTTP 1.1."
        }
      ]
    },
    {
      "id": "oop",
      "name": "ООП",
      "description": "Вопросы по объектно-ориентированному программированию.",
      "questions": [
        {
          "text": "Что такое инкапсуляция?",
          "options": [
            "Сокрытие данных и методов в объекте",
            "Объединение данных и методов в единый объект",
            "Процесс создания объектов",
            "Наследование свойств от родительского класса"
          ],
          "correctAnswer": "Объединение данных и методов в единый объект",
          "explanation": "Инкапсуляция — это механизм, позволяющий объединить данные и методы, работающие с этими данными, в единый объект и скрыть детали реализации от пользователя."
        },
        {
          "text": "Какова основная цель инкапсуляции?",
          "options": [
            "Сокрытие данных",
            "Сбор знаний о сущности в одном месте",
            "Упрощение кода",
            "Увеличение производительности"
          ],
          "correctAnswer": "Сбор знаний о сущности в одном месте",
          "explanation": "Основное назначение инкапсуляции — собрать в одном месте знания, относящиеся к устройству некой сущности и правилам обращения с ней."
        },
        {
          "text": "Как инкапсуляция помогает избежать размазывания знаний?",
          "options": [
            "Скрывает детали реализации",
            "Упрощает код",
            "Увеличивает скорость выполнения",
            "Снижает количество ошибок"
          ],
          "correctAnswer": "Скрывает детали реализации",
          "explanation": "Инкапсуляция помогает собрать все знания о реализации в одном месте, что предотвращает размазывание этих знаний по всему коду."
        },
        {
          "text": "Что такое сокрытие данных?",
          "options": [
            "Сокрытие методов от пользователя",
            "Защита данных от несанкционированного доступа",
            "Удаление данных из объекта",
            "Сокрытие объектов в памяти"
          ],
          "correctAnswer": "Защита данных от несанкционированного доступа",
          "explanation": "Сокрытие данных — это процесс, при котором данные защищаются от несанкционированного доступа, что является частью инкапсуляции."
        },
        {
          "text": "Что такое наследование в ООП?",
          "options": [
            "Механизм, позволяющий описывать новый класс на основе существующего",
            "Процесс создания объектов",
            "Способ сокрытия данных",
            "Метод для работы с массивами"
          ],
          "correctAnswer": "Механизм, позволяющий описывать новый класс на основе существующего",
          "explanation": "Наследование — это механизм языка, который позволяет создавать новый класс на основе уже существующего."
        },
        {
          "text": "Почему наследование может быть вредным в ООП?",
          "options": [
            "Потому что оно приводит к сильному связыванию",
            "Потому что оно усложняет код",
            "Потому что оно не поддерживает полиморфизм",
            "Потому что оно не позволяет создавать объекты"
          ],
          "correctAnswer": "Потому что оно приводит к сильному связыванию",
          "explanation": "В 'истинном' ООП наследование может быть причиной сильного связывания, что делает код менее гибким."
        },
        {
          "text": "Что предпочтительнее использовать вместо наследования?",
          "options": [
            "Композицию",
            "Абстракцию",
            "Инкапсуляцию",
            "Полиморфизм"
          ],
          "correctAnswer": "Композицию",
          "explanation": "Композиция предпочтительнее наследования, так как она обеспечивает большую гибкость и уменьшает связывание."
        },
        {
          "text": "Что такое полиморфизм в ООП?",
          "options": [
            "Способность объектов разных классов обрабатывать данные разных типов",
            "Способность одного класса наследовать свойства другого",
            "Способность класса скрывать свои данные",
            "Способность класса создавать экземпляры"
          ],
          "correctAnswer": "Способность объектов разных классов обрабатывать данные разных типов",
          "explanation": "Полиморфизм — это возможность схожим типам данных, которые заданы иерархией наследования, иметь различные реализации."
        },
        {
          "text": "Какие формы полиморфизма существуют?",
          "options": [
            "Специальный, параметрический, полиморфизм подтипов",
            "Наследование, инкапсуляция, абстракция",
            "Перегрузка, переопределение, композиция",
            "Только перегрузка методов"
          ],
          "correctAnswer": "Специальный, параметрический, полиморфизм подтипов",
          "explanation": "Полиморфизм имеет несколько форм: специальный (Ad-Hoc), параметрический и полиморфизм подтипов."
        },
        {
          "text": "Что такое полиморфизм подтипов?",
          "options": [
            "Способность функции обрабатывать данные разных типов",
            "Способность объектов одного класса иметь разные реализации",
            "Способность класса наследовать свойства другого класса",
            "Способность метода изменять свое поведение в зависимости от типа данных"
          ],
          "correctAnswer": "Способность объектов одного класса иметь разные реализации",
          "explanation": "Полиморфизм подтипов достигается с помощью механизмов наследования и апкаста, позволяя объектам одного класса иметь разные реализации."
        },
        {
          "text": "Что такое абстракция в ООП?",
          "options": [
            "Выделение важных характеристик объекта",
            "Сокрытие данных и методов",
            "Создание экземпляров классов",
            "Наследование свойств от родительского класса"
          ],
          "correctAnswer": "Выделение важных характеристик объекта",
          "explanation": "Абстракция — это процесс выделения важных характеристик объекта, позволяющий определить минимально необходимый набор этих характеристик для решения задачи."
        },
        {
          "text": "С чем часто путают абстракцию?",
          "options": [
            "С наследованием",
            "С инкапсуляцией",
            "С полиморфизмом",
            "С композицией"
          ],
          "correctAnswer": "С инкапсуляцией",
          "explanation": "Абстракцию часто путают с инкапсуляцией, так как обе концепции влияют на формирование публичного интерфейса типа."
        },
        {
          "text": "Какова основная цель абстракции?",
          "options": [
            "Сокрытие данных",
            "Определение минимально необходимого набора характеристик",
            "Создание интерфейсов",
            "Упрощение кода"
          ],
          "correctAnswer": "Определение минимально необходимого набора характеристик",
          "explanation": "Цель абстракции — выделить важные характеристики объекта, необходимые для решения поставленной задачи."
        }
      ]
    },
    {
      "id": "programming_principles",
      "name": "Принципы программирования",
      "description": "Вопросы по основным принципам программирования.",
      "questions": [
        {
          "text": "Что означает принцип KISS?",
          "options": [
            "Keep It Simple, Stupid",
            "Keep It Short and Simple",
            "Keep It Smart and Simple",
            "Keep It Simple and Safe"
          ],
          "correctAnswer": "Keep It Simple, Stupid",
          "explanation": "Принцип KISS (Keep It Simple, Stupid) призывает к тому, чтобы код оставался как можно более простым."
        },
        {
          "text": "Какой подход нарушает принцип KISS?",
          "options": [
            "Использование простых и понятных решений",
            "Написание сложных и хитроумных функций",
            "Оптимизация кода для повышения производительности",
            "Соблюдение стандартов кодирования"
          ],
          "correctAnswer": "Написание сложных и хитроумных функций",
          "explanation": "Нарушение принципа KISS происходит, когда код становится сложным и трудным для понимания, например, написание отдельной функции только для сложения."
        },
        {
          "text": "Почему важно следовать принципу KISS?",
          "options": [
            "Чтобы код был более эффективным",
            "Чтобы код был проще для понимания и поддержки",
            "Чтобы избежать использования комментариев",
            "Чтобы код был более сложным"
          ],
          "correctAnswer": "Чтобы код был проще для понимания и поддержки",
          "explanation": "Следование принципу KISS помогает сделать код более простым и понятным, что облегчает его поддержку."
        },
        {
          "text": "Что означает принцип DRY?",
          "options": [
            "Don't Repeat Yourself",
            "Do Repeat Yourself",
            "Don't Run Yourself",
            "Do Run Yourself"
          ],
          "correctAnswer": "Don't Repeat Yourself",
          "explanation": "Принцип DRY (Don't Repeat Yourself) напоминает о том, что повторяющееся поведение в коде следует обособлять для многократного использования."
        },
        {
          "text": "Почему важно следовать принципу DRY?",
          "options": [
            "Чтобы уменьшить размер программы",
            "Чтобы избежать рассинхронизации и багов",
            "Чтобы сделать код более сложным",
            "Чтобы увеличить количество повторяющегося кода"
          ],
          "correctAnswer": "Чтобы избежать рассинхронизации и багов",
          "explanation": "Следование принципу DRY помогает избежать дублирования кода, что может привести к ошибкам и увеличению размера программы."
        },
        {
          "text": "Как можно реализовать принцип DRY в коде?",
          "options": [
            "Выделяя повторяющиеся фрагменты в отдельные функции",
            "Копируя и вставляя код в разных местах",
            "Игнорируя повторяющийся код",
            "Создавая больше классов"
          ],
          "correctAnswer": "Выделяя повторяющиеся фрагменты в отдельные функции",
          "explanation": "Реализация принципа DRY включает выделение повторяющихся фрагментов кода в отдельные функции для многократного использования."
        },
        {
          "text": "Что означает принцип YAGNI?",
          "options": [
            "You Aren't Gonna Need It",
            "You Are Gonna Need It",
            "You Always Get New Ideas",
            "You Are Gonna Neglect It"
          ],
          "correctAnswer": "You Aren't Gonna Need It",
          "explanation": "Принцип YAGNI (You Aren't Gonna Need It) говорит о том, что не следует оставлять в коде ненужные точки расширения."
        },
        {
          "text": "Почему нежелательно оставлять точки расширения в коде?",
          "options": [
            "Они увеличивают размер кодовой базы и вносят ненужную сложность",
            "Они делают код более простым",
            "Они необходимы для тестирования",
            "Они улучшают производительность"
          ],
          "correctAnswer": "Они увеличивают размер кодовой базы и вносят ненужную сложность",
          "explanation": "Точки расширения могут усложнить код и увеличить его размер, что нежелательно."
        },
        {
          "text": "Когда следует игнорировать принцип YAGNI?",
          "options": [
            "Когда речь идет о заказанном функционале",
            "Когда код уже написан",
            "Когда проект завершен",
            "Когда нет времени на изменения"
          ],
          "correctAnswer": "Когда речь идет о заказанном функционале",
          "explanation": "Принцип YAGNI не применяется, если функционал уже заказан и необходим для проекта."
        },
        {
          "text": "Что означает аббревиатура SOLID?",
          "options": [
            "Принципы объектно-ориентированного программирования",
            "Принципы структурного программирования",
            "Принципы функционального программирования",
            "Принципы модульного программирования"
          ],
          "correctAnswer": "Принципы объектно-ориентированного программирования",
          "explanation": "SOLID — это аббревиатура от пяти принципов, способствующих созданию хорошего объектно-ориентированного кода."
        },
        {
          "text": "Какой принцип SOLID гласит, что каждый класс должен решать лишь одну задачу?",
          "options": [
            "Open-Closed Principle",
            "Single Responsibility Principle",
            "Liskov Substitution Principle",
            "Dependency Inversion Principle"
          ],
          "correctAnswer": "Single Responsibility Principle",
          "explanation": "Принцип единственной ответственности (Single Responsibility Principle) утверждает, что каждый класс должен решать лишь одну задачу."
        },
        {
          "text": "Какой принцип SOLID говорит о том, что программные сущности должны быть открыты для расширения, но не для модификации?",
          "options": [
            "Interface Segregation Principle",
            "Open-Closed Principle",
            "Dependency Inversion Principle",
            "Liskov Substitution Principle"
          ],
          "correctAnswer": "Open-Closed Principle",
          "explanation": "Принцип открытости-закрытости (Open-Closed Principle) гласит, что программные сущности должны быть открыты для расширения, но не для модификации."
        },
        {
          "text": "Какой принцип SOLID требует, чтобы подклассы могли служить заменой для своих суперклассов?",
          "options": [
            "Single Responsibility Principle",
            "Liskov Substitution Principle",
            "Dependency Inversion Principle",
            "Open-Closed Principle"
          ],
          "correctAnswer": "Liskov Substitution Principle",
          "explanation": "Принцип подстановки Барбары Лисков (Liskov Substitution Principle) требует, чтобы подклассы могли служить заменой для своих суперклассов."
        },
        {
          "text": "Какой принцип SOLID говорит о создании узкоспециализированных интерфейсов?",
          "options": [
            "Dependency Inversion Principle",
            "Interface Segregation Principle",
            "Single Responsibility Principle",
            "Open-Closed Principle"
          ],
          "correctAnswer": "Interface Segregation Principle",
          "explanation": "Принцип разделения интерфейса (Interface Segregation Principle) говорит о создании узкоспециализированных интерфейсов, предназначенных для конкретного клиента."
        },
        {
          "text": "Какой принцип SOLID утверждает, что объектом зависимости должна быть абстракция?",
          "options": [
            "Dependency Inversion Principle",
            "Single Responsibility Principle",
            "Open-Closed Principle",
            "Liskov Substitution Principle"
          ],
          "correctAnswer": "Dependency Inversion Principle",
          "explanation": "Принцип инверсии зависимостей (Dependency Inversion Principle) утверждает, что объектом зависимости должна быть абстракция, а не что-то конкретное."
        }
      ]
    },
    {
      "id": "general_questions",
      "name": "Общие вопросы",
      "description": "Вопросы по общим концепциям программирования.",
      "questions": [
        {
          "text": "Что такое связанность модулей (coupling)?",
          "options": [
            "Степень независимости модулей",
            "Степень зависимости модулей",
            "Степень сложности кода",
            "Степень производительности системы"
          ],
          "correctAnswer": "Степень зависимости модулей",
          "explanation": "Связанность модулей (coupling) характеризует степень зависимости модулей друг от друга."
        },
        {
          "text": "Какова цель минимизации связанности модулей?",
          "options": [
            "Увеличение производительности",
            "Упрощение кода",
            "Снижение зависимости между модулями",
            "Увеличение сложности системы"
          ],
          "correctAnswer": "Снижение зависимости между модулями",
          "explanation": "При проектировании систем необходимо стремиться к минимизации зависимости между модулями."
        },
        {
          "text": "Что такое связность (cohesion)?",
          "options": [
            "Степень независимости модулей",
            "Степень сложности кода",
            "Целостность и «плотность» модуля",
            "Степень производительности системы"
          ],
          "correctAnswer": "Целостность и «плотность» модуля",
          "explanation": "Связность (cohesion) характеризует целостность и «плотность» модуля, т.е. насколько модуль является простым с точки зрения его использования."
        },
        {
          "text": "Какой пример модуля имеет максимальную связность?",
          "options": [
            "Модуль проверки орфографии",
            "Модуль для работы с базами данных",
            "Модуль для обработки изображений",
            "Модуль для управления пользователями"
          ],
          "correctAnswer": "Модуль проверки орфографии",
          "explanation": "Примером модуля с максимальной связностью является модуль проверки орфографии, который выполняет одну единственную функцию."
        },
        {
          "text": "Что такое LRU кэш?",
          "options": [
            "Алгоритм, который вытесняет наименее недавно использованные значения",
            "Алгоритм, который хранит все значения в памяти",
            "Алгоритм, который использует наибольшее количество ресурсов",
            "Алгоритм, который всегда сохраняет последние значения"
          ],
          "correctAnswer": "Алгоритм, который вытесняет наименее недавно использованные значения",
          "explanation": "LRU (least recently used) — это алгоритм, при котором вытесняются значения, которые дольше всего не запрашивались."
        },
        {
          "text": "Как работает алгоритм LRU?",
          "options": [
            "Хранит время последнего запроса к значению",
            "Удаляет все значения из кэша",
            "Сохраняет только самые новые значения",
            "Не требует хранения времени запросов"
          ],
          "correctAnswer": "Хранит время последнего запроса к значению",
          "explanation": "Для работы алгоритма LRU необходимо хранить время последнего запроса к каждому значению."
        },
        {
          "text": "Что происходит, когда число закэшированных значений превосходит N в LRU кэше?",
          "options": [
            "Вытесняется значение, которое дольше всего не запрашивалось",
            "Все значения остаются в кэше",
            "Новые значения не могут быть добавлены",
            "Кэш очищается полностью"
          ],
          "correctAnswer": "Вытесняется значение, которое дольше всего не запрашивалось",
          "explanation": "Когда число закэшированных значений превышает N, вытесняется значение, которое дольше всего не запрашивалось."
        },
        {
          "text": "Что такое очереди сообщений (MQ)?",
          "options": [
            "Структура данных для хранения сообщений",
            "Связующее звено между различными процессами",
            "Метод обработки данных",
            "Протокол передачи данных"
          ],
          "correctAnswer": "Связующее звено между различными процессами",
          "explanation": "Очереди сообщений (MQ) являются связующим звеном между различными процессами в приложениях и обеспечивают надежный интерфейс взаимодействия."
        },
        {
          "text": "Какова основная дисциплина доступа к элементам в очереди?",
          "options": [
            "Первый пришёл — первый вышел (FIFO)",
            "Последний пришёл — первый вышел (LIFO)",
            "Случайный доступ",
            "Доступ по индексу"
          ],
          "correctAnswer": "Первый пришёл — первый вышел (FIFO)",
          "explanation": "Очередь — это структура данных с дисциплиной доступа «первый пришёл — первый вышел»."
        },
        {
          "text": "Какую функцию выполняют очереди сообщений в архитектуре приложений?",
          "options": [
            "Создают неявные интерфейсы обмена данными",
            "Увеличивают сложность системы",
            "Уменьшают производительность",
            "Сохраняют все данные в памяти"
          ],
          "correctAnswer": "Создают неявные интерфейсы обмена данными",
          "explanation": "Очереди сообщений создают неявные интерфейсы обмена данными, позволяя процессам быть независимыми друг от друга."
        },
        {
          "text": "Как очереди сообщений помогают в случае пиковой нагрузки?",
          "options": [
            "Служат буфером для накопления данных",
            "Удаляют старые сообщения",
            "Увеличивают скорость обработки",
            "Снижают объем данных"
          ],
          "correctAnswer": "Служат буфером для накопления данных",
          "explanation": "Очереди сообщений могут выполнять роль буфера для накопления данных в случае пиковой нагрузки, смягчая нагрузку на систему."
        },
        {
          "text": "Какую гарантию предоставляет использование очередей сообщений?",
          "options": [
            "Гарантированная доставка сообщений",
            "Гарантированная потеря сообщений",
            "Гарантированное удаление сообщений",
            "Гарантированная задержка сообщений"
          ],
          "correctAnswer": "Гарантированная доставка сообщений",
          "explanation": "Использование очереди сообщений гарантирует, что сообщение будет доставлено и обработано в любом случае."
        },
        {
          "text": "Какие готовые реализации MQ вы знаете?",
          "options": [
            "RabbitMQ, ActiveMQ, Kafka, Redis, ZeroMQ, RocketMQ",
            "MySQL, PostgreSQL, MongoDB",
            "Django, Flask, Express",
            "HTML, CSS, JavaScript"
          ],
          "correctAnswer": "RabbitMQ, ActiveMQ, Kafka, Redis, ZeroMQ, RocketMQ",
          "explanation": "Существуют различные реализации MQ, такие как RabbitMQ, ActiveMQ, Kafka, Redis, ZeroMQ и RocketMQ."
        },
        {
          "text": "Какой из следующих вариантов является реализацией очереди сообщений?",
          "options": [
            "RabbitMQ",
            "HTML",
            "CSS",
            "Java"
          ],
          "correctAnswer": "RabbitMQ",
          "explanation": "RabbitMQ — это реализация очереди сообщений, которая поддерживает различные протоколы обмена сообщениями."
        },
        {
          "text": "Какой из следующих инструментов используется для обработки потоков данных?",
          "options": [
            "Kafka",
            "Photoshop",
            "Excel",
            "Notepad"
          ],
          "correctAnswer": "Kafka",
          "explanation": "Kafka — это система для обработки потоков данных и обмена сообщениями."
        },
        {
          "text": "Что такое RPC?",
          "options": [
            "Удалённый вызов процедур",
            "Локальный вызов процедур",
            "Синхронный вызов функций",
            "Асинхронный вызов функций"
          ],
          "correctAnswer": "Удалённый вызов процедур",
          "explanation": "RPC (Remote Procedure Call) — это класс технологий, позволяющих программам вызывать функции в другом адресном пространстве."
        },
        {
          "text": "Какие протоколы обычно используются на транспортном уровне для RPC?",
          "options": [
            "TCP и UDP",
            "HTTP и FTP",
            "SMTP и IMAP",
            "SSH и Telnet"
          ],
          "correctAnswer": "TCP и UDP",
          "explanation": "На транспортном уровне RPC обычно использует протоколы TCP и UDP."
        },
        {
          "text": "Каковы характерные черты вызова удалённых процедур?",
          "options": [
            "Асимметричность и синхронность",
            "Симметричность и асинхронность",
            "Локальность и синхронность",
            "Асинхронность и многопоточность"
          ],
          "correctAnswer": "Асимметричность и синхронность",
          "explanation": "Характерными чертами RPC являются асимметричность и синхронность, где одна сторона является инициатором."
        },
        {
          "text": "Что такое gRPC?",
          "options": [
            "Фреймворк для удалённого вызова процедур от Google",
            "Протокол передачи данных",
            "Система управления базами данных",
            "Язык программирования"
          ],
          "correctAnswer": "Фреймворк для удалённого вызова процедур от Google",
          "explanation": "gRPC — это высокопроизводительный фреймворк, разработанный компанией Google для вызова удалённых процедур (RPC), работающий поверх HTTP/2."
        },
        {
          "text": "Какой протокол использует gRPC для передачи данных?",
          "options": [
            "HTTP/1.1",
            "HTTP/2",
            "TCP",
            "UDP"
          ],
          "correctAnswer": "HTTP/2",
          "explanation": "gRPC работает поверх HTTP/2, что обеспечивает высокую производительность и множество возможностей."
        },
        {
          "text": "Какой инструмент gRPC использует для описания типов данных и сериализации?",
          "options": [
            "JSON",
            "XML",
            "Protobuf",
            "YAML"
          ],
          "correctAnswer": "Protobuf",
          "explanation": "gRPC использует Protobuf в качестве инструмента описания типов данных и сериализации."
        },
        {
          "text": "Какое преимущество предоставляет gRPC в сравнении с REST?",
          "options": [
            "Гарантированная доставка сообщений",
            "Поддержка асинхронной обработки",
            "Быстрая работа с данными",
            "Поддержка только одного языка программирования"
          ],
          "correctAnswer": "Быстрая работа с данными",
          "explanation": "gRPC обеспечивает высокую производительность, что позволяет быстрее обрабатывать данные по сравнению с REST."
        },
        {
          "text": "Сколько языков программирования поддерживает gRPC?",
          "options": [
            "5",
            "9",
            "10",
            "15"
          ],
          "correctAnswer": "9",
          "explanation": "gRPC поддерживает 9 языков программирования, включая C, C++, Java, Go, Node.js, Python, Ruby, Objective-C, PHP и C#."
        }
      ]
    },
    {
      "id": "frontend",
      "name": "Frontend",
      "description": "Вопросы по фронтенд-разработке.",
      "questions": [
        {
          "text": "Что такое куки?",
          "options": [
            "Информация, сохраняемая на компьютере веб-сайтом",
            "Тип базы данных",
            "Файл на сервере",
            "Скрипт на стороне сервера"
          ],
          "correctAnswer": "Информация, сохраняемая на компьютере веб-сайтом",
          "explanation": "Куки — это информация, сохраняемая на компьютере веб-сайтом, которая позволяет запоминать настройки и предпочтения пользователя."
        },
        {
          "text": "Зачем используются куки?",
          "options": [
            "Для хранения настроек веб-сайта",
            "Для увеличения скорости загрузки",
            "Для защиты данных",
            "Для создания баз данных"
          ],
          "correctAnswer": "Для хранения настроек веб-сайта",
          "explanation": "Куки часто хранят настройки для веб-сайта, такие как предпочитаемый язык или местоположение."
        },
        {
          "text": "Где хранятся куки?",
          "options": [
            "На сервере",
            "В браузере",
            "В базе данных",
            "На компьютере пользователя"
          ],
          "correctAnswer": "В браузере",
          "explanation": "Куки хранятся в браузере пользователя."
        },
        {
          "text": "Как можно работать с куками в Django?",
          "options": [
            "Используя request.COOKIES и response.set_cookie",
            "Используя document.cookie",
            "Используя localStorage",
            "Используя sessionStorage"
          ],
          "correctAnswer": "Используя request.COOKIES и response.set_cookie",
          "explanation": "В Django можно работать с куками через request.COOKIES и response.set_cookie."
        },
        {
          "text": "Как можно работать с куками в JavaScript?",
          "options": [
            "Используя document.cookie",
            "Используя request.COOKIES",
            "Используя localStorage",
            "Используя sessionStorage"
          ],
          "correctAnswer": "Используя document.cookie",
          "explanation": "В JavaScript куки можно обрабатывать с помощью document.cookie, если не установлен флаг HTTPONLY."
        },
        {
          "text": "Может ли сервер изменить (добавить, удалить) куки?",
          "options": [
            "Да, сервер может изменить куки",
            "Нет, куки могут изменяться только клиентом",
            "Сервер может только удалять куки",
            "Сервер не имеет доступа к кукам"
          ],
          "correctAnswer": "Да, сервер может изменить куки",
          "explanation": "Сервер может изменить значение куки, отправляя новые строки Set-Cookie: name=newvalue, после чего браузер заменяет старое куки с тем же name на новое значение."
        },
        {
          "text": "Что такое JWT (JSON Web Token)?",
          "options": [
            "Стандартизированный формат упаковки данных для безопасной передачи",
            "Формат изображения",
            "Тип базы данных",
            "Протокол передачи данных"
          ],
          "correctAnswer": "Стандартизированный формат упаковки данных для безопасной передачи",
          "explanation": "JWT (JSON Web Token) представляет собой стандартизированный формат упаковки данных, используемый для безопасной передачи информации между двумя сторонами."
        },
        {
          "text": "Какую структуру информации определяет JWT?",
          "options": [
            "Сериализованную и десериализованную",
            "Только сериализованную",
            "Только десериализованную",
            "Текстовую и бинарную"
          ],
          "correctAnswer": "Сериализованную и десериализованную",
          "explanation": "JWT определяет структуру информации, представленную в сериализованной и десериализованной формах."
        },
        {
          "text": "Для чего используется сериализованная форма JWT?",
          "options": [
            "Для передачи данных с запросами и ответами",
            "Для хранения данных",
            "Для шифрования данных",
            "Для создания баз данных"
          ],
          "correctAnswer": "Для передачи данных с запросами и ответами",
          "explanation": "Сериализованная форма JWT используется непосредственно для передачи данных с запросами и ответами."
        }
      ]
    },
    {
      "id": "sdlc",
      "name": "SDLC",
      "description": "Вопросы по жизненному циклу разработки программного обеспечения.",
      "questions": [
        {
          "text": "Что такое Agile?",
          "options": [
            "Методология разработки программного обеспечения",
            "Тип базы данных",
            "Язык программирования",
            "Система управления проектами"
          ],
          "correctAnswer": "Методология разработки программного обеспечения",
          "explanation": "Agile — это методология разработки программного обеспечения, которая акцентирует внимание на гибкости и адаптивности в процессе разработки."
        },
        {
          "text": "Что такое Scrum?",
          "options": [
            "Методология управления проектами в Agile",
            "Тип программного обеспечения",
            "Язык программирования",
            "Система контроля версий"
          ],
          "correctAnswer": "Методология управления проектами в Agile",
          "explanation": "Scrum — это методология управления проектами, которая используется в рамках Agile для организации работы команд."
        },
        {
          "text": "Какова основная цель Agile/Scrum?",
          "options": [
            "Увеличение гибкости и скорости разработки",
            "Снижение затрат на проект",
            "Увеличение количества документации",
            "Снижение качества продукта"
          ],
          "correctAnswer": "Увеличение гибкости и скорости разработки",
          "explanation": "Основная цель Agile/Scrum — увеличить гибкость и скорость разработки, позволяя командам быстро адаптироваться к изменениям."
        },
        {
          "text": "Что такое непрерывная интеграция (CI)?",
          "options": [
            "Процесс автоматического развертывания в продакшен",
            "Процесс автоматизации сборки и тестирования кода",
            "Процесс управления проектами",
            "Процесс документирования кода"
          ],
          "correctAnswer": "Процесс автоматизации сборки и тестирования кода",
          "explanation": "Непрерывная интеграция (CI) заключается в автоматизации сборки и тестирования кода после каждого слияния изменений в центральный репозиторий."
        },
        {
          "text": "Что такое непрерывная доставка (CD)?",
          "options": [
            "Автоматизация процесса релиза ПО",
            "Процесс тестирования кода",
            "Процесс управления версиями",
            "Процесс документирования"
          ],
          "correctAnswer": "Автоматизация процесса релиза ПО",
          "explanation": "Непрерывная доставка (CD) — это практика автоматизации всего процесса релиза программного обеспечения."
        },
        {
          "text": "Какова основная разница между непрерывной доставкой и непрерывным развертыванием?",
          "options": [
            "Непрерывная доставка требует ручного развертывания, а непрерывное развертывание — автоматического",
            "Непрерывная доставка не требует тестирования, а непрерывное развертывание требует",
            "Непрерывная доставка — это только для веб-приложений, а непрерывное развертывание — для мобильных",
            "Непрерывная доставка не требует CI, а непрерывное развертывание требует"
          ],
          "correctAnswer": "Непрерывная доставка требует ручного развертывания, а непрерывное развертывание — автоматического",
          "explanation": "Непрерывная доставка включает ручное развертывание, тогда как непрерывное развертывание автоматически развертывает изменения в продакшен."
        },
        {
          "text": "Какова основная цель непрерывного развертывания?",
          "options": [
            "Автоматизация всех процессов разработки",
            "Полностью автоматизированное развертывание в продакшен",
            "Увеличение времени на тестирование",
            "Снижение качества кода"
          ],
          "correctAnswer": "Полностью автоматизированное развертывание в продакшен",
          "explanation": "Непрерывное развертывание предполагает автоматическое развертывание всех изменений в продакшен без явного одобрения разработчика."
        },
        {
          "text": "В чем основная разница между Scrum и Kanban?",
          "options": [
            "В длине итераций",
            "В количестве участников команды",
            "В используемых инструментах",
            "В типах документации"
          ],
          "correctAnswer": "В длине итераций",
          "explanation": "Основная разница между Scrum и Kanban заключается в длине итераций: в Scrum итерации составляют 2-3 недели, в Kanban задачи можно менять каждый день."
        },
        {
          "text": "Каковы итерации в Scrum?",
          "options": [
            "Долгосрочные",
            "Короткие, обычно 2-3 недели",
            "Неопределенные",
            "Каждый день"
          ],
          "correctAnswer": "Короткие, обычно 2-3 недели",
          "explanation": "В Scrum итерации, называемые спринтами, обычно составляют 2-3 недели."
        },
        {
          "text": "Как в Scrum оцениваются задачи?",
          "options": [
            "В Story points или часах",
            "В процентах",
            "Не оцениваются",
            "В днях"
          ],
          "correctAnswer": "В Story points или часах",
          "explanation": "В Scrum задачи принято оценивать в Story points или в часах, что позволяет сформировать спринт."
        },
        {
          "text": "Как в Kanban оцениваются задачи?",
          "options": [
            "Не оцениваются, это опционально",
            "В Story points",
            "В часах",
            "В процентах"
          ],
          "correctAnswer": "Не оцениваются, это опционально",
          "explanation": "В Kanban не принято делать оценку задач, это опционально и зависит от команды."
        },
        {
          "text": "Какова цель Scrum?",
          "options": [
            "Закончить спринт",
            "Завершить задачу",
            "Увеличить скорость работы команды",
            "Собрать больше информации"
          ],
          "correctAnswer": "Закончить спринт",
          "explanation": "В Scrum основная цель — закончить спринт, в то время как в Kanban — завершить задачу."
        },
        {
          "text": "Что такое технический долг (Code Debt)?",
          "options": [
            "Осознанное компромиссное решение в разработке",
            "Ошибка в коде",
            "Неправильная архитектура",
            "Отсутствие документации"
          ],
          "correctAnswer": "Осознанное компромиссное решение в разработке",
          "explanation": "Технический долг — это осознанное компромиссное решение, когда разработчики понимают преимущества быстрого, но не идеального решения."
        },
        {
          "text": "Каковы основные стратегии управления техническим долгом?",
          "options": [
            "Переписывание кода с нуля, рефакторинг, смирение с долгом",
            "Игнорирование кода, добавление новых функций",
            "Увеличение команды разработчиков",
            "Сокращение времени на тестирование"
          ],
          "correctAnswer": "Переписывание кода с нуля, рефакторинг, смирение с долгом",
          "explanation": "Основные стратегии управления техническим долгом включают переписывание кода с нуля, постепенный рефакторинг и смирение с долгом."
        },
        {
          "text": "Как можно уменьшить технический долг на этапе создания продукта?",
          "options": [
            "Создавать одноразовые прототипы и четко определять завершенность задач",
            "Игнорировать тестирование",
            "Сокращать время разработки",
            "Увеличивать количество функций"
          ],
          "correctAnswer": "Создавать одноразовые прототипы и четко определять завершенность задач",
          "explanation": "Уменьшить технический долг можно, создавая одноразовые прототипы и устанавливая четкие метрики качества."
        },
        {
          "text": "Что такое 'definition of done' в контексте управления техническим долгом?",
          "options": [
            "Определение завершенности задачи с учетом качества",
            "Список всех функций приложения",
            "Документация по проекту",
            "Список ошибок в коде"
          ],
          "correctAnswer": "Определение завершенности задачи с учетом качества",
          "explanation": "'Definition of done' — это четкое определение завершенности задачи, включая метрики качества, что помогает избежать накопления технического долга."
        }
      ]
    },
    {
      "id": "vcs",
      "name": "VCS",
      "description": "Вопросы по системам контроля версий.",
      "questions": [
        {
          "text": "Что такое Git Flow?",
          "options": [
            "Методология работы с Git, использующая несколько веток",
            "Тип базы данных",
            "Язык программирования",
            "Система управления проектами"
          ],
          "correctAnswer": "Методология работы с Git, использующая несколько веток",
          "explanation": "Git Flow — это методология работы с Git, которая использует несколько веток для управления разработкой и релизами."
        },
        {
          "text": "Каковы основные ветки в Git Flow?",
          "options": [
            "Master, Development, Feature, Release, Hotfix",
            "Main, Feature, Bugfix",
            "Master, Feature, Release",
            "Development, Testing, Production"
          ],
          "correctAnswer": "Master, Development, Feature, Release, Hotfix",
          "explanation": "Основные ветки в Git Flow включают master, development, feature, release и hotfix."
        },
        {
          "text": "Что такое Feature Branch в Git Flow?",
          "options": [
            "Ветка для разработки новых функций",
            "Ветка для исправления ошибок",
            "Ветка для релизов",
            "Ветка для тестирования"
          ],
          "correctAnswer": "Ветка для разработки новых функций",
          "explanation": "Feature Branch — это ветка, в которой разрабатываются новые функции отдельно от основной ветки."
        },
        {
          "text": "Когда создается Release Branch в Git Flow?",
          "options": [
            "Когда development наберет достаточно фич для релиза",
            "Когда нужно исправить ошибку",
            "Когда начинается новая разработка",
            "Когда заканчивается проект"
          ],
          "correctAnswer": "Когда development наберет достаточно фич для релиза",
          "explanation": "Release Branch создается, когда в ветке development накопилось достаточно функций для нового релиза."
        },
        {
          "text": "Что такое Hotfix Branch в Git Flow?",
          "options": [
            "Ветка для быстрого исправления релизов",
            "Ветка для разработки новых функций",
            "Ветка для тестирования",
            "Ветка для документации"
          ],
          "correctAnswer": "Ветка для быстрого исправления релизов",
          "explanation": "Hotfix Branch используется для быстрого патчинга релизов и создается из master."
        },
        {
          "text": "Что такое Git Rebase?",
          "options": [
            "Метод слияния веток, который изменяет историю коммитов",
            "Способ создания новой ветки",
            "Команда для удаления коммитов",
            "Способ создания резервной копии"
          ],
          "correctAnswer": "Метод слияния веток, который изменяет историю коммитов",
          "explanation": "Git Rebase позволяет перемещать ваши локальные коммиты после всех коммитов в другой ветке, изменяя их хэши."
        },
        {
          "text": "Когда следует использовать git rebase?",
          "options": [
            "Когда нужно объединить несколько коммитов в один",
            "Когда нужно удалить коммиты",
            "Когда нужно создать новую ветку",
            "Когда нужно сделать резервную копию"
          ],
          "correctAnswer": "Когда нужно объединить несколько коммитов в один",
          "explanation": "Git Rebase используется для объединения нескольких коммитов в один, чтобы упростить историю изменений."
        },
        {
          "text": "Что происходит с хэшами коммитов при использовании git rebase?",
          "options": [
            "Хэши коммитов остаются неизменными",
            "Хэши коммитов изменяются",
            "Хэши коммитов удаляются",
            "Хэши коммитов дублируются"
          ],
          "correctAnswer": "Хэши коммитов изменяются",
          "explanation": "При использовании git rebase хэши ваших коммитов изменяются, так как они перемещаются в новую позицию в истории."
        },
        {
          "text": "Что такое 'squash' в контексте git rebase?",
          "options": [
            "Объединение нескольких коммитов в один",
            "Удаление коммитов",
            "Создание новой ветки",
            "Изменение комментариев коммитов"
          ],
          "correctAnswer": "Объединение нескольких коммитов в один",
          "explanation": "'Squash' позволяет объединить несколько коммитов в один, сохраняя только один комментарий."
        },
        {
          "text": "Что нужно сделать после редактирования коммитов с помощью git rebase?",
          "options": [
            "Выполнить push с опцией -f",
            "Удалить ветку",
            "Создать новую ветку",
            "Сделать merge"
          ],
          "correctAnswer": "Выполнить push с опцией -f",
          "explanation": "После редактирования коммитов с помощью git rebase необходимо выполнить push с опцией -f, так как история коммитов была изменена."
        },
        {
          "text": "Что такое git cherry-pick?",
          "options": [
            "Команда для переноса отдельных коммитов между ветками",
            "Команда для слияния веток",
            "Команда для удаления коммитов",
            "Команда для создания новой ветки"
          ],
          "correctAnswer": "Команда для переноса отдельных коммитов между ветками",
          "explanation": "Команда `git cherry-pick` используется для переноса отдельных коммитов из одного места репозитория в другое, обычно между ветками."
        },
        {
          "text": "Как используется команда git cherry-pick?",
          "options": [
            "git cherry-pick <commit-hash>",
            "git cherry-pick <branch-name>",
            "git cherry-pick <file-name>",
            "git cherry-pick <tag-name>"
          ],
          "correctAnswer": "git cherry-pick <commit-hash>",
          "explanation": "Команда `git cherry-pick` используется с указанием хэша коммита, который нужно перенести."
        },
        {
          "text": "В чем отличие git cherry-pick от git merge?",
          "options": [
            "Cherry-pick переносит отдельные коммиты, а merge — целые цепочки коммитов",
            "Cherry-pick объединяет ветки, а merge — создает новые",
            "Cherry-pick удаляет коммиты, а merge — сохраняет их",
            "Cherry-pick работает только с локальными ветками, а merge — с удаленными"
          ],
          "correctAnswer": "Cherry-pick переносит отдельные коммиты, а merge — целые цепочки коммитов",
          "explanation": "Команда `git cherry-pick` переносит отдельные коммиты, в то время как `git merge` объединяет целые цепочки коммитов."
        },
        {
          "text": "Что такое force push в Git?",
          "options": [
            "Команда для принудительной отправки изменений в удаленный репозиторий",
            "Команда для удаления ветки",
            "Команда для создания новой ветки",
            "Команда для слияния веток"
          ],
          "correctAnswer": "Команда для принудительной отправки изменений в удаленный репозиторий",
          "explanation": "Force push используется для принудительной отправки изменений в удаленный репозиторий, даже если это перезаписывает историю."
        },
        {
          "text": "Когда необходимо использовать git push --force?",
          "options": [
            "Когда вы изменили историю коммитов",
            "Когда вы хотите создать новую ветку",
            "Когда вы хотите удалить коммиты",
            "Когда вы хотите объединить ветки"
          ],
          "correctAnswer": "Когда вы изменили историю коммитов",
          "explanation": "git push --force необходимо использовать, если вы изменили историю коммитов, например, исправили имя автора или отменили последний коммит."
        },
        {
          "text": "Какой более безопасный вариант команды для принудительного пуша?",
          "options": [
            "git push --force-with-lease",
            "git push --force",
            "git push --all",
            "git push --tags"
          ],
          "correctAnswer": "git push --force-with-lease",
          "explanation": "git push --force-with-lease более безопасен, так как он предотвращает перезапись чужих коммитов, если они были добавлены после последнего получения изменений."
        },
        {
          "text": "Что произойдет, если использовать git push --force без предостережений?",
          "options": [
            "Можно перезаписать чужие изменения",
            "Команда не выполнится",
            "Создастся новая ветка",
            "Удалит все коммиты"
          ],
          "correctAnswer": "Можно перезаписать чужие изменения",
          "explanation": "Использование git push --force может привести к перезаписи чужих изменений, если кто-то другой уже запушил свои коммиты."
        },
        {
          "text": "Что такое pre-commit check в Git?",
          "options": [
            "Сценарий, выполняемый перед созданием коммита",
            "Команда для удаления коммитов",
            "Команда для слияния веток",
            "Сценарий, выполняемый после создания коммита"
          ],
          "correctAnswer": "Сценарий, выполняемый перед созданием коммита",
          "explanation": "Pre-commit check — это сценарий, который выполняется перед созданием коммита для проверки кода на валидность и других условий."
        },
        {
          "text": "Для чего можно использовать pre-commit check?",
          "options": [
            "Для проверки кода на валидность и выполнения юнит-тестов",
            "Для создания новой ветки",
            "Для удаления старых коммитов",
            "Для слияния веток"
          ],
          "correctAnswer": "Для проверки кода на валидность и выполнения юнит-тестов",
          "explanation": "Pre-commit check можно использовать для проверки кода на валидность, выполнения юнит-тестов и прерывания операции коммита в случае ошибок."
        },
        {
          "text": "Какие типы перехватчиков (hooks) существуют в Git?",
          "options": [
            "На стороне клиента и на стороне сервера",
            "Только на стороне клиента",
            "Только на стороне сервера",
            "Только для коммитов"
          ],
          "correctAnswer": "На стороне клиента и на стороне сервера",
          "explanation": "В Git существуют перехватчики на стороне клиента для операций, таких как создание коммита, и на стороне сервера для операций, таких как прием отправленных коммитов."
        },
        {
          "text": "Что может произойти, если pre-commit check обнаружит ошибки?",
          "options": [
            "Операция коммита будет прервана",
            "Коммит будет создан с ошибками",
            "Ошибки будут проигнорированы",
            "Коммит будет автоматически исправлен"
          ],
          "correctAnswer": "Операция коммита будет прервана",
          "explanation": "Если pre-commit check обнаружит ошибки, операция коммита будет прервана, и будет отображен журнал для разбора ошибок."
        }
      ]
    },
    {
      "id": "databases",
      "name": "Базы данных",
      "description": "Вопросы по базам данных и транзакциям.",
      "questions": [
        {
          "text": "Что такое транзакция в контексте баз данных?",
          "options": [
            "Рабочая единица работы с базой данных",
            "Тип базы данных",
            "Команда для удаления данных",
            "Процесс создания базы данных"
          ],
          "correctAnswer": "Рабочая единица работы с базой данных",
          "explanation": "Транзакция — это последовательность операций, выполняемых в логическом порядке пользователем или программой, работающей с базой данных."
        },
        {
          "text": "Каковы основные свойства транзакции, описываемые аббревиатурой ACID?",
          "options": [
            "Атомарность, Согласованность, Изолированность, Долговечность",
            "Анализ, Синхронизация, Изоляция, Долговечность",
            "Атомарность, Согласованность, Интеграция, Долговечность",
            "Анализ, Согласованность, Изолированность, Долговечность"
          ],
          "correctAnswer": "Атомарность, Согласованность, Изолированность, Долговечность",
          "explanation": "Основные свойства транзакции описываются аббревиатурой ACID: Атомарность, Согласованность, Изолированность, Долговечность."
        },
        {
          "text": "Что означает атомарность транзакции?",
          "options": [
            "Транзакция фиксируется только целиком",
            "Транзакция может быть частично выполнена",
            "Транзакция не может быть отменена",
            "Транзакция выполняется в фоновом режиме"
          ],
          "correctAnswer": "Транзакция фиксируется только целиком",
          "explanation": "Атомарность гарантирует, что любая транзакция будет зафиксирована только целиком; если одна из операций не выполнена, вся транзакция будет отменена."
        },
        {
          "text": "Что означает согласованность в контексте транзакций?",
          "options": [
            "Завершенная транзакция фиксирует только допустимые результаты",
            "Транзакция может быть выполнена в любое время",
            "Транзакция не зависит от других",
            "Транзакция может быть отменена"
          ],
          "correctAnswer": "Завершенная транзакция фиксирует только допустимые результаты",
          "explanation": "Согласованность означает, что любая завершенная транзакция фиксирует только допустимые результаты, поддерживая баланс системы."
        },
        {
          "text": "Что такое долговечность в контексте транзакций?",
          "options": [
            "Изменения не должны быть отменены из-за сбоя системы",
            "Транзакция может быть отменена",
            "Транзакция выполняется в фоновом режиме",
            "Транзакция может быть выполнена несколько раз"
          ],
          "correctAnswer": "Изменения не должны быть отменены из-за сбоя системы",
          "explanation": "Долговечность гарантирует, что если мы получили подтверждение о выполнении транзакции, изменения не должны быть отменены из-за сбоя системы."
        },
        {
          "text": "Какие команды управления транзакциями вы знаете?",
          "options": [
            "COMMIT, ROLLBACK, SAVEPOINT, SET TRANSACTION",
            "INSERT, UPDATE, DELETE",
            "CREATE, ALTER, DROP",
            "SELECT, FROM, WHERE"
          ],
          "correctAnswer": "COMMIT, ROLLBACK, SAVEPOINT, SET TRANSACTION",
          "explanation": "Для управления транзакциями используются команды: COMMIT (сохраняет изменения), ROLLBACK (отменяет изменения), SAVEPOINT (создает точку отката) и SET TRANSACTION (размещает имя транзакции)."
        },
        {
          "text": "Что делает команда COMMIT?",
          "options": [
            "Сохраняет изменения в базе данных",
            "Отменяет изменения",
            "Создает точку отката",
            "Изменяет имя транзакции"
          ],
          "correctAnswer": "Сохраняет изменения в базе данных",
          "explanation": "Команда COMMIT сохраняет все изменения, сделанные в текущей транзакции."
        },
        {
          "text": "Что делает команда ROLLBACK?",
          "options": [
            "Сохраняет изменения",
            "Отменяет изменения",
            "Создает точку отката",
            "Изменяет имя транзакции"
          ],
          "correctAnswer": "Отменяет изменения",
          "explanation": "Команда ROLLBACK отменяет все изменения, сделанные в текущей транзакции."
        },
        {
          "text": "Что такое SAVEPOINT?",
          "options": [
            "Создает точку, к которой можно откатиться",
            "Сохраняет изменения",
            "Отменяет изменения",
            "Изменяет имя транзакции"
          ],
          "correctAnswer": "Создает точку, к которой можно откатиться",
          "explanation": "SAVEPOINT создает точку в транзакции, к которой можно откатиться, если это необходимо."
        },
        {
          "text": "Для каких команд можно использовать команды управления транзакциями?",
          "options": [
            "Только для DML команд: INSERT, UPDATE, DELETE",
            "Для всех команд SQL",
            "Только для DDL команд",
            "Только для SELECT команд"
          ],
          "correctAnswer": "Только для DML команд: INSERT, UPDATE, DELETE",
          "explanation": "Команды управления транзакциями используются только для DML команд: INSERT, UPDATE, DELETE."
        },
        {
          "text": "Что такое уровни изолированности транзакций?",
          "options": [
            "Способы управления конкурентным доступом к данным",
            "Типы баз данных",
            "Методы создания таблиц",
            "Способы удаления данных"
          ],
          "correctAnswer": "Способы управления конкурентным доступом к данным",
          "explanation": "Уровни изолированности транзакций определяют, как транзакции взаимодействуют друг с другом и как они видят данные, измененные другими транзакциями."
        },
        {
          "text": "Какой уровень изолированности предотвращает 'грязные' операции чтения?",
          "options": [
            "Чтение зафиксированных данных (Read Committed)",
            "Изоляция снимков состояния",
            "Сериализуемость",
            "Чтение незакрепленных данных"
          ],
          "correctAnswer": "Чтение зафиксированных данных (Read Committed)",
          "explanation": "Уровень изоляции 'Чтение зафиксированных данных' предотвращает 'грязные' операции чтения, позволяя видеть только зафиксированные данные."
        },
        {
          "text": "Что такое сериализуемость в контексте изолированности транзакций?",
          "options": [
            "Самый сильный уровень изолированности, который гарантирует последовательное выполнение транзакций",
            "Уровень, который позволяет транзакциям выполняться параллельно",
            "Уровень, который предотвращает все операции записи",
            "Уровень, который не требует блокировок"
          ],
          "correctAnswer": "Самый сильный уровень изолированности, который гарантирует последовательное выполнение транзакций",
          "explanation": "Сериализуемость гарантирует, что результат выполнения транзакций будет таким же, как если бы они выполнялись последовательно."
        },
        {
          "text": "Какой метод обеспечивает сериализуемость, но может иметь плохие показатели производительности?",
          "options": [
            "Двухфазная блокировка",
            "Сериализуемая изоляция снимков состояния",
            "Оптимистический подход",
            "Чтение зафиксированных данных"
          ],
          "correctAnswer": "Двухфазная блокировка",
          "explanation": "Двухфазная блокировка была стандартным способом обеспечения сериализуемости, но многие приложения стараются ее не использовать из-за плохих показателей производительности."
        },
        {
          "text": "Что такое изоляция снимков состояния?",
          "options": [
            "Каждая транзакция читает данные из согласованного снимка состояния БД",
            "Транзакция выполняется без блокировок",
            "Транзакция может быть отменена",
            "Транзакция выполняется в фоновом режиме"
          ],
          "correctAnswer": "Каждая транзакция читает данные из согласованного снимка состояния БД",
          "explanation": "Изоляция снимков состояния позволяет каждой транзакции видеть данные, которые были зафиксированы на момент ее начала, предотвращая асимметрию чтения."
        },
        {
          "text": "Что такое вложенные транзакции?",
          "options": [
            "Транзакции, инициируемые из тела уже активной транзакции",
            "Транзакции, которые выполняются параллельно",
            "Транзакции, которые не могут быть отменены",
            "Транзакции, которые выполняются только в фоновом режиме"
          ],
          "correctAnswer": "Транзакции, инициируемые из тела уже активной транзакции",
          "explanation": "Вложенные транзакции — это транзакции, выполнение которых инициируется из тела уже активной транзакции."
        },
        {
          "text": "Что происходит при завершении транзакции верхнего уровня, если вложенная транзакция завершена неудачно?",
          "options": [
            "Все транзакции верхнего уровня будут отменены",
            "Только вложенная транзакция будет отменена",
            "Транзакция верхнего уровня будет зафиксирована",
            "Ничего не произойдет"
          ],
          "correctAnswer": "Все транзакции верхнего уровня будут отменены",
          "explanation": "Если вложенная транзакция завершена неудачно, то все транзакции верхнего уровня, включая транзакцию первого уровня, будут отменены."
        },
        {
          "text": "Как работает команда COMMIT TRANSACTION в контексте вложенных транзакций?",
          "options": [
            "Она завершает только последнюю начатую транзакцию",
            "Она завершает все транзакции",
            "Она завершает транзакцию верхнего уровня",
            "Она не имеет эффекта"
          ],
          "correctAnswer": "Она завершает только последнюю начатую транзакцию",
          "explanation": "Каждая команда COMMIT TRANSACTION работает только с последней начатой транзакцией, завершая наиболее 'глубокую' вложенную транзакцию."
        },
        {
          "text": "Что произойдет, если несколько вложенных транзакций завершатся успешно, но одна из транзакций среднего уровня завершится неудачно?",
          "options": [
            "Произойдет откат всех транзакций всех уровней",
            "Только неудачная транзакция будет отменена",
            "Все транзакции будут зафиксированы",
            "Ничего не произойдет"
          ],
          "correctAnswer": "Произойдет откат всех транзакций всех уровней",
          "explanation": "Если одна из транзакций среднего уровня завершится неудачно, произойдет откат всех транзакций всех уровней, включая успешно завершенные."
        },
        {
          "text": "Что такое курсор в контексте баз данных?",
          "options": [
            "Указатель на ряд данных в базе данных",
            "Тип базы данных",
            "Команда для удаления данных",
            "Процесс создания таблицы"
          ],
          "correctAnswer": "Указатель на ряд данных в базе данных",
          "explanation": "Курсор — это указатель на ряд данных в реляционной базе данных, который позволяет обрабатывать записи по одной."
        },
        {
          "text": "Для чего обычно используются курсоры?",
          "options": [
            "Для выбора подмножества информации из базы данных",
            "Для создания новых таблиц",
            "Для удаления всех записей",
            "Для изменения структуры базы данных"
          ],
          "correctAnswer": "Для выбора подмножества информации из базы данных",
          "explanation": "Курсоры используются для выбора из базы данных некоторого подмножества хранимой в ней информации."
        },
        {
          "text": "Какова основная проблема использования курсоров?",
          "options": [
            "Скорость выполнения операций ниже, чем у стандартных команд SQL",
            "Курсоры не могут быть использованы в SQL",
            "Курсоры не позволяют выбирать данные",
            "Курсоры требуют больше памяти"
          ],
          "correctAnswer": "Скорость выполнения операций ниже, чем у стандартных команд SQL",
          "explanation": "Курсоры имеют более низкую скорость выполнения операций обработки данных по сравнению со стандартными командами SQL."
        },
        {
          "text": "Что происходит, если курсор неявно создается сервером базы данных?",
          "options": [
            "Он автоматически управляется сервером",
            "Программист должен его определить",
            "Он не может быть использован",
            "Он требует дополнительных команд"
          ],
          "correctAnswer": "Он автоматически управляется сервером",
          "explanation": "Некоторые курсоры создаются неявно сервером базы данных и управляются им."
        },
        {
          "text": "Какой подход рекомендуется вместо использования курсоров?",
          "options": [
            "Использовать стандартные команды обработки данных: SELECT, UPDATE, INSERT, DELETE",
            "Использовать только курсоры",
            "Использовать только команды удаления",
            "Использовать только команды создания таблиц"
          ],
          "correctAnswer": "Использовать стандартные команды обработки данных: SELECT, UPDATE, INSERT, DELETE",
          "explanation": "Рекомендуется избегать использования курсоров и работать со стандартными командами обработки данных."
        },
        {
          "text": "Какая разница между PostgreSQL и MySQL?",
          "options": [
            "PostgreSQL поддерживает больше стандартов SQL, чем MySQL",
            "MySQL всегда быстрее PostgreSQL",
            "PostgreSQL не поддерживает индексы",
            "MySQL не поддерживает транзакции"
          ],
          "correctAnswer": "PostgreSQL поддерживает больше стандартов SQL, чем MySQL",
          "explanation": "PostgreSQL поддерживает все новые стандарты SQL, в то время как MySQL не поддерживает все функции и возможности SQL."
        },
        {
          "text": "Какой движок используется в MySQL для хранения данных?",
          "options": [
            "Различные движки, такие как InnoDB и MyISAM",
            "Только один движок",
            "Нет движка",
            "Только PostgreSQL"
          ],
          "correctAnswer": "Различные движки, такие как InnoDB и MyISAM",
          "explanation": "MySQL использует различные движки для хранения данных, такие как MyISAM, InnoDB, MEMORY и другие."
        },
        {
          "text": "Как PostgreSQL обрабатывает данные при выполнении запроса?",
          "options": [
            "Хранит весь ответ в памяти сервера, а клиент получает указатель",
            "Загружает весь ответ в память клиента",
            "Не обрабатывает данные",
            "Сохраняет данные на диск"
          ],
          "correctAnswer": "Хранит весь ответ в памяти сервера, а клиент получает только указатель на данные.",
          "explanation": "PostgreSQL хранит весь ответ в памяти сервера, а клиент получает только указатель на данные."
        },
        {
          "text": "Какой из этих типов данных поддерживает PostgreSQL, но не поддерживает MySQL?",
          "options": [
            "Регулярные выражения",
            "Целые числа",
            "Строки",
            "Дата и время"
          ],
          "correctAnswer": "Регулярные выражения",
          "explanation": "PostgreSQL поддерживает регулярные выражения в запросах, чего нет в MySQL."
        },
        {
          "text": "Какой из этих вариантов верен относительно производительности MySQL и PostgreSQL?",
          "options": [
            "MySQL быстрее при использовании первичных ключей",
            "PostgreSQL всегда быстрее MySQL",
            "Они имеют одинаковую производительность",
            "MySQL медленнее, чем PostgreSQL"
          ],
          "correctAnswer": "MySQL быстрее при использовании первичных ключей",
          "explanation": "MySQL был ориентирован на большую производительность, особенно при использовании первичных ключей."
        },
        {
          "text": "Что такое VACUUM в PostgreSQL?",
          "options": [
            "Команда для высвобождения пространства, занимаемого 'мёртвыми' кортежами",
            "Команда для создания резервной копии базы данных",
            "Команда для удаления таблиц",
            "Команда для обновления данных"
          ],
          "correctAnswer": "Команда для высвобождения пространства, занимаемого 'мёртвыми' кортежами",
          "explanation": "VACUUM высвобождает пространство, занимаемое 'мёртвыми' кортежами, которые не удаляются физически из таблицы при обычных операциях."
        },
        {
          "text": "Когда необходимо выполнять команду VACUUM?",
          "options": [
            "Периодически, особенно для часто изменяемых таблиц",
            "Каждый раз после обновления данных",
            "Только при создании новой таблицы",
            "Никогда, это не требуется"
          ],
          "correctAnswer": "Периодически, особенно для часто изменяемых таблиц",
          "explanation": "Необходимо периодически выполнять VACUUM, особенно для таблиц, которые часто изменяются."
        },
        {
          "text": "Что такое EXPLAIN в PostgreSQL?",
          "options": [
            "Команда для вывода информации о выполнении запроса",
            "Команда для удаления данных",
            "Команда для создания индексов",
            "Команда для обновления данных"
          ],
          "correctAnswer": "Команда для вывода информации о выполнении запроса",
          "explanation": "EXPLAIN выводит информацию, необходимую для понимания, что делает ядро при каждом конкретном запросе."
        },
        {
          "text": "В чем разница между EXPLAIN и EXPLAIN ANALYZE?",
          "options": [
            "EXPLAIN ANALYZE выполняет запрос и выводит его результаты",
            "EXPLAIN не выводит информацию о запросе",
            "EXPLAIN ANALYZE используется только для SELECT запросов",
            "EXPLAIN и EXPLAIN ANALYZE идентичны"
          ],
          "correctAnswer": "EXPLAIN ANALYZE выполняет запрос и выводит его результаты",
          "explanation": "EXPLAIN ANALYZE выполняет объясняемое выражение, даже если это insert, update или delete, в отличие от EXPLAIN, который только выводит информацию."
        },
        {
          "text": "Какие виды JOIN'ов вы знаете?",
          "options": [
            "INNER JOIN, LEFT OUTER JOIN, RIGHT OUTER JOIN, FULL OUTER JOIN, CROSS JOIN",
            "INNER JOIN, OUTER JOIN, NATURAL JOIN",
            "LEFT JOIN, RIGHT JOIN, FULL JOIN",
            "JOIN, LEFT JOIN, RIGHT JOIN"
          ],
          "correctAnswer": "INNER JOIN, LEFT OUTER JOIN, RIGHT OUTER JOIN, FULL OUTER JOIN, CROSS JOIN",
          "explanation": "Существуют различные виды JOIN'ов, включая INNER JOIN, LEFT OUTER JOIN, RIGHT OUTER JOIN, FULL OUTER JOIN и CROSS JOIN."
        },
        {
          "text": "Что делает INNER JOIN?",
          "options": [
            "Возвращает строки, которые имеют соответствия в обеих таблицах",
            "Возвращает все строки из первой таблицы",
            "Возвращает все строки из второй таблицы",
            "Возвращает все строки, даже если нет соответствий"
          ],
          "correctAnswer": "Возвращает строки, которые имеют соответствия в обеих таблицах",
          "explanation": "INNER JOIN возвращает строки, которые имеют соответствия в обеих таблицах."
        },
        {
          "text": "Какой результат дает LEFT OUTER JOIN?",
          "options": [
            "Все строки из первой таблицы и соответствующие строки из второй таблицы",
            "Только строки, которые имеют соответствия в обеих таблицах",
            "Все строки из второй таблицы",
            "Только строки, которые не имеют соответствий"
          ],
          "correctAnswer": "Все строки из первой таблицы и соответствующие строки из второй таблицы",
          "explanation": "LEFT OUTER JOIN возвращает все строки из первой таблицы и соответствующие строки из второй таблицы, а если соответствий нет, то вставляются NULL."
        },
        {
          "text": "Что делает FULL OUTER JOIN?",
          "options": [
            "Возвращает все строки из обеих таблиц, включая строки без соответствий",
            "Возвращает только строки с соответствиями",
            "Возвращает только строки из первой таблицы",
            "Возвращает только строки из второй таблицы"
          ],
          "correctAnswer": "Возвращает все строки из обеих таблиц, включая строки без соответствий",
          "explanation": "FULL OUTER JOIN возвращает все строки из обеих таблиц, включая строки, которые не имеют соответствий."
        },
        {
          "text": "Что такое CROSS JOIN?",
          "options": [
            "Декартово произведение двух таблиц",
            "Соединение таблиц по ключевым полям",
            "Соединение таблиц с использованием NATURAL",
            "Соединение таблиц с использованием USING"
          ],
          "correctAnswer": "Декартово произведение двух таблиц",
          "explanation": "CROSS JOIN возвращает декартово произведение двух таблиц, то есть все возможные комбинации строк из обеих таблиц."
        }
      ]
    }
  ]
} 