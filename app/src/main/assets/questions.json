{
  "categories": [
    {
      "id": "python",
      "name": "Python",
      "description": "Вопросы по языку программирования Python.",
      "questions": [
        {
          "text": "Что такое последовательность в Python?",
          "options": [
            "Итерабельный объект с доступом по индексам и поддержкой __len__",
            "Любой итерируемый объект",
            "Только списки и кортежи",
            "Объект с методами append() и extend()"
          ],
          "correctAnswer": "Итерабельный объект с доступом по индексам и поддержкой __len__",
          "explanation": "Последовательность — итерабельный объект, поддерживающий доступ по индексам через __getitem__() и имеющий метод __len__()."
        },
        {
          "text": "Какие встроенные типы являются последовательностями?",
          "options": [
            "list, tuple, range, str, bytes",
            "dict, set, frozenset",
            "int, float, bool",
            "function, class, module"
          ],
          "correctAnswer": "list, tuple, range, str, bytes",
          "explanation": "Основные встроенные последовательности: list, tuple, range, str и bytes."
        },
        {
          "text": "Какие методы могут реализовывать последовательности?",
          "options": [
            "count(), index(), __contains__(), __reversed__()",
            "add(), remove(), pop()",
            "keys(), values(), items()",
            "open(), close(), read()"
          ],
          "correctAnswer": "count(), index(), __contains__(), __reversed__()",
          "explanation": "Последовательности могут опционально реализовывать методы count(), index(), __contains__() и __reversed__()."
        },
        {
          "text": "Какие операции поддерживают неизменяемые последовательности?",
          "options": [
            "x in s, s + t, s * n, s[i], len(s), min(s), max(s)",
            "s.append(x), s.clear(), s.pop(), s.remove(x)",
            "s[i] = x, s[i:j] = t, del s[i:j]",
            "hash(s), s.copy(), s.extend(t)"
          ],
          "correctAnswer": "x in s, s + t, s * n, s[i], len(s), min(s), max(s)",
          "explanation": "Неизменяемые последовательности поддерживают операции проверки вхождения, конкатенации, срезов, получения длины, минимального и максимального элементов."
        },
        {
          "text": "Какие операции поддерживают изменяемые последовательности?",
          "options": [
            "s[i] = x, s.append(x), s.pop(), s.reverse()",
            "s + t, s * n, s[i], len(s)",
            "hash(s), s.count(x), s.index(x)",
            "min(s), max(s), sum(s)"
          ],
          "correctAnswer": "s[i] = x, s.append(x), s.pop(), s.reverse()",
          "explanation": "Изменяемые последовательности поддерживают операции изменения элементов, добавления, удаления и разворота."
        },
        {
          "text": "Что делает операция s[::-1]?",
          "options": [
            "Переворачивает последовательность",
            "Удаляет последний элемент",
            "Создает копию последовательности",
            "Возвращает минимальный элемент"
          ],
          "correctAnswer": "Переворачивает последовательность",
          "explanation": "Операция s[::-1] возвращает последовательность в обратном порядке."
        },
        {
          "text": "Что делает операция s.index(x)?",
          "options": [
            "Возвращает индекс первого вхождения x",
            "Удаляет первое вхождение x",
            "Подсчитывает количество вхождений x",
            "Вставляет x в начало последовательности"
          ],
          "correctAnswer": "Возвращает индекс первого вхождения x",
          "explanation": "Метод index(x) возвращает индекс первого вхождения элемента x в последовательности."
        },
        {
          "text": "Какие виды строк существуют в Python 2?",
          "options": [
            "str (однобайтные строки) и unicode (Юникод)",
            "Только str",
            "Только unicode",
            "bytes и str"
          ],
          "correctAnswer": "str (однобайтные строки) и unicode (Юникод)",
          "explanation": "В Python 2 есть два типа строк: str для однобайтных строк и unicode для строк в кодировке Юникод."
        },
        {
          "text": "Какие виды строк существуют в Python 3?",
          "options": [
            "str (Юникод) и bytes (цепочка байт)",
            "Только str",
            "Только bytes",
            "unicode и str"
          ],
          "correctAnswer": "str (Юникод) и bytes (цепочка байт)",
          "explanation": "В Python 3 строки представлены типом str (Юникод), а однобайтные строки заменены на тип bytes."
        },
        {
          "text": "Какой тип строк используется для Юникода в Python 3?",
          "options": [
            "str",
            "bytes",
            "unicode",
            "string"
          ],
          "correctAnswer": "str",
          "explanation": "В Python 3 тип str используется для представления строк в кодировке Юникод."
        },
        {
          "text": "Можно ли изменить отдельный символ внутри строки в Python?",
          "options": [
            "Нет, строки неизменяемы",
            "Да, с помощью индексации",
            "Да, с помощью метода replace()",
            "Только в Python 2"
          ],
          "correctAnswer": "Нет, строки неизменяемы",
          "explanation": "Строки в Python неизменяемы. Операции замены, форматирования и конкатенации возвращают новую строку."
        },
        {
          "text": "Что происходит при попытке изменить символ в строке?",
          "options": [
            "Возвращается новая строка",
            "Символ изменяется на месте",
            "Возникает ошибка TypeError",
            "Строка автоматически преобразуется в список"
          ],
          "correctAnswer": "Возникает ошибка TypeError",
          "explanation": "Попытка изменить символ в строке вызывает ошибку TypeError, так как строки неизменяемы."
        },
        {
          "text": "Как соединить список строк в одну строку?",
          "options": [
            "Использовать метод .join()",
            "Использовать метод .split()",
            "Использовать оператор +",
            "Использовать метод .concat()"
          ],
          "correctAnswer": "Использовать метод .join()",
          "explanation": "Метод .join() используется для соединения списка строк в одну строку."
        },
        {
          "text": "Как разбить строку на список строк?",
          "options": [
            "Использовать метод .split()",
            "Использовать метод .join()",
            "Использовать оператор *",
            "Использовать метод .partition()"
          ],
          "correctAnswer": "Использовать метод .split()",
          "explanation": "Метод .split() используется для разбиения строки на список строк."
        },
        {
          "text": "Как кодировать строку в байтовую строку?",
          "options": [
            "Использовать метод .encode()",
            "Использовать метод .decode()",
            "Использовать метод .convert()",
            "Использовать метод .bytes()"
          ],
          "correctAnswer": "Использовать метод .encode()",
          "explanation": "Метод .encode() используется для кодирования строки в байтовую строку."
        },
        {
          "text": "Как декодировать байтовую строку в строку?",
          "options": [
            "Использовать метод .decode()",
            "Использовать метод .encode()",
            "Использовать метод .convert()",
            "Использовать метод .str()"
          ],
          "correctAnswer": "Использовать метод .decode()",
          "explanation": "Метод .decode() используется для декодирования байтовой строки в строку."
        },
        {
          "text": "Какие исключения могут возникнуть при кодировании и декодировании строк?",
          "options": [
            "UnicodeEncodeError и UnicodeDecodeError",
            "ValueError и TypeError",
            "IndexError и KeyError",
            "SyntaxError и AttributeError"
          ],
          "correctAnswer": "UnicodeEncodeError и UnicodeDecodeError",
          "explanation": "При кодировании и декодировании строк могут возникнуть исключения UnicodeEncodeError и UnicodeDecodeError."
        },
        {
          "text": "Чем список отличается от кортежа?",
          "options": [
            "Списки изменяемы, кортежи неизменяемы",
            "Списки неизменяемы, кортежи изменяемы",
            "Списки хранят только числа, кортежи — любые данные",
            "Списки быстрее кортежей"
          ],
          "correctAnswer": "Списки изменяемы, кортежи неизменяемы",
          "explanation": "Списки — это изменяемые последовательности, а кортежи — неизменяемые."
        },
        {
          "text": "Какой метод используется для добавления элемента в конец списка?",
          "options": [
            "append()",
            "extend()",
            "insert()",
            "add()"
          ],
          "correctAnswer": "append()",
          "explanation": "Метод append() добавляет элемент в конец списка."
        },
        {
          "text": "Какой метод используется для вставки элемента в список по индексу?",
          "options": [
            "insert()",
            "append()",
            "extend()",
            "push()"
          ],
          "correctAnswer": "insert()",
          "explanation": "Метод insert() вставляет элемент на указанную позицию в списке."
        },
        {
          "text": "Какой метод используется для удаления элемента из списка по значению?",
          "options": [
            "remove()",
            "pop()",
            "delete()",
            "discard()"
          ],
          "correctAnswer": "remove()",
          "explanation": "Метод remove() удаляет первое вхождение указанного элемента из списка."
        },
        {
          "text": "Какой метод используется для удаления и возврата элемента из списка по индексу?",
          "options": [
            "pop()",
            "remove()",
            "delete()",
            "extract()"
          ],
          "correctAnswer": "pop()",
          "explanation": "Метод pop() удаляет и возвращает элемент по указанному индексу (по умолчанию последний)."
        },
        {
          "text": "Что такое диапазон (range) в Python?",
          "options": [
            "Неизменяемая последовательность чисел, задаваемая началом, концом и шагом",
            "Изменяемая последовательность чисел",
            "Функция, возвращающая список чисел",
            "Тип данных для хранения строк"
          ],
          "correctAnswer": "Неизменяемая последовательность чисел, задаваемая началом, концом и шагом",
          "explanation": "Диапазон (range) — это неизменяемая последовательность чисел, которая задается началом, концом и шагом."
        },
        {
          "text": "Какой класс представляет диапазон в Python 3?",
          "options": [
            "range",
            "xrange",
            "list",
            "tuple"
          ],
          "correctAnswer": "range",
          "explanation": "В Python 3 диапазон представлен классом range."
        },
        {
          "text": "Какие операции поддерживает диапазон (range)?",
          "options": [
            "Все общие для последовательностей операции, кроме конкатенации и повторения",
            "Только сложение и вычитание",
            "Только индексация и срезы",
            "Все операции, включая конкатенацию и повторение"
          ],
          "correctAnswer": "Все общие для последовательностей операции, кроме конкатенации и повторения",
          "explanation": "Диапазон поддерживает все общие для последовательностей операции, кроме конкатенации и повторения."
        },
        {
          "text": "Как сделать список уникальным, не сохраняя порядок элементов?",
          "options": [
            "Использовать set()",
            "Использовать OrderedDict",
            "Использовать цикл с проверкой",
            "Использовать метод .unique()"
          ],
          "correctAnswer": "Использовать set()",
          "explanation": "Преобразование списка в множество (set) удаляет дубликаты, но не гарантирует сохранение порядка элементов."
        },
        {
          "text": "Как сделать список уникальным, сохраняя порядок элементов?",
          "options": [
            "Использовать OrderedDict.fromkeys()",
            "Использовать set()",
            "Использовать метод .remove_duplicates()",
            "Использовать метод .distinct()"
          ],
          "correctAnswer": "Использовать OrderedDict.fromkeys()",
          "explanation": "Использование OrderedDict.fromkeys() удаляет дубликаты и сохраняет порядок элементов."
        },
        {
          "text": "Какой метод подходит для удаления дубликатов, если элементы нельзя помещать в множество?",
          "options": [
            "Использовать цикл с проверкой",
            "Использовать set()",
            "Использовать OrderedDict.fromkeys()",
            "Использовать метод .filter()"
          ],
          "correctAnswer": "Использовать цикл с проверкой",
          "explanation": "Цикл с проверкой подходит для удаления дубликатов, если элементы нельзя помещать в множество, например, словари."
        },
        {
          "text": "Как назначить переменным a, b, c значения из кортежа (1, 2, 3)?",
          "options": [
            "a, b, c = (1, 2, 3)",
            "a = 1; b = 2; c = 3",
            "a, b, c = [1, 2, 3]",
            "a, b, c = {1, 2, 3}"
          ],
          "correctAnswer": "a, b, c = (1, 2, 3)",
          "explanation": "Кортеж можно распаковать в переменные с помощью синтаксиса a, b, c = (1, 2, 3)."
        },
        {
          "text": "Когда две последовательности считаются равными?",
          "options": [
            "Если они имеют одинаковый тип, равную длину и соответствующие элементы равны",
            "Если они имеют одинаковый тип",
            "Если их длины равны",
            "Если их элементы равны"
          ],
          "correctAnswer": "Если они имеют одинаковый тип, равную длину и соответствующие элементы равны",
          "explanation": "Две последовательности равны, если они имеют одинаковый тип, равную длину и соответствующие элементы равны."
        },
        {
          "text": "Как сравниваются последовательности одинаковых типов?",
          "options": [
            "В лексикографическом порядке",
            "По длине последовательностей",
            "По типу последовательностей",
            "По первому элементу"
          ],
          "correctAnswer": "В лексикографическом порядке",
          "explanation": "Последовательности одинаковых типов сравниваются в лексикографическом порядке: сначала по длине, затем по первым отличающимся элементам."
        },
        {
          "text": "Какая последовательность считается меньшей, если их длины различаются?",
          "options": [
            "Последовательность меньшей длины",
            "Последовательность большей длины",
            "Последовательность с меньшим первым элементом",
            "Последовательность с большим первым элементом"
          ],
          "correctAnswer": "Последовательность меньшей длины",
          "explanation": "Последовательность меньшей длины считается меньшей, если длины последовательностей различаются."
        },
        {
          "text": "Что делает объект хешируемым?",
          "options": [
            "Наличие хеш-значения, которое не изменяется, и метода __eq__()",
            "Наличие метода __hash__()",
            "Наличие метода __eq__()",
            "Наличие неизменяемого состояния"
          ],
          "correctAnswer": "Наличие хеш-значения, которое не изменяется, и метода __eq__()",
          "explanation": "Объект хешируем, если он имеет хеш-значение, которое не изменяется, и может сравниваться с другими объектами (реализует метод __eq__())."
        },
        {
          "text": "Какие объекты являются хешируемыми по умолчанию?",
          "options": [
            "Неизменяемые объекты",
            "Изменяемые объекты",
            "Все объекты",
            "Только строки"
          ],
          "correctAnswer": "Неизменяемые объекты",
          "explanation": "Все стандартные неизменяемые объекты хешируемы, а изменяемые — нет."
        },
        {
          "text": "Что должно быть верно для равных хешируемых объектов?",
          "options": [
            "Они должны иметь равные хеш-значения",
            "Они должны иметь разные хеш-значения",
            "Они должны быть неизменяемыми",
            "Они должны быть изменяемыми"
          ],
          "correctAnswer": "Они должны иметь равные хеш-значения",
          "explanation": "Равные хешируемые объекты должны иметь равные хеш-значения."
        },
        {
          "text": "Что такое множество в Python?",
          "options": [
            "Неупорядоченная коллекция уникальных хешируемых объектов",
            "Упорядоченная коллекция объектов",
            "Коллекция объектов с возможностью дублирования",
            "Коллекция только числовых объектов"
          ],
          "correctAnswer": "Неупорядоченная коллекция уникальных хешируемых объектов",
          "explanation": "Множество — это неупорядоченная коллекция уникальных хешируемых объектов."
        },
        {
          "text": "Какие встроенные классы множеств существуют в Python?",
          "options": [
            "set и frozenset",
            "set и tuple",
            "frozenset и list",
            "set и dict"
          ],
          "correctAnswer": "set и frozenset",
          "explanation": "В Python есть два встроенных класса множеств: set (изменяемое множество) и frozenset (неизменяемое множество)."
        },
        {
          "text": "Поддерживают ли множества индексацию и срезы?",
          "options": [
            "Нет, множества не поддерживают индексацию и срезы",
            "Да, множества поддерживают индексацию",
            "Да, множества поддерживают срезы",
            "Только frozenset поддерживает индексацию"
          ],
          "correctAnswer": "Нет, множества не поддерживают индексацию и срезы",
          "explanation": "Множества не поддерживают индексацию и срезы, так как они неупорядочены."
        },
        {
          "text": "Для чего обычно применяются множества?",
          "options": [
            "Для проверки вхождения элемента и выполнения операций (объединение, пересечение и т.д.)",
            "Для хранения упорядоченных данных",
            "Для хранения данных с дубликатами",
            "Для выполнения математических вычислений"
          ],
          "correctAnswer": "Для проверки вхождения элемента и выполнения операций (объединение, пересечение и т.д.)",
          "explanation": "Множества используются для проверки вхождения элемента и выполнения операций, таких как объединение, пересечение, разница и симметрическая разница."
        },
        {
          "text": "Какая операция позволяет проверить вхождение элемента в множество?",
          "options": [
            "Оператор in",
            "Метод .contains()",
            "Метод .find()",
            "Оператор =="
          ],
          "correctAnswer": "Оператор in",
          "explanation": "Оператор in используется для проверки вхождения элемента в множество."
        },
        {
          "text": "Какие операции можно выполнять над множествами?",
          "options": [
            "Объединение, пересечение, разница, симметрическая разница",
            "Сложение, вычитание, умножение, деление",
            "Индексация, срезы, сортировка",
            "Конкатенация, повторение, сравнение"
          ],
          "correctAnswer": "Объединение, пересечение, разница, симметрическая разница",
          "explanation": "Над множествами можно выполнять операции объединения, пересечения, разницы и симметрической разницы."
        },
        {
          "text": "Какая операция используется для проверки вхождения элемента в множество?",
          "options": [
            "x in s",
            "s.contains(x)",
            "s.find(x)",
            "s.has(x)"
          ],
          "correctAnswer": "x in s",
          "explanation": "Операция x in s проверяет, содержится ли элемент x в множестве s."
        },
        {
          "text": "Какая операция возвращает объединение множеств?",
          "options": [
            "s.union(t)",
            "s.intersection(t)",
            "s.difference(t)",
            "s.symmetric_difference(t)"
          ],
          "correctAnswer": "s.union(t)",
          "explanation": "Метод s.union(t) возвращает новое множество, которое является объединением множеств s и t."
        },
        {
          "text": "Какая операция возвращает разницу множеств?",
          "options": [
            "s.difference(t)",
            "s.union(t)",
            "s.intersection(t)",
            "s.symmetric_difference(t)"
          ],
          "correctAnswer": "s.difference(t)",
          "explanation": "Метод s.difference(t) возвращает новое множество, которое содержит элементы, присутствующие в s, но отсутствующие в t."
        },
        {
          "text": "Какая операция используется для добавления элемента в множество?",
          "options": [
            "s.add(element)",
            "s.update(element)",
            "s.insert(element)",
            "s.append(element)"
          ],
          "correctAnswer": "s.add(element)",
          "explanation": "Метод s.add(element) добавляет новый элемент в множество s."
        },
        {
          "text": "Какая операция удаляет элемент из множества, если он существует?",
          "options": [
            "s.discard(element)",
            "s.remove(element)",
            "s.pop()",
            "s.delete(element)"
          ],
          "correctAnswer": "s.discard(element)",
          "explanation": "Метод s.discard(element) удаляет элемент из множества, если он существует, без вызова исключения."
        },
        {
          "text": "Как происходит проверка множеств на равенство?",
          "options": [
            "Поэлементно, независимо от типов множеств",
            "По типу множеств",
            "По порядку элементов",
            "По хеш-значениям элементов"
          ],
          "correctAnswer": "Поэлементно, независимо от типов множеств",
          "explanation": "Множества считаются равными, если они содержат одинаковые элементы, независимо от их типов."
        },
        {
          "text": "Что такое отображение (mapping) в Python?",
          "options": [
            "Объект-контейнер, поддерживающий доступ к элементам по ключам",
            "Неупорядоченная коллекция уникальных элементов",
            "Упорядоченная последовательность элементов",
            "Функция для преобразования данных"
          ],
          "correctAnswer": "Объект-контейнер, поддерживающий доступ к элементам по ключам",
          "explanation": "Отображение — это объект-контейнер, который поддерживает произвольный доступ к элементам по ключам."
        },
        {
          "text": "Какие классы относятся к отображениям?",
          "options": [
            "dict, defaultdict, OrderedDict, Counter",
            "list, tuple, set, frozenset",
            "str, bytes, bytearray",
            "int, float, bool"
          ],
          "correctAnswer": "dict, defaultdict, OrderedDict, Counter",
          "explanation": "К отображениям относятся классы dict, collections.defaultdict, collections.OrderedDict и collections.Counter."
        },
        {
          "text": "Какие методы описываются в абстрактном базовом классе collections.Mapping?",
          "options": [
            "get(), items(), keys(), values()",
            "clear(), pop(), popitem(), setdefault()",
            "append(), extend(), insert(), remove()",
            "add(), discard(), union(), intersection()"
          ],
          "correctAnswer": "get(), items(), keys(), values()",
          "explanation": "Абстрактный базовый класс collections.Mapping описывает методы get(), items(), keys() и values()."
        },
        {
          "text": "Какие нюансы есть при использовании чисел как ключей в словарях?",
          "options": [
            "int(1) и float(1.0) считаются одинаковым ключом",
            "int(1) и float(1.0) считаются разными ключами",
            "Ключи типа float всегда округляются",
            "Ключи типа int преобразуются в float"
          ],
          "correctAnswer": "int(1) и float(1.0) считаются одинаковым ключом",
          "explanation": "Числовые ключи подчиняются правилам сравнения чисел, поэтому int(1) и float(1.0) считаются одинаковым ключом."
        },
        {
          "text": "Почему не рекомендуется использовать float в качестве ключей?",
          "options": [
            "Из-за приближенного хранения значений float",
            "Из-за ограничений на размер ключей",
            "Из-за невозможности сравнения float",
            "Из-за автоматического преобразования в int"
          ],
          "correctAnswer": "Из-за приближенного хранения значений float",
          "explanation": "Значения типа float хранятся приближенно, что может привести к неожиданным результатам при использовании их в качестве ключей."
        },
        {
          "text": "Как безопасно получить значение по ключу в словаре?",
          "options": [
            "Использовать метод get()",
            "Использовать метод setdefault()",
            "Использовать метод pop()",
            "Использовать метод items()"
          ],
          "correctAnswer": "Использовать метод get()",
          "explanation": "Метод get() позволяет безопасно получить значение по ключу, не вызывая исключение KeyError, если ключ отсутствует."
        },
        {
          "text": "Как удалить произвольную пару ключ-значение из словаря?",
          "options": [
            "Использовать метод popitem()",
            "Использовать метод pop()",
            "Использовать метод clear()",
            "Использовать метод remove()"
          ],
          "correctAnswer": "Использовать метод popitem()",
          "explanation": "Метод popitem() удаляет и возвращает произвольную пару ключ-значение из словаря."
        },
        {
          "text": "Как добавить элементы в словарь, перезаписывая существующие ключи?",
          "options": [
            "Использовать метод update()",
            "Использовать метод setdefault()",
            "Использовать метод append()",
            "Использовать метод extend()"
          ],
          "correctAnswer": "Использовать метод update()",
          "explanation": "Метод update() добавляет элементы в словарь, перезаписывая значения для существующих ключей."
        },
        {
          "text": "Как создать новый словарь с ключами из последовательности и заданным значением?",
          "options": [
            "Использовать метод dict.fromkeys()",
            "Использовать метод dict.update()",
            "Использовать метод dict.setdefault()",
            "Использовать метод dict.items()"
          ],
          "correctAnswer": "Использовать метод dict.fromkeys()",
          "explanation": "Метод dict.fromkeys() создаёт новый словарь с ключами из последовательности и заданным значением."
        },
        {
          "text": "Что возвращает метод items() в Python 3?",
          "options": [
            "Объект представления словаря",
            "Список пар ключ-значение",
            "Итератор по ключам",
            "Словарь с новыми элементами"
          ],
          "correctAnswer": "Объект представления словаря",
          "explanation": "Метод items() возвращает объект представления словаря, который динамически отражает изменения в словаре."
        },
        {
          "text": "Какие операции поддерживают объекты представления словаря?",
          "options": [
            "Итерирование, проверка вхождения, получение длины",
            "Добавление и удаление элементов",
            "Сортировка и фильтрация",
            "Преобразование в список"
          ],
          "correctAnswer": "Итерирование, проверка вхождения, получение длины",
          "explanation": "Объекты представления словаря поддерживают итерирование, проверку вхождения и получение длины."
        },
        {
          "text": "Что произойдет, если изменить словарь во время итерирования по его представлению?",
          "options": [
            "Может возникнуть исключение RuntimeError",
            "Изменения не отразятся на представлении",
            "Представление автоматически обновится",
            "Итерирование начнется заново"
          ],
          "correctAnswer": "Может возникнуть исключение RuntimeError",
          "explanation": "При изменении словаря во время итерирования по его представлению может возникнуть исключение RuntimeError."
        },
        {
          "text": "Как отсортировать список словарей по определенному полю?",
          "options": [
            "Использовать параметр key в методе sort() или функции sorted()",
            "Использовать метод sort_by()",
            "Использовать метод order_by()",
            "Использовать метод arrange()"
          ],
          "correctAnswer": "Использовать параметр key в методе sort() или функции sorted()",
          "explanation": "Для сортировки списка словарей по определенному полю используется параметр key, который принимает функцию, возвращающую значение для сортировки."
        },
        {
          "text": "Какой пример кода сортирует список словарей по возрасту?",
          "options": [
            "users.sort(key=lambda user: user['age'])",
            "users.sort_by('age')",
            "users.order_by(lambda user: user['age'])",
            "users.arrange(key='age')"
          ],
          "correctAnswer": "users.sort(key=lambda user: user['age'])",
          "explanation": "Пример users.sort(key=lambda user: user['age']) сортирует список словарей по полю 'age'."
        },
        {
          "text": "Какие объекты могут быть ключами словаря?",
          "options": [
            "Хешируемые и неизменяемые объекты",
            "Любые объекты",
            "Только строки и числа",
            "Только кортежи"
          ],
          "correctAnswer": "Хешируемые и неизменяемые объекты",
          "explanation": "Ключом словаря может быть любой хешируемый и неизменяемый объект, например, числа, строки, кортежи."
        },
        {
          "text": "Почему списки не могут быть ключами словаря?",
          "options": [
            "Они изменяемы и не имеют метода хеширования",
            "Они слишком большие",
            "Они не поддерживают сравнение",
            "Они не могут быть преобразованы в строки"
          ],
          "correctAnswer": "Они изменяемы и не имеют метода хеширования",
          "explanation": "Списки изменяемы и не имеют метода хеширования, поэтому не могут быть ключами словаря."
        },
        {
          "text": "Может ли кортеж, содержащий словарь, быть ключом словаря?",
          "options": [
            "Нет, так как он содержит изменяемый элемент",
            "Да, так как кортеж неизменяем",
            "Да, если словарь пустой",
            "Нет, так как кортеж не поддерживает хеширование"
          ],
          "correctAnswer": "Нет, так как он содержит изменяемый элемент",
          "explanation": "Кортеж, содержащий изменяемый элемент (например, словарь), не может быть ключом словаря, так как его хеш не может быть рассчитан."
        },
        {
          "text": "Как составить словарь из двух списков: ключей и значений?",
          "options": [
            "Использовать dict(zip(keys, vals))",
            "Использовать dict(keys, vals)",
            "Использовать dict.fromkeys(keys, vals)",
            "Использовать dict.combine(keys, vals)"
          ],
          "correctAnswer": "Использовать dict(zip(keys, vals))",
          "explanation": "Функция zip создает пары ключ-значение, а конструктор dict преобразует их в словарь."
        },
        {
          "text": "Что делает функция zip в контексте создания словаря?",
          "options": [
            "Создает пары из элементов двух списков",
            "Объединяет два списка в один",
            "Сортирует элементы списков",
            "Преобразует списки в кортежи"
          ],
          "correctAnswer": "Создает пары из элементов двух списков",
          "explanation": "Функция zip создает пары из соответствующих элементов двух списков, которые затем используются для создания словаря."
        },
        {
          "text": "Что такое хэш-таблица в Python?",
          "options": [
            "Разреженный массив, где каждая ячейка содержит ключ и значение",
            "Список кортежей ключ-значение",
            "Массив, где индексы являются ключами",
            "Словарь, где ключи отсортированы"
          ],
          "correctAnswer": "Разреженный массив, где каждая ячейка содержит ключ и значение",
          "explanation": "Хэш-таблица — это разреженный массив, где каждая ячейка содержит ссылку на ключ и значение."
        },
        {
          "text": "Как Python обрабатывает коллизии хэширования?",
          "options": [
            "Использует дополнительные биты хэш-значения для поиска другой ячейки",
            "Создает новую хэш-таблицу",
            "Возвращает исключение KeyError",
            "Игнорирует коллизии"
          ],
          "correctAnswer": "Использует дополнительные биты хэш-значения для поиска другой ячейки",
          "explanation": "Для разрешения коллизий Python использует дополнительные биты хэш-значения и вычисляет смещение другой ячейки."
        },
        {
          "text": "Что происходит, если хэш-таблица становится слишком заполненной?",
          "options": [
            "Она копируется в новый участок памяти с большим количеством ячеек",
            "Возникает исключение MemoryError",
            "Python автоматически удаляет старые элементы",
            "Хэш-таблица перестает работать"
          ],
          "correctAnswer": "Она копируется в новый участок памяти с большим количеством ячеек",
          "explanation": "Если хэш-таблица становится слишком заполненной, Python копирует её в новый участок памяти с большим количеством ячеек."
        },
        {
          "text": "Что такое коллизия в контексте хэш-таблиц?",
          "options": [
            "Когда хэш-функция возвращает одинаковое значение для разных ключей",
            "Когда хэш-таблица переполняется",
            "Когда ключ не найден в хэш-таблице",
            "Когда хэш-функция возвращает ошибку"
          ],
          "correctAnswer": "Когда хэш-функция возвращает одинаковое значение для разных ключей",
          "explanation": "Коллизия возникает, когда хэш-функция возвращает одинаковое значение для разных ключей."
        },
        {
          "text": "Где будет быстрее поиск элемента: в dict/set или list/tuple?",
          "options": [
            "В dict и set, так как это хэш-таблицы",
            "В list и tuple, так как они упорядочены",
            "В list и set, так как они изменяемы",
            "В tuple и dict, так как они неизменяемы"
          ],
          "correctAnswer": "В dict и set, так как это хэш-таблицы",
          "explanation": "Поиск в dict и set выполняется за O(1), так как они реализованы как хэш-таблицы, в то время как в list и tuple поиск занимает O(n)."
        },
        {
          "text": "Почему итерация по dict и set в Python 3 может быть медленнее, чем по list?",
          "options": [
            "Из-за разреженного хранения данных в хэш-таблицах",
            "Из-за необходимости создания списка перед итерацией",
            "Из-за более сложной структуры данных",
            "Из-за ограничений на размер хэш-таблиц"
          ],
          "correctAnswer": "Из-за разреженного хранения данных в хэш-таблицах",
          "explanation": "Итерация по dict и set может быть медленнее, чем по list, из-за разреженного хранения данных в хэш-таблицах."
        },
        {
          "text": "Когда поиск в list может быть быстрее, чем в dict или set?",
          "options": [
            "Для очень маленьких списков (до 5 элементов)",
            "Для отсортированных списков",
            "Для списков, содержащих только числа",
            "Для списков, содержащих строки"
          ],
          "correctAnswer": "Для очень маленьких списков (до 5 элементов)",
          "explanation": "Для очень маленьких списков (до 5 элементов) поиск может быть быстрее, чем в dict или set, так как интерпретатору быстрее пробежаться по списку, чем вычислять хэш."
        },
        {
          "text": "Что такое *args и **kwargs в Python?",
          "options": [
            "*args — кортеж позиционных аргументов, **kwargs — словарь именованных аргументов",
            "*args — список позиционных аргументов, **kwargs — кортеж именованных аргументов",
            "*args — словарь позиционных аргументов, **kwargs — список именованных аргументов",
            "*args — кортеж именованных аргументов, **kwargs — словарь позиционных аргументов"
          ],
          "correctAnswer": "*args — кортеж позиционных аргументов, **kwargs — словарь именованных аргументов",
          "explanation": "*args собирает позиционные аргументы в кортеж, а **kwargs собирает именованные аргументы в словарь."
        },
        {
          "text": "Что будет, если в функцию не переданы аргументы для *args и **kwargs?",
          "options": [
            "args будет пустым кортежем, kwargs — пустым словарем",
            "args и kwargs будут равны None",
            "args будет пустым списком, kwargs — пустым словарем",
            "Будет вызвана ошибка"
          ],
          "correctAnswer": "args будет пустым кортежем, kwargs — пустым словарем",
          "explanation": "Если аргументы не переданы, args будет пустым кортежем, а kwargs — пустым словарем."
        },
        {
          "text": "Почему не рекомендуется использовать другие имена вместо args и kwargs?",
          "options": [
            "Это считается дурным тоном, так как args и kwargs — общепринятые имена",
            "Это вызовет ошибку интерпретатора",
            "Это замедлит выполнение функции",
            "Это ограничивает количество аргументов"
          ],
          "correctAnswer": "Это считается дурным тоном, так как args и kwargs — общепринятые имена",
          "explanation": "Использование других имен вместо args и kwargs не вызовет ошибок, но считается дурным тоном, так как эти имена общеприняты."
        },
        {
          "text": "Почему не рекомендуется использовать изменяемые объекты как параметры по умолчанию?",
          "options": [
            "Потому что они создаются один раз и могут изменяться между вызовами функции",
            "Потому что это замедляет выполнение функции",
            "Потому что это вызывает ошибку интерпретатора",
            "Потому что это ограничивает функциональность"
          ],
          "correctAnswer": "Потому что они создаются один раз и могут изменяться между вызовами функции",
          "explanation": "Изменяемые объекты создаются один раз при определении функции и могут изменяться между вызовами, что приводит к неожиданным результатам."
        },
        {
          "text": "Как исправить функцию, чтобы избежать проблемы с изменяемыми параметрами по умолчанию?",
          "options": [
            "Использовать None и создавать новый объект внутри функции",
            "Использовать неизменяемые объекты, такие как кортежи",
            "Использовать глобальные переменные",
            "Использовать декораторы"
          ],
          "correctAnswer": "Использовать None и создавать новый объект внутри функции",
          "explanation": "Хорошей практикой является использование None в качестве значения по умолчанию и создание нового объекта внутри функции, если значение не передано."
        },
        {
          "text": "Какие объекты можно использовать как безопасные значения по умолчанию?",
          "options": [
            "None, 0, '', False",
            "Списки, словари, множества",
            "Любые неизменяемые объекты",
            "Любые изменяемые объекты"
          ],
          "correctAnswer": "None, 0, '', False",
          "explanation": "Безопасными значениями по умолчанию являются None, 0, '', False, так как они неизменяемы и не приводят к неожиданным результатам."
        },
        {
          "text": "Можно ли передавать функцию в качестве аргумента другой функции?",
          "options": [
            "Да, функции в Python являются объектами первого порядка",
            "Нет, функции нельзя передавать как аргументы",
            "Только если функция объявлена как лямбда",
            "Только если функция возвращает значение"
          ],
          "correctAnswer": "Да, функции в Python являются объектами первого порядка",
          "explanation": "Функции в Python являются объектами первого порядка, что позволяет передавать их в качестве аргументов другим функциям."
        },
        {
          "text": "Можно ли объявлять функцию внутри другой функции?",
          "options": [
            "Да, и она будет видна только внутри внешней функции",
            "Да, и она будет видна глобально",
            "Нет, это вызовет ошибку",
            "Только если она объявлена как лямбда"
          ],
          "correctAnswer": "Да, и она будет видна только внутри внешней функции",
          "explanation": "Функцию можно объявлять внутри другой функции, и она будет видна только в пределах этой внешней функции."
        },
        {
          "text": "Что такое лямбда-функции в Python?",
          "options": [
            "Анонимные функции, состоящие из одного выражения",
            "Функции, которые резервируют имя в пространстве имен",
            "Функции, которые могут содержать несколько операторов",
            "Функции, которые используются только для математических операций"
          ],
          "correctAnswer": "Анонимные функции, состоящие из одного выражения",
          "explanation": "Лямбда-функции — это анонимные функции, которые состоят из одного выражения и не резервируют имени в пространстве имен."
        },
        {
          "text": "Какие функции часто используют лямбды в качестве аргументов?",
          "options": [
            "map, reduce, filter",
            "len, sum, max",
            "print, input, open",
            "range, list, dict"
          ],
          "correctAnswer": "map, reduce, filter",
          "explanation": "Лямбды часто передаются в функции map, reduce и filter для выполнения операций над коллекциями."
        },
        {
          "text": "Можно ли использовать несколько операторов в лямбда-функции?",
          "options": [
            "Нет, лямбда может содержать только одно выражение",
            "Да, если использовать точку с запятой",
            "Да, если использовать фигурные скобки",
            "Да, если использовать ключевое слово return"
          ],
          "correctAnswer": "Нет, лямбда может содержать только одно выражение",
          "explanation": "Лямбда-функции могут содержать только одно выражение, и использование точки с запятой для разделения операторов не допускается."
        },
        {
          "text": "Почему выражение `nope = lambda: pass` недопустимо?",
          "options": [
            "Потому что `pass` является оператором, а лямбда может содержать только выражения",
            "Потому что `pass` не может быть использован в функциях",
            "Потому что лямбда должна возвращать значение",
            "Потому что `pass` не является допустимым ключевым словом"
          ],
          "correctAnswer": "Потому что `pass` является оператором, а лямбда может содержать только выражения",
          "explanation": "Лямбда-функции могут содержать только выражения, а `pass` является оператором, что вызывает ошибку SyntaxError."
        },
        {
          "text": "Почему выражение `riser = lambda x: raise Exception(x)` недопустимо?",
          "options": [
            "Потому что `raise` является оператором, а лямбда может содержать только выражения",
            "Потому что `raise` не может быть использован в функциях",
            "Потому что лямбда должна возвращать значение",
            "Потому что `raise` не является допустимым ключевым словом"
          ],
          "correctAnswer": "Потому что `raise` является оператором, а лямбда может содержать только выражения",
          "explanation": "Лямбда-функции могут содержать только выражения, а `raise` является оператором, что вызывает ошибку SyntaxError."
        },
        {
          "text": "Как передаются аргументы в функции в Python?",
          "options": [
            "Имена аргументов связываются с существующими объектами",
            "Значения аргументов копируются в новую область памяти",
            "Передаются только ссылки на объекты в динамической памяти",
            "Аргументы передаются через стек"
          ],
          "correctAnswer": "Имена аргументов связываются с существующими объектами",
          "explanation": "В Python аргументы передаются путем связывания имен аргументов с существующими объектами, а не через копирование значений или передачу ссылок."
        },
        {
          "text": "Что происходит с изменяемыми объектами при передаче в функцию?",
          "options": [
            "Изменения объекта видны вне функции, так как имя связано с тем же объектом",
            "Создается копия объекта, и изменения не видны вне функции",
            "Объект передается через стек, и изменения не видны вне функции",
            "Объект автоматически преобразуется в неизменяемый"
          ],
          "correctAnswer": "Изменения объекта видны вне функции, так как имя связано с тем же объектом",
          "explanation": "Для изменяемых объектов изменения, сделанные внутри функции, видны вне функции, так как имя аргумента связано с тем же объектом."
        },
        {
          "text": "Что происходит с неизменяемыми объектами при передаче в функцию?",
          "options": [
            "Создается новый объект при изменении, и изменения не видны вне функции",
            "Изменения объекта видны вне функции, так как имя связано с тем же объектом",
            "Объект передается через стек, и изменения не видны вне функции",
            "Объект автоматически преобразуется в изменяемый"
          ],
          "correctAnswer": "Создается новый объект при изменении, и изменения не видны вне функции",
          "explanation": "Для неизменяемых объектов при изменении создается новый объект, и изменения не видны вне функции, так как имя аргумента связывается с новым объектом."
        },
        {
          "text": "Что такое замыкание в Python?",
          "options": [
            "Функция, которая содержит ссылки на переменные внешней функции",
            "Функция, которая возвращает другую функцию",
            "Функция, которая вызывается внутри другой функции",
            "Функция, которая не принимает аргументов"
          ],
          "correctAnswer": "Функция, которая содержит ссылки на переменные внешней функции",
          "explanation": "Замыкание — это функция, которая содержит ссылки на локальные переменные внешней функции и сохраняет их даже после завершения работы внешней функции."
        },
        {
          "text": "Когда создается новый экземпляр внутренней функции в замыкании?",
          "options": [
            "Каждый раз при выполнении внешней функции",
            "Только при первом вызове внешней функции",
            "Когда внутренняя функция вызывается явно",
            "Когда внешняя функция завершает выполнение"
          ],
          "correctAnswer": "Каждый раз при выполнении внешней функции",
          "explanation": "При каждом выполнении внешней функции создается новый экземпляр внутренней функции с новыми ссылками на переменные внешней функции."
        },
        {
          "text": "Что такое контейнер в Python?",
          "options": [
            "Тип данных, который инкапсулирует значения других типов",
            "Тип данных, который хранит только числа",
            "Тип данных, который используется для хранения функций",
            "Тип данных, который поддерживает только неизменяемые объекты"
          ],
          "correctAnswer": "Тип данных, который инкапсулирует значения других типов",
          "explanation": "Контейнер — это тип данных, который инкапсулирует в себе значения других типов, например, списки, кортежи, множества и словари."
        },
        {
          "text": "Какие из следующих типов данных являются контейнерами?",
          "options": [
            "Списки, кортежи, множества, словари",
            "Числа, строки, булевы значения",
            "Функции, модули, классы",
            "Итераторы, генераторы, декораторы"
          ],
          "correctAnswer": "Списки, кортежи, множества, словари",
          "explanation": "Списки, кортежи, множества и словари являются контейнерами, так как они инкапсулируют значения других типов."
        },
        {
          "text": "Что такое итерабельный объект в Python?",
          "options": [
            "Объект, который может возвращать значения по одному за раз",
            "Объект, который может изменять свои значения",
            "Объект, который хранит только числа",
            "Объект, который поддерживает только неизменяемые элементы"
          ],
          "correctAnswer": "Объект, который может возвращать значения по одному за раз",
          "explanation": "Итерабельный объект — это объект, который может возвращать значения по одному за раз, например, списки, строки, файлы и другие контейнеры."
        },
        {
          "text": "Какие методы должен реализовывать итерабельный объект?",
          "options": [
            "__iter__ или __getitem__",
            "__next__ или __iter__",
            "__len__ или __getitem__",
            "__contains__ или __iter__"
          ],
          "correctAnswer": "__iter__ или __getitem__",
          "explanation": "Итерабельный объект должен реализовывать метод __iter__ или __getitem__, чтобы быть итерируемым."
        },
        {
          "text": "Как функция iter() работает с объектом?",
          "options": [
            "Сначала вызывает __iter__, затем __getitem__, если __iter__ не реализован",
            "Сначала вызывает __getitem__, затем __iter__, если __getitem__ не реализован",
            "Вызывает только __iter__",
            "Вызывает только __getitem__"
          ],
          "correctAnswer": "Сначала вызывает __iter__, затем __getitem__, если __iter__ не реализован",
          "explanation": "Функция iter() сначала пытается вызвать метод __iter__, а если он не реализован, то проверяет наличие метода __getitem__ и создает итератор на его основе."
        },
        {
          "text": "Что такое итератор в Python?",
          "options": [
            "Объект, который представляет поток данных и возвращает элементы по одному",
            "Объект, который хранит все элементы в памяти",
            "Объект, который изменяет элементы потока",
            "Объект, который сортирует элементы потока"
          ],
          "correctAnswer": "Объект, который представляет поток данных и возвращает элементы по одному",
          "explanation": "Итератор — это объект, который представляет поток данных и возвращает элементы по одному с помощью метода __next__."
        },
        {
          "text": "Какое исключение выбрасывается, когда итератор исчерпан?",
          "options": [
            "StopIteration",
            "IndexError",
            "ValueError",
            "KeyError"
          ],
          "correctAnswer": "StopIteration",
          "explanation": "Когда итератор исчерпан, он выбрасывает исключение StopIteration."
        },
        {
          "text": "Какие методы должен реализовывать итератор?",
          "options": [
            "__iter__ и __next__",
            "__len__ и __getitem__",
            "__contains__ и __iter__",
            "__next__ и __len__"
          ],
          "correctAnswer": "__iter__ и __next__",
          "explanation": "Итератор должен реализовывать методы __iter__ и __next__, чтобы быть итератором."
        },
        {
          "text": "Что такое генератор в Python?",
          "options": [
            "Функция с ключевым словом yield или итератор, созданный генераторным выражением",
            "Функция, которая возвращает список значений",
            "Функция, которая создает итератор из коллекции",
            "Функция, которая сортирует элементы коллекции"
          ],
          "correctAnswer": "Функция с ключевым словом yield или итератор, созданный генераторным выражением",
          "explanation": "Генератор — это функция с ключевым словом yield или итератор, созданный генераторным выражением, который возвращает значения по одному."
        },
        {
          "text": "Какое ключевое слово используется в функции-генераторе?",
          "options": [
            "yield",
            "return",
            "next",
            "iter"
          ],
          "correctAnswer": "yield",
          "explanation": "Ключевое слово yield используется в функции-генераторе для возврата значений по одному."
        },
        {
          "text": "Какое исключение возникает, когда выполнение функции-генератора завершается?",
          "options": [
            "StopIteration",
            "IndexError",
            "ValueError",
            "KeyError"
          ],
          "correctAnswer": "StopIteration",
          "explanation": "Когда выполнение функции-генератора завершается, возникает исключение StopIteration."
        },
        {
          "text": "Что такое генераторная функция в Python?",
          "options": [
            "Функция, в теле которой используется ключевое слово yield",
            "Функция, которая возвращает список значений",
            "Функция, которая создает итератор из коллекции",
            "Функция, которая сортирует элементы коллекции"
          ],
          "correctAnswer": "Функция, в теле которой используется ключевое слово yield",
          "explanation": "Генераторная функция — это функция, в теле которой используется ключевое слово yield, и которая возвращает объект-генератор."
        },
        {
          "text": "Что возвращает генераторная функция при вызове?",
          "options": [
            "Объект-генератор",
            "Список значений",
            "Итератор из коллекции",
            "Отсортированную коллекцию"
          ],
          "correctAnswer": "Объект-генератор",
          "explanation": "Генераторная функция возвращает объект-генератор, который можно использовать для итерации по значениям."
        },
        {
          "text": "Что делает ключевое слово yield в Python?",
          "options": [
            "Замораживает состояние функции и возвращает текущее значение",
            "Завершает выполнение функции",
            "Возвращает список значений",
            "Создает новый объект-генератор"
          ],
          "correctAnswer": "Замораживает состояние функции и возвращает текущее значение",
          "explanation": "Ключевое слово yield замораживает состояние функции-генератора и возвращает текущее значение, позволяя продолжить выполнение с этого места при следующем вызове."
        },
        {
          "text": "Что происходит после вызова __next__() на объекте-генераторе?",
          "options": [
            "Функция-генератор продолжает выполнение с места, где была приостановлена",
            "Функция-генератор завершает выполнение",
            "Функция-генератор возвращает список значений",
            "Функция-генератор создает новый объект-генератор"
          ],
          "correctAnswer": "Функция-генератор продолжает выполнение с места, где была приостановлена",
          "explanation": "После вызова __next__() функция-генератор продолжает выполнение с того места, где она была приостановлена с помощью yield."
        },
        {
          "text": "В чем отличие [x for x in y] от (x for x in y)?",
          "options": [
            "Первое возвращает список, второе — генератор",
            "Первое возвращает генератор, второе — список",
            "Первое работает быстрее, чем второе",
            "Первое поддерживает только числа, второе — любые типы"
          ],
          "correctAnswer": "Первое возвращает список, второе — генератор",
          "explanation": "[x for x in y] возвращает список (списковое включение), а (x for x in y) возвращает генератор."
        },
        {
          "text": "Что особенного в генераторе?",
          "options": [
            "Он хранит в памяти только состояние для вычисления следующего элемента",
            "Он хранит в памяти все элементы",
            "Он позволяет вернуться к предыдущим элементам",
            "Он может быть пройден в цикле несколько раз"
          ],
          "correctAnswer": "Он хранит в памяти только состояние для вычисления следующего элемента",
          "explanation": "Генератор хранит в памяти только внутреннее состояние для вычисления очередного элемента, а не все элементы."
        },
        {
          "text": "Сколько раз можно пройти генератор в цикле?",
          "options": [
            "Только один раз",
            "Два раза",
            "Сколько угодно раз",
            "Только если генератор создан из списка"
          ],
          "correctAnswer": "Только один раз",
          "explanation": "Генератор можно пройти в цикле только один раз, так как он вычисляет элементы на лету и не хранит их в памяти."
        },
        {
          "text": "Как объявить генератор в Python?",
          "options": [
            "Использовать синтаксис (x for x in seq), оператор yield или функцию iter",
            "Использовать только синтаксис (x for x in seq)",
            "Использовать только оператор yield",
            "Использовать только функцию iter"
          ],
          "correctAnswer": "Использовать синтаксис (x for x in seq), оператор yield или функцию iter",
          "explanation": "Генератор можно объявить с помощью синтаксиса (x for x in seq), оператора yield в функции или функции iter, которая вызывает метод __iter__()."
        },
        {
          "text": "Что делает оператор yield в генераторе?",
          "options": [
            "Возвращает значение и приостанавливает выполнение функции",
            "Завершает выполнение функции",
            "Создает новый объект-генератор",
            "Возвращает список значений"
          ],
          "correctAnswer": "Возвращает значение и приостанавливает выполнение функции",
          "explanation": "Оператор yield возвращает значение и приостанавливает выполнение функции, позволяя продолжить с этого места при следующем вызове."
        },
        {
          "text": "Как получить список из генератора?",
          "options": [
            "Использовать конструктор list()",
            "Использовать метод to_list()",
            "Использовать функцию convert_to_list()",
            "Использовать оператор []"
          ],
          "correctAnswer": "Использовать конструктор list()",
          "explanation": "Чтобы получить список из генератора, нужно передать генератор в конструктор list()."
        },
        {
          "text": "Что происходит с генератором после преобразования в список?",
          "options": [
            "По нему уже нельзя итерироваться",
            "Он остается доступным для итерации",
            "Он автоматически удаляется",
            "Он преобразуется в кортеж"
          ],
          "correctAnswer": "По нему уже нельзя итерироваться",
          "explanation": "После преобразования генератора в список по нему уже нельзя итерироваться, так как все элементы были извлечены."
        },
        {
          "text": "Что такое подгенератор в Python?",
          "options": [
            "Генератор, который делегируется с помощью yield from",
            "Генератор, который вызывается внутри другого генератора",
            "Генератор, который возвращает значения из списка",
            "Генератор, который создается с помощью функции iter"
          ],
          "correctAnswer": "Генератор, который делегируется с помощью yield from",
          "explanation": "Подгенератор — это генератор, который делегируется с помощью ключевых слов yield from, пока он не завершится."
        },
        {
          "text": "Что возвращает выражение yield from?",
          "options": [
            "Значение, которое подгенератор возвращает в исключении StopIteration",
            "Список значений подгенератора",
            "Объект-генератор",
            "None"
          ],
          "correctAnswer": "Значение, которое подгенератор возвращает в исключении StopIteration",
          "explanation": "Выражение yield from возвращает значение, которое подгенератор возвращает в исключении StopIteration."
        },
        {
          "text": "Какие методы есть у генераторов?",
          "options": [
            "__next__, send, throw, close",
            "__iter__, __next__, send, close",
            "__next__, send, yield, close",
            "__iter__, send, throw, close"
          ],
          "correctAnswer": "__next__, send, throw, close",
          "explanation": "Генераторы имеют методы __next__, send, throw и close для управления их выполнением."
        },
        {
          "text": "Что делает метод send у генератора?",
          "options": [
            "Продолжает выполнение и отправляет значение в генератор",
            "Завершает выполнение генератора",
            "Возвращает текущее значение генератора",
            "Выбрасывает исключение в генераторе"
          ],
          "correctAnswer": "Продолжает выполнение и отправляет значение в генератор",
          "explanation": "Метод send продолжает выполнение генератора и отправляет значение в текущее yield-выражение."
        },
        {
          "text": "Что делает метод close у генератора?",
          "options": [
            "Выбрасывает исключение GeneratorExit в месте приостановки генератора",
            "Завершает выполнение генератора без исключений",
            "Возвращает последнее значение генератора",
            "Продолжает выполнение генератора"
          ],
          "correctAnswer": "Выбрасывает исключение GeneratorExit в месте приостановки генератора",
          "explanation": "Метод close выбрасывает исключение GeneratorExit в месте приостановки генератора, чтобы завершить его выполнение."
        },
        {
          "text": "Можно ли извлечь элемент генератора по индексу?",
          "options": [
            "Нет, генератор не поддерживает метод __getitem__",
            "Да, с помощью метода __getitem__",
            "Да, с помощью функции get()",
            "Да, с помощью метода getitem"
          ],
          "correctAnswer": "Нет, генератор не поддерживает метод __getitem__",
          "explanation": "Генератор не поддерживает метод __getitem__, поэтому извлечь элемент по индексу нельзя."
        },
        {
          "text": "Что возвращает итерация по словарю?",
          "options": [
            "Ключи словаря",
            "Значения словаря",
            "Пары ключ-значение",
            "Индексы элементов"
          ],
          "correctAnswer": "Ключи словаря",
          "explanation": "Итерация по словарю возвращает ключи словаря."
        },
        {
          "text": "Гарантируется ли порядок ключей при итерации по словарю?",
          "options": [
            "В Python 3.7 и выше порядок гарантируется",
            "Порядок никогда не гарантируется",
            "Порядок гарантируется только для маленьких словарей",
            "Порядок гарантируется только для OrderedDict"
          ],
          "correctAnswer": "В Python 3.7 и выше порядок гарантируется",
          "explanation": "Начиная с Python 3.7 порядок ключей при итерации по словарю гарантируется."
        },
        {
          "text": "Как итерировать словарь по парам ключ-значение?",
          "options": [
            "Использовать метод items()",
            "Использовать метод keys()",
            "Использовать метод values()",
            "Использовать метод get()"
          ],
          "correctAnswer": "Использовать метод items()",
          "explanation": "Метод items() возвращает генератор кортежей (key, value), что позволяет итерировать словарь по парам ключ-значение."
        },
        {
          "text": "Что такое сопрограмма в Python?",
          "options": [
            "Компонент программы, поддерживающий множество входных точек и остановку/продолжение выполнения",
            "Функция, которая возвращает генератор",
            "Функция, которая использует yield для возврата значений",
            "Функция, которая выполняет асинхронные операции"
          ],
          "correctAnswer": "Компонент программы, поддерживающий множество входных точек и остановку/продолжение выполнения",
          "explanation": "Сопрограмма — это компонент программы, который поддерживает множество входных точек и остановку/продолжение выполнения с сохранением положения."
        },
        {
          "text": "Какие ключевые слова используются для работы с сопрограммами в Python 3.5 и выше?",
          "options": [
            "async и await",
            "yield и yield from",
            "coroutine и await",
            "async и yield"
          ],
          "correctAnswer": "async и await",
          "explanation": "Начиная с Python 3.5, для работы с сопрограммами используются ключевые слова async и await."
        },
        {
          "text": "Как получить список атрибутов объекта?",
          "options": [
            "Использовать функцию dir",
            "Использовать метод __dict__",
            "Использовать функцию vars",
            "Использовать метод attributes"
          ],
          "correctAnswer": "Использовать функцию dir",
          "explanation": "Функция dir возвращает список строк — полей объекта."
        },
        {
          "text": "Что содержит поле __dict__ объекта?",
          "options": [
            "Словарь вида {поле -> значение}",
            "Список всех атрибутов объекта",
            "Список методов объекта",
            "Словарь всех встроенных атрибутов"
          ],
          "correctAnswer": "Словарь вида {поле -> значение}",
          "explanation": "Поле __dict__ содержит словарь вида {поле -> значение}, который хранит атрибуты объекта."
        },
        {
          "text": "Что такое магические методы в Python?",
          "options": [
            "Методы, которые вызываются встроенными функциями или синтаксическими конструкциями",
            "Методы, которые выполняют сложные вычисления",
            "Методы, которые доступны только в магических классах",
            "Методы, которые начинаются с одного подчеркивания"
          ],
          "correctAnswer": "Методы, которые вызываются встроенными функциями или синтаксическими конструкциями",
          "explanation": "Магические методы — это методы, которые начинаются и заканчиваются двойным подчеркиванием и вызываются встроенными функциями или синтаксическими конструкциями."
        },
        {
          "text": "Какой магический метод вызывается при сложении объектов оператором +?",
          "options": [
            "__add__",
            "__init__",
            "__eq__",
            "__iter__"
          ],
          "correctAnswer": "__add__",
          "explanation": "Метод __add__ вызывается автоматически при сложении объектов оператором +."
        },
        {
          "text": "Какой магический метод вызывается функцией len()?",
          "options": [
            "__len__",
            "__init__",
            "__eq__",
            "__iter__"
          ],
          "correctAnswer": "__len__",
          "explanation": "Функция len() вызывает магический метод __len__ для получения длины объекта."
        },
        {
          "text": "Как в классе сослаться на родительский класс?",
          "options": [
            "Использовать функцию super",
            "Использовать метод __parent__",
            "Использовать метод __base__",
            "Использовать функцию parent"
          ],
          "correctAnswer": "Использовать функцию super",
          "explanation": "Функция super используется для ссылки на родительский класс и вызова его методов."
        },
        {
          "text": "Какие аргументы принимает функция super?",
          "options": [
            "Класс и экземпляр",
            "Только класс",
            "Только экземпляр",
            "Класс и метод"
          ],
          "correctAnswer": "Класс и экземпляр",
          "explanation": "Функция super принимает класс и экземпляр для корректного вызова методов родительского класса."
        },
        {
          "text": "Возможно ли множественное наследование в Python?",
          "options": [
            "Да, можно указать более одного родителя в классе потомка",
            "Нет, Python поддерживает только одиночное наследование",
            "Да, но только если родители не имеют общих методов",
            "Нет, это вызывает ошибку"
          ],
          "correctAnswer": "Да, можно указать более одного родителя в классе потомка",
          "explanation": "Python поддерживает множественное наследование, позволяя указать более одного родителя в классе потомка."
        },
        {
          "text": "Что такое MRO в Python?",
          "options": [
            "Порядок разрешения методов при множественном наследовании",
            "Метод для поиска атрибутов в классе",
            "Алгоритм для сортировки методов в классе",
            "Метод для определения родительского класса"
          ],
          "correctAnswer": "Порядок разрешения методов при множественном наследовании",
          "explanation": "MRO (Method Resolution Order) — это порядок разрешения методов, который определяет, как искать метод в случае множественного наследования."
        },
        {
          "text": "Какой алгоритм используется для MRO в Python?",
          "options": [
            "C3-линеаризация",
            "DFLR (Обход вглубину и слева направо)",
            "BFS (Поиск в ширину)",
            "DFS (Поиск в глубину)"
          ],
          "correctAnswer": "C3-линеаризация",
          "explanation": "В Python используется алгоритм C3-линеаризации для определения порядка разрешения методов (MRO)."
        },
        {
          "text": "Какой атрибут содержит порядок MRO для класса?",
          "options": [
            "__mro__",
            "__bases__",
            "__class__",
            "__dict__"
          ],
          "correctAnswer": "__mro__",
          "explanation": "Атрибут __mro__ содержит порядок разрешения методов (MRO) для класса."
        },
        {
          "text": "Что такое Diamond problem в Python?",
          "options": [
            "Проблема выбора метода при ромбовидном наследовании",
            "Проблема с множественным наследованием",
            "Проблема с вызовом методов родительского класса",
            "Проблема с определением атрибутов класса"
          ],
          "correctAnswer": "Проблема выбора метода при ромбовидном наследовании",
          "explanation": "Diamond problem — это проблема выбора метода, который должен быть вызван при ромбовидном наследовании, когда класс наследует от двух классов, которые, в свою очередь, наследуют от одного общего класса."
        },
        {
          "text": "Что такое миксины в Python?",
          "options": [
            "Небольшие классы-помощники, добавляемые в цепочку наследования",
            "Классы, которые нельзя наследовать",
            "Классы, которые используются только для хранения данных",
            "Классы, которые автоматически создают методы"
          ],
          "correctAnswer": "Небольшие классы-помощники, добавляемые в цепочку наследования",
          "explanation": "Миксины — это небольшие классы-помощники, которые добавляются в цепочку наследования для предоставления дополнительных методов или функциональности."
        },
        {
          "text": "Как принято называть миксины?",
          "options": [
            "Добавлять слово Mixin в название",
            "Добавлять слово Helper в название",
            "Добавлять слово Base в название",
            "Добавлять слово Util в название"
          ],
          "correctAnswer": "Добавлять слово Mixin в название",
          "explanation": "В названия миксинов принято добавлять слово Mixin, чтобы обозначить их роль в качестве примесей."
        },
        {
          "text": "Что такое контекстный менеджер в Python?",
          "options": [
            "Объект, который управляет входом и выходом из блока with",
            "Объект, который управляет выполнением функций",
            "Объект, который управляет памятью",
            "Объект, который управляет исключениями"
          ],
          "correctAnswer": "Объект, который управляет входом и выходом из блока with",
          "explanation": "Контекстный менеджер — это объект, который управляет входом и выходом из блока with, используя методы __enter__ и __exit__."
        },
        {
          "text": "Какие методы должен реализовывать контекстный менеджер?",
          "options": [
            "__enter__ и __exit__",
            "__init__ и __del__",
            "__start__ и __stop__",
            "__open__ и __close__"
          ],
          "correctAnswer": "__enter__ и __exit__",
          "explanation": "Контекстный менеджер должен реализовывать методы __enter__ и __exit__ для управления входом и выходом из блока with."
        },
        {
          "text": "Как можно создать контекстный менеджер с помощью contextlib?",
          "options": [
            "Использовать декоратор @contextmanager",
            "Использовать функцию context_manager",
            "Использовать класс ContextManager",
            "Использовать функцию with_context"
          ],
          "correctAnswer": "Использовать декоратор @contextmanager",
          "explanation": "С помощью библиотеки contextlib можно создать контекстный менеджер, используя декоратор @contextmanager."
        },
        {
          "text": "Что вернет выражение object() == object()?",
          "options": [
            "Всегда False",
            "Всегда True",
            "Зависит от реализации Python",
            "Зависит от содержимого объектов"
          ],
          "correctAnswer": "Всегда False",
          "explanation": "Выражение object() == object() всегда возвращает False, так как объекты сравниваются по их id (адресу в памяти), если метод __eq__ не переопределен."
        },
        {
          "text": "Как объекты сравниваются по умолчанию в Python?",
          "options": [
            "По их id (адресу в памяти)",
            "По их содержимому",
            "По их типу",
            "По их размеру"
          ],
          "correctAnswer": "По их id (адресу в памяти)",
          "explanation": "По умолчанию объекты в Python сравниваются по их id (адресу в памяти), если метод __eq__ не переопределен."
        },
        {
          "text": "Что такое __slots__ в Python?",
          "options": [
            "Механизм для фиксации набора полей класса",
            "Механизм для динамического добавления полей",
            "Механизм для управления памятью",
            "Механизм для создания словаря полей"
          ],
          "correctAnswer": "Механизм для фиксации набора полей класса",
          "explanation": "__slots__ — это механизм, который жестко фиксирует набор полей класса, предотвращая динамическое добавление новых полей."
        },
        {
          "text": "Какие преимущества у использования __slots__?",
          "options": [
            "Экономия памяти и повышение производительности",
            "Возможность динамически добавлять поля",
            "Упрощение работы с методами __getattr__ и __setattr__",
            "Автоматическое создание словаря полей"
          ],
          "correctAnswer": "Экономия памяти и повышение производительности",
          "explanation": "Использование __slots__ позволяет экономить память и повышать производительность, так как доступ к слотам быстрее, чем поиск в словаре."
        },
        {
          "text": "Какие недостатки у использования __slots__?",
          "options": [
            "Нельзя добавить поле, которого нет в слотах",
            "Снижение производительности",
            "Увеличение потребления памяти",
            "Невозможность использования методов __getattr__ и __setattr__"
          ],
          "correctAnswer": "Нельзя добавить поле, которого нет в слотах",
          "explanation": "Основной недостаток __slots__ — это невозможность добавить поле, которого нет в слотах, если не включить __dict__ в __slots__."
        },
        {
          "text": "Что означает одно подчеркивание перед именем поля в Python?",
          "options": [
            "Поле используется только внутри класса (соглашение)",
            "Поле недоступно извне",
            "Поле является приватным",
            "Поле является защищенным"
          ],
          "correctAnswer": "Поле используется только внутри класса (соглашение)",
          "explanation": "Одно подчеркивание перед именем поля указывает, что оно используется только внутри класса, но доступно извне (соглашение)."
        },
        {
          "text": "Что означает двойное подчеркивание перед именем поля в Python?",
          "options": [
            "Поле недоступно извне (name mangling)",
            "Поле используется только внутри класса (соглашение)",
            "Поле является публичным",
            "Поле является защищенным"
          ],
          "correctAnswer": "Поле недоступно извне (name mangling)",
          "explanation": "Двойное подчеркивание перед именем поля делает его недоступным извне благодаря механизму name mangling."
        },
        {
          "text": "Как называется механизм, который делает поля с двойным подчеркиванием недоступными извне?",
          "options": [
            "Name mangling",
            "Name decoration",
            "Name hiding",
            "Name protection"
          ],
          "correctAnswer": "Name mangling",
          "explanation": "Механизм, который делает поля с двойным подчеркиванием недоступными извне, называется name mangling."
        },
        {
          "text": "Чем отличается __new__ от __init__?",
          "options": [
            "__new__ создает объект, __init__ инициализирует его",
            "__new__ инициализирует объект, __init__ создает его",
            "__new__ и __init__ выполняют одинаковые функции",
            "__new__ вызывается после __init__"
          ],
          "correctAnswer": "__new__ создает объект, __init__ инициализирует его",
          "explanation": "__new__ отвечает за создание объекта, а __init__ — за его инициализацию."
        },
        {
          "text": "В какой последовательности вызываются __new__ и __init__?",
          "options": [
            "Сначала __new__, затем __init__",
            "Сначала __init__, затем __new__",
            "Они вызываются одновременно",
            "Порядок вызова зависит от реализации"
          ],
          "correctAnswer": "Сначала __new__, затем __init__",
          "explanation": "Сначала вызывается __new__ для создания объекта, а затем __init__ для его инициализации."
        },
        {
          "text": "Чем отличаются old-style и new-style классы в Python?",
          "options": [
            "New-style классы наследуют от object и имеют другой порядок поиска методов",
            "Old-style классы наследуют от object и имеют другой порядок поиска методов",
            "New-style классы доступны только в Python 2.x",
            "Old-style классы доступны только в Python 3.x"
          ],
          "correctAnswer": "New-style классы наследуют от object и имеют другой порядок поиска методов",
          "explanation": "New-style классы наследуют от object и имеют другой порядок поиска методов (MRO), в отличие от old-style классов."
        },
        {
          "text": "Какой порядок поиска методов используется в new-style классах?",
          "options": [
            "C3-линеаризация",
            "Обход в глубину (DFLR)",
            "Обход в ширину (BFS)",
            "Случайный порядок"
          ],
          "correctAnswer": "C3-линеаризация",
          "explanation": "В new-style классах используется порядок поиска методов C3-линеаризация."
        },
        {
          "text": "От какого класса наследуют все new-style классы?",
          "options": [
            "object",
            "type",
            "class",
            "base"
          ],
          "correctAnswer": "object",
          "explanation": "Все new-style классы наследуют от встроенного класса object."
        },
        {
          "text": "Что такое утиная типизация?",
          "options": [
            "Типизация, при которой объект определяется его методами и свойствами, а не классом",
            "Типизация, основанная на строгом наследовании классов",
            "Типизация, которая требует явного указания интерфейсов",
            "Типизация, которая используется только в статически типизированных языках"
          ],
          "correctAnswer": "Типизация, при которой объект определяется его методами и свойствами, а не классом",
          "explanation": "Утиная типизация — это вид динамической типизации, при которой объект определяется его текущим набором методов и свойств, а не его классом или наследованием."
        },
        {
          "text": "Какие проблемы решает утиная типизация?",
          "options": [
            "Проблемы иерархической типизации, такие как экспоненциальный рост связей",
            "Проблемы с производительностью в статически типизированных языках",
            "Проблемы с наследованием интерфейсов",
            "Проблемы с определением типов в динамически типизированных языках"
          ],
          "correctAnswer": "Проблемы иерархической типизации, такие как экспоненциальный рост связей",
          "explanation": "Утиная типизация решает проблемы иерархической типизации, такие как невозможность явно указать совместимость интерфейсов и экспоненциальный рост связей в иерархии типов."
        },
        {
          "text": "Что такое модуль в Python?",
          "options": [
            "Функционально законченный фрагмент программы, оформленный в виде отдельного файла",
            "Часть программы, которая выполняет одну функцию",
            "Набор функций, объединенных в один файл",
            "Библиотека, содержащая несколько файлов"
          ],
          "correctAnswer": "Функционально законченный фрагмент программы, оформленный в виде отдельного файла",
          "explanation": "Модуль — это функционально законченный фрагмент программы, оформленный в виде отдельного файла с исходным кодом."
        },
        {
          "text": "Как модули могут быть организованы в Python?",
          "options": [
            "Модули могут объединяться в пакеты и библиотеки",
            "Модули могут объединяться только в библиотеки",
            "Модули не могут объединяться в пакеты",
            "Модули могут объединяться только в пакеты"
          ],
          "correctAnswer": "Модули могут объединяться в пакеты и библиотеки",
          "explanation": "Модули могут объединяться в пакеты и, далее, в библиотеки для организации кода."
        },
        {
          "text": "Как можно получить имя модуля в Python?",
          "options": [
            "Использовать переменную __name__",
            "Использовать функцию module_name()",
            "Использовать атрибут __module__",
            "Использовать функцию get_module_name()"
          ],
          "correctAnswer": "Использовать переменную __name__",
          "explanation": "Имя модуля доступно в его глобальной переменной __name__."
        },
        {
          "text": "Какое значение имеет __name__, если модуль запущен как скрипт?",
          "options": [
            "__main__",
            "module",
            "script",
            "None"
          ],
          "correctAnswer": "__main__",
          "explanation": "Если модуль запущен как скрипт, то переменная __name__ устанавливается в значение '__main__'."
        },
        {
          "text": "Что такое модульное программирование?",
          "options": [
            "Организация программы как совокупности независимых модулей",
            "Программирование с использованием только одного модуля",
            "Программирование, ориентированное на аппаратные зависимости",
            "Программирование без использования модулей"
          ],
          "correctAnswer": "Организация программы как совокупности независимых модулей",
          "explanation": "Модульное программирование — это организация программы как совокупности небольших независимых блоков, называемых модулями."
        },
        {
          "text": "Какие преимущества дает модульное программирование?",
          "options": [
            "Упрощение тестирования и обнаружения ошибок",
            "Увеличение сложности программы",
            "Снижение мобильности программы",
            "Увеличение аппаратной зависимости"
          ],
          "correctAnswer": "Упрощение тестирования и обнаружения ошибок",
          "explanation": "Модульное программирование упрощает тестирование программы и обнаружение ошибок, а также улучшает мобильность создаваемых программ."
        },
        {
          "text": "Как Python ищет модули при импорте?",
          "options": [
            "Используя список директорий в переменной sys.path",
            "Используя только текущую директорию",
            "Используя только переменную окружения PYTHONPATH",
            "Используя только стандартное расположение модулей"
          ],
          "correctAnswer": "Используя список директорий в переменной sys.path",
          "explanation": "Python ищет модули при импорте, используя список директорий и архивов, доступных в переменной sys.path."
        },
        {
          "text": "Что входит в sys.path по умолчанию?",
          "options": [
            "Директория с запускаемым скриптом, PYTHONPATH и стандартное расположение модулей",
            "Только директория с запускаемым скриптом",
            "Только переменная окружения PYTHONPATH",
            "Только стандартное расположение модулей"
          ],
          "correctAnswer": "Директория с запускаемым скриптом, PYTHONPATH и стандартное расположение модулей",
          "explanation": "По умолчанию sys.path состоит из директории с запускаемым скриптом, содержимого переменной окружения PYTHONPATH и стандартного расположения модулей."
        },
        {
          "text": "Что такое пакет в Python?",
          "options": [
            "Пространство имен для модулей и способ их структурирования",
            "Отдельный файл с исходным кодом",
            "Набор функций, объединенных в один файл",
            "Библиотека, содержащая несколько файлов"
          ],
          "correctAnswer": "Пространство имен для модулей и способ их структурирования",
          "explanation": "Пакет — это пространство имен для модулей и способ их структурирования, обычно представленный в виде каталога в файловой системе."
        },
        {
          "text": "Какой файл должен находиться в каталоге, чтобы он считался пакетом?",
          "options": [
            "__init__.py",
            "__main__.py",
            "__package__.py",
            "__module__.py"
          ],
          "correctAnswer": "__init__.py",
          "explanation": "Для того чтобы каталог считался пакетом, в нем должен находиться файл __init__.py."
        },
        {
          "text": "Что происходит при импортировании пакета?",
          "options": [
            "Выполняется файл __init__.py",
            "Выполняется файл __main__.py",
            "Выполняется файл __package__.py",
            "Ничего не происходит"
          ],
          "correctAnswer": "Выполняется файл __init__.py",
          "explanation": "При импортировании пакета автоматически выполняется файл __init__.py, который может содержать код инициализации."
        },
        {
          "text": "Что можно импортировать с помощью конструкции import package.item?",
          "options": [
            "Модуль или пакет",
            "Любое имя, описанное в пакете",
            "Только модуль",
            "Только пакет"
          ],
          "correctAnswer": "Модуль или пакет",
          "explanation": "При использовании конструкции import package.item, item должен быть модулем или пакетом."
        },
        {
          "text": "Что можно импортировать с помощью конструкции from package import item?",
          "options": [
            "Пакет, модуль или любое имя, описанное в пакете",
            "Только модуль",
            "Только пакет",
            "Только функции"
          ],
          "correctAnswer": "Пакет, модуль или любое имя, описанное в пакете",
          "explanation": "При использовании конструкции from package import item, item может быть пакетом, модулем или любым именем, описанным в пакете."
        },
        {
          "text": "Что такое обработка исключений?",
          "options": [
            "Механизм для описания реакции программы на ошибки времени выполнения",
            "Механизм для предотвращения ошибок в коде",
            "Механизм для оптимизации производительности программы",
            "Механизм для логирования ошибок"
          ],
          "correctAnswer": "Механизм для описания реакции программы на ошибки времени выполнения",
          "explanation": "Обработка исключений — это механизм, предназначенный для описания реакции программы на ошибки времени выполнения и другие возможные проблемы."
        },
        {
          "text": "Как можно сгенерировать исключение в Python?",
          "options": [
            "Использовать ключевое слово raise",
            "Использовать ключевое слово throw",
            "Использовать ключевое слово except",
            "Использовать ключевое слово catch"
          ],
          "correctAnswer": "Использовать ключевое слово raise",
          "explanation": "Исключение в Python можно сгенерировать с помощью ключевого слова raise."
        },
        {
          "text": "Какие объекты можно выбрасывать в качестве исключений?",
          "options": [
            "Экземпляры класса BaseException и его наследников",
            "Любые объекты",
            "Только строки",
            "Только числа"
          ],
          "correctAnswer": "Экземпляры класса BaseException и его наследников",
          "explanation": "В качестве исключений можно выбрасывать только экземпляры класса BaseException и его наследников."
        },
        {
          "text": "Для чего может использоваться конструкция try-finally без except?",
          "options": [
            "Для выполнения cleanup-кода, даже если в try произошла ошибка",
            "Для обработки исключений",
            "Для предотвращения ошибок",
            "Для логирования ошибок"
          ],
          "correctAnswer": "Для выполнения cleanup-кода, даже если в try произошла ошибка",
          "explanation": "Конструкция try-finally без except используется для выполнения cleanup-кода, даже если в блоке try произошла ошибка."
        },
        {
          "text": "Как правильно по-разному обрабатывать исключения в Python?",
          "options": [
            "Сначала указывать обработчики менее общих исключений, затем более общих",
            "Сначала указывать обработчики более общих исключений, затем менее общих",
            "Указывать обработчики в произвольном порядке",
            "Использовать только один обработчик для всех исключений"
          ],
          "correctAnswer": "Сначала указывать обработчики менее общих исключений, затем более общих",
          "explanation": "Блоки except обрабатываются сверху вниз, поэтому сначала нужно указывать обработчики менее общих исключений, а затем — более общих."
        },
        {
          "text": "Почему bare except должен быть последним?",
          "options": [
            "Иначе будет SyntaxError",
            "Иначе он перехватит все исключения",
            "Иначе он будет проигнорирован",
            "Иначе он вызовет ошибку времени выполнения"
          ],
          "correctAnswer": "Иначе будет SyntaxError",
          "explanation": "Bare except должен быть последним, иначе возникнет SyntaxError."
        },
        {
          "text": "Что произойдет, если ошибка не будет обработана блоком except?",
          "options": [
            "Исключение будет перехвачено внешним блоком try/except или завершит программу",
            "Программа продолжит выполнение без обработки ошибки",
            "Исключение будет проигнорировано",
            "Программа завершится с ошибкой SyntaxError"
          ],
          "correctAnswer": "Исключение будет перехвачено внешним блоком try/except или завершит программу",
          "explanation": "Если ни один из блоков except не перехватывает исключение, оно будет перехвачено внешним блоком try/except или завершит выполнение программы."
        },
        {
          "text": "Что происходит, если исключение возникает в деструкторе объекта?",
          "options": [
            "Программа не завершается, выводится предупреждение 'Exception ignored'",
            "Программа завершается с выводом информации об исключении",
            "Исключение игнорируется без вывода предупреждения",
            "Программа завершается с ошибкой SyntaxError"
          ],
          "correctAnswer": "Программа не завершается, выводится предупреждение 'Exception ignored'",
          "explanation": "Если исключение возникает в деструкторе объекта, программа не завершается, а выводится предупреждение 'Exception ignored'."
        },
        {
          "text": "Что происходит при возникновении исключения SystemExit?",
          "options": [
            "Программа завершается без вывода информации об исключении",
            "Программа завершается с выводом информации об исключении",
            "Программа продолжает выполнение",
            "Программа завершается с ошибкой SyntaxError"
          ],
          "correctAnswer": "Программа завершается без вывода информации об исключении",
          "explanation": "При возникновении исключения SystemExit программа завершается без вывода информации об исключении."
        },
        {
          "text": "Как перехватить исключение, выполнить действия и снова возбудить его?",
          "options": [
            "Использовать raise без параметров",
            "Использовать raise с указанием исключения",
            "Использовать throw",
            "Использовать except без raise"
          ],
          "correctAnswer": "Использовать raise без параметров",
          "explanation": "Для повторного возбуждения того же исключения после выполнения действий в обработчике используется ключевое слово raise без параметров."
        },
        {
          "text": "Что такое сцепление исключений в Python?",
          "options": [
            "Механизм, связывающий исключения в цепочку",
            "Механизм для подавления исключений",
            "Механизм для замены исключений",
            "Механизм для логирования исключений"
          ],
          "correctAnswer": "Механизм, связывающий исключения в цепочку",
          "explanation": "Сцепление исключений — это механизм, который связывает исключения в цепочку, сохраняя информацию о предыдущих исключениях."
        },
        {
          "text": "Какой атрибут сохраняет старое исключение при сцеплении?",
          "options": [
            "__context__",
            "__cause__",
            "__suppress_context__",
            "__exception__"
          ],
          "correctAnswer": "__context__",
          "explanation": "Старое исключение сохраняется в атрибуте __context__ при сцеплении исключений."
        },
        {
          "text": "Как можно явно указать причину нового исключения?",
          "options": [
            "Использовать raise новое_исключение from старое_исключение",
            "Использовать raise новое_исключение from None",
            "Использовать raise без параметров",
            "Использовать except без raise"
          ],
          "correctAnswer": "Использовать raise новое_исключение from старое_исключение",
          "explanation": "Для явного указания причины нового исключения используется конструкция raise новое_исключение from старое_исключение."
        },
        {
          "text": "Для чего используется блок else в конструкции try/except?",
          "options": [
            "Для выполнения кода, если в блоке try не возникло исключений",
            "Для обработки исключений",
            "Для выполнения кода, если в блоке try возникло исключение",
            "Для завершения программы"
          ],
          "correctAnswer": "Для выполнения кода, если в блоке try не возникло исключений",
          "explanation": "Блок else выполняется, если в процессе выполнения блока try не возникло исключений."
        },
        {
          "text": "Что можно передать в конструктор исключения?",
          "options": [
            "Любые неименованные аргументы",
            "Только строки",
            "Только числа",
            "Только именованные аргументы"
          ],
          "correctAnswer": "Любые неименованные аргументы",
          "explanation": "Исключения могут принимать в качестве параметра конструктора любые неименованные аргументы."
        },
        {
          "text": "Где хранятся аргументы, переданные в конструктор исключения?",
          "options": [
            "В атрибуте args",
            "В атрибуте message",
            "В атрибуте __str__",
            "В атрибуте __cause__"
          ],
          "correctAnswer": "В атрибуте args",
          "explanation": "Аргументы, переданные в конструктор исключения, хранятся в атрибуте args в виде кортежа."
        },
        {
          "text": "Какой метод используется для строкового представления исключения?",
          "options": [
            "__str__",
            "__repr__",
            "__format__",
            "__init__"
          ],
          "correctAnswer": "__str__",
          "explanation": "Метод __str__ используется для строкового представления исключения и по умолчанию вызывает str(self.args)."
        },
        {
          "text": "Какой класс является базовым для всех исключений в Python?",
          "options": [
            "BaseException",
            "Exception",
            "StandardError",
            "ArithmeticError"
          ],
          "correctAnswer": "BaseException",
          "explanation": "BaseException — это базовый класс для всех исключений в Python."
        },
        {
          "text": "Какой класс является базовым для всех стандартных исключений, кроме тех, что указывают на завершение программы?",
          "options": [
            "Exception",
            "BaseException",
            "StandardError",
            "RuntimeError"
          ],
          "correctAnswer": "Exception",
          "explanation": "Exception — это базовый класс для всех стандартных исключений, которые не указывают на обязательное завершение программы."
        },
        {
          "text": "Какое исключение возникает при делении на ноль?",
          "options": [
            "ZeroDivisionError",
            "ArithmeticError",
            "FloatingPointError",
            "ValueError"
          ],
          "correctAnswer": "ZeroDivisionError",
          "explanation": "ZeroDivisionError возникает при попытке деления на ноль."
        },
        {
          "text": "Какое исключение возникает при неверном индексе последовательности?",
          "options": [
            "IndexError",
            "KeyError",
            "LookupError",
            "ValueError"
          ],
          "correctAnswer": "IndexError",
          "explanation": "IndexError возникает при попытке доступа к неверному индексу последовательности, например, списка."
        },
        {
          "text": "Какое исключение возникает при ошибке синтаксиса?",
          "options": [
            "SyntaxError",
            "IndentationError",
            "TabError",
            "TypeError"
          ],
          "correctAnswer": "SyntaxError",
          "explanation": "SyntaxError возникает при ошибке синтаксиса в коде."
        },
        {
          "text": "В каких случаях можно обработать SyntaxError?",
          "options": [
            "Ошибка синтаксиса в импортируемом модуле или в коде, переданном в eval/exec",
            "Ошибка синтаксиса в главном модуле",
            "Ошибка синтаксиса в любом месте программы",
            "Ошибка синтаксиса в блоке try/except"
          ],
          "correctAnswer": "Ошибка синтаксиса в импортируемом модуле или в коде, переданном в eval/exec",
          "explanation": "SyntaxError можно обработать, если он возникает в импортируемом модуле или в коде, переданном в функции eval или exec."
        },
        {
          "text": "Можно ли создавать собственные исключения в Python?",
          "options": [
            "Да, они должны наследовать от класса Exception",
            "Да, они должны наследовать от класса BaseException",
            "Нет, это невозможно",
            "Да, но только от класса StandardError"
          ],
          "correctAnswer": "Да, они должны наследовать от класса Exception",
          "explanation": "Собственные исключения можно создавать, и они должны наследовать от класса Exception."
        },
        {
          "text": "Как принято называть классы пользовательских исключений?",
          "options": [
            "Имя класса должно заканчиваться на Error",
            "Имя класса должно заканчиваться на Exception",
            "Имя класса должно начинаться с Error",
            "Имя класса должно начинаться с Exception"
          ],
          "correctAnswer": "Имя класса должно заканчиваться на Error",
          "explanation": "Принято называть пользовательские исключения так, чтобы имя их класса заканчивалось на Error."
        },
        {
          "text": "Для чего используются предупреждения (warnings) в Python?",
          "options": [
            "Для уведомления о ситуациях, когда программа может продолжать работу, но пользователя нужно предупредить",
            "Для завершения программы с ошибкой",
            "Для логирования ошибок",
            "Для предотвращения ошибок"
          ],
          "correctAnswer": "Для уведомления о ситуациях, когда программа может продолжать работу, но пользователя нужно предупредить",
          "explanation": "Предупреждения используются для уведомления о ситуациях, когда программа может продолжать работу, но пользователя нужно предупредить."
        },
        {
          "text": "Какой класс является базовым для предупреждений?",
          "options": [
            "Warning",
            "Exception",
            "UserWarning",
            "BaseException"
          ],
          "correctAnswer": "Warning",
          "explanation": "Базовым классом для предупреждений является Warning, который наследуется от Exception."
        },
        {
          "text": "Какой класс используется для создания пользовательских предупреждений?",
          "options": [
            "UserWarning",
            "Warning",
            "Exception",
            "BaseException"
          ],
          "correctAnswer": "UserWarning",
          "explanation": "Базовым классом-наследником Warning для пользовательских предупреждений является UserWarning."
        },
        {
          "text": "Для чего используется модуль warnings в Python?",
          "options": [
            "Для работы с предупреждениями",
            "Для обработки исключений",
            "Для логирования ошибок",
            "Для завершения программы"
          ],
          "correctAnswer": "Для работы с предупреждениями",
          "explanation": "Модуль warnings содержит функции для работы с предупреждениями."
        },
        {
          "text": "Какая основная функция используется для вывода предупреждений?",
          "options": [
            "warn",
            "warning",
            "alert",
            "notify"
          ],
          "correctAnswer": "warn",
          "explanation": "Основная функция для вывода предупреждений — это warn."
        },
        {
          "text": "Что можно передать в функцию warn в качестве сообщения?",
          "options": [
            "Строку или экземпляр класса Warning",
            "Только строку",
            "Только экземпляр класса Warning",
            "Любой объект"
          ],
          "correctAnswer": "Строку или экземпляр класса Warning",
          "explanation": "Функция warn принимает строку-сообщение или экземпляр класса Warning в качестве сообщения."
        },
        {
          "text": "Что такое декоратор в Python?",
          "options": [
            "Функция, которая принимает другую функцию и возвращает новую функцию",
            "Функция, которая изменяет код другой функции",
            "Функция, которая удаляет функциональность другой функции",
            "Функция, которая заменяет другую функцию"
          ],
          "correctAnswer": "Функция, которая принимает другую функцию и возвращает новую функцию",
          "explanation": "Декоратор — это функция, которая принимает другую функцию и возвращает новую функцию, изменяя её поведение."
        },
        {
          "text": "Что значит задекорировать функцию?",
          "options": [
            "Заменить её на результат работы декоратора",
            "Изменить её исходный код",
            "Удалить её функциональность",
            "Заменить её на другую функцию"
          ],
          "correctAnswer": "Заменить её на результат работы декоратора",
          "explanation": "Задекорировать функцию значит заменить её на результат работы декоратора."
        },
        {
          "text": "Что может быть декоратором в Python?",
          "options": [
            "Любой вызываемый объект: функция, лямбда, класс, экземпляр класса",
            "Только функция",
            "Только класс",
            "Только лямбда"
          ],
          "correctAnswer": "Любой вызываемый объект: функция, лямбда, класс, экземпляр класса",
          "explanation": "Декоратором может быть любой вызываемый объект: функция, лямбда, класс или экземпляр класса."
        },
        {
          "text": "К чему может быть применен декоратор?",
          "options": [
            "К любому объекту, чаще к функциям, методам и классам",
            "Только к функциям",
            "Только к классам",
            "Только к методам"
          ],
          "correctAnswer": "К любому объекту, чаще к функциям, методам и классам",
          "explanation": "Декоратор может быть применен к любому объекту, но чаще всего используется для функций, методов и классов."
        },
        {
          "text": "Какой оператор используется для применения декоратора?",
          "options": [
            "@",
            "#",
            "$",
            "&"
          ],
          "correctAnswer": "@",
          "explanation": "Для применения декоратора используется оператор @."
        },
        {
          "text": "Что произойдет, если декоратор не возвращает ничего?",
          "options": [
            "Функция станет None и вызов приведет к ошибке 'NoneType is not callable'",
            "Функция продолжит работать как обычно",
            "Декоратор вызовет исключение",
            "Ничего не произойдет"
          ],
          "correctAnswer": "Функция станет None и вызов приведет к ошибке 'NoneType is not callable'",
          "explanation": "Если декоратор не возвращает ничего, функция станет None, и при попытке ее вызвать возникнет ошибка 'NoneType is not callable'."
        },
        {
          "text": "В чем отличие @foobar от @foobar()?",
          "options": [
            "@foobar - обычное декорирование, @foobar() - декорирование с вызовом функции",
            "@foobar - декорирование с вызовом функции, @foobar() - обычное декорирование",
            "Оба варианта эквивалентны",
            "Никакого отличия нет"
          ],
          "correctAnswer": "@foobar - обычное декорирование, @foobar() - декорирование с вызовом функции",
          "explanation": "Первое — это обычное декорирование функцией foobar, второе — декорирование функцией, которую вернет вызов foobar (параметрический декоратор)."
        },
        {
          "text": "Что такое фабрика декораторов?",
          "options": [
            "Функция, которая возвращает декоратор",
            "Функция, которая изменяет поведение другой функции",
            "Функция, которая удаляет функциональность другой функции",
            "Функция, которая создает новую функцию"
          ],
          "correctAnswer": "Функция, которая возвращает декоратор",
          "explanation": "Фабрика декораторов — это функция, которая возвращает декоратор, позволяя создавать декораторы с параметрами."
        },
        {
          "text": "Для чего используется фабрика декораторов?",
          "options": [
            "Чтобы избежать дублирования кода при создании декораторов с одинаковой логикой",
            "Чтобы создать декоратор без параметров",
            "Чтобы изменить поведение встроенных функций",
            "Чтобы создать новый тип данных"
          ],
          "correctAnswer": "Чтобы избежать дублирования кода при создании декораторов с одинаковой логикой",
          "explanation": "Фабрика декораторов используется для создания декораторов с одинаковой логикой, чтобы избежать дублирования кода."
        },
        {
          "text": "Зачем нужен декоратор wraps?",
          "options": [
            "Чтобы сохранить метаданные оригинальной функции после декорирования",
            "Чтобы изменить поведение функции",
            "Чтобы удалить метаданные оригинальной функции",
            "Чтобы создать новую функцию"
          ],
          "correctAnswer": "Чтобы сохранить метаданные оригинальной функции после декорирования",
          "explanation": "wraps — это декоратор, который сохраняет поля __name__, __module__, __doc__ оригинальной функции, чтобы функция-враппер выглядела как декорируемая функция."
        },
        {
          "text": "Что такое метаклассы в Python?",
          "options": [
            "Метакласс — это класс, который создает другие классы",
            "Метакласс — это объект, который создает экземпляры",
            "Метакласс — это функция, которая создает классы",
            "Метакласс — это специальный тип данных"
          ],
          "correctAnswer": "Метакласс — это класс, который создает другие классы",
          "explanation": "Метакласс — это «штука», которая создает классы. Мы создаем класс для создания объектов, а метакласс создает эти классы."
        },
        {
          "text": "Что такое type в Python?",
          "options": [
            "Метакласс, который используется для создания всех классов",
            "Класс, который создает экземпляры",
            "Функция для создания классов",
            "Специальный тип данных"
          ],
          "correctAnswer": "Метакласс, который используется для создания всех классов",
          "explanation": "type — это метакласс, который Python внутренне использует для создания всех классов."
        },
        {
          "text": "Как работает поиск метакласса при создании объекта?",
          "options": [
            "Python ищет __metaclass__ в классе, родителях и модуле, и если не находит, использует type",
            "Python всегда использует type, независимо от __metaclass__",
            "Python создает класс без метакласса",
            "Python игнорирует __metaclass__ и создает класс автоматически"
          ],
          "correctAnswer": "Python ищет __metaclass__ в классе, родителях и модуле, и если не находит, использует type",
          "explanation": "При создании класса Python ищет __metaclass__ в классе, родителях и модуле, и если не находит, использует type для создания объекта-класса."
        },
        {
          "text": "Как работают метаклассы в Python?",
          "options": [
            "Перехватывают создание класса, изменяют его и возвращают модифицированный",
            "Создают экземпляры классов",
            "Определяют поведение объектов",
            "Не влияют на создание классов"
          ],
          "correctAnswer": "Перехватывают создание класса, изменяют его и возвращают модифицированный",
          "explanation": "Метаклассы перехватывают создание класса, могут изменить его и вернуть модифицированный класс."
        },
        {
          "text": "Зачем используются метаклассы в Python?",
          "options": [
            "Для создания API, упрощая сложные операции",
            "Для создания экземпляров классов",
            "Для обработки исключений",
            "Для управления памятью"
          ],
          "correctAnswer": "Для создания API, упрощая сложные операции",
          "explanation": "Основное применение метаклассов — это создание API, как в Django ORM, позволяя скрыть сложные операции за простым интерфейсом."
        },
        {
          "text": "Как метаклассы помогают в Django ORM?",
          "options": [
            "Они превращают простые классы в сложные привязки к базе данных",
            "Они создают экземпляры моделей",
            "Они обрабатывают запросы к базе данных",
            "Они управляют сессиями пользователей"
          ],
          "correctAnswer": "Они превращают простые классы в сложные привязки к базе данных",
          "explanation": "Метаклассы в Django ORM позволяют превращать простые классы в сложные привязки к базе данных, скрывая сложность за простым API."
        },
        {
          "text": "Что такое файловый объект в Python?",
          "options": [
            "Объект, предоставляющий файл-ориентированный API для доступа к ресурсам",
            "Объект, который хранит данные в памяти",
            "Объект, который управляет потоками данных",
            "Объект, который используется только для чтения файлов"
          ],
          "correctAnswer": "Объект, предоставляющий файл-ориентированный API для доступа к ресурсам",
          "explanation": "Файловый объект — это объект, предоставляющий файл-ориентированный API (методы read(), write() и т.д.) для доступа к ресурсу."
        },
        {
          "text": "Что могут представлять файловые объекты?",
          "options": [
            "Реальный файл на диске или другие устройства хранения",
            "Только файлы на диске",
            "Только буферы в памяти",
            "Только сокеты"
          ],
          "correctAnswer": "Реальный файл на диске или другие устройства хранения",
          "explanation": "Файловые объекты могут предоставлять доступ как к реальным файлам на диске, так и к другим видам устройств хранения или передачи данных."
        },
        {
          "text": "Как файловые объекты могут быть использованы в Python?",
          "options": [
            "Как контекстные менеджеры",
            "Только для чтения",
            "Только для записи",
            "Только для работы с текстовыми файлами"
          ],
          "correctAnswer": "Как контекстные менеджеры",
          "explanation": "Файловые объекты являются контекстными менеджерами, что позволяет использовать их с оператором with."
        },
        {
          "text": "Какие виды файловых объектов существуют в Python 3?",
          "options": [
            "Текстовые файлы, небуферизированные бинарные файлы и буферизированные бинарные файлы",
            "Только текстовые файлы",
            "Только бинарные файлы",
            "Текстовые и бинарные файлы без различий"
          ],
          "correctAnswer": "Текстовые файлы, небуферизированные бинарные файлы и буферизированные бинарные файлы",
          "explanation": "В Python 3 существуют три вида файловых объектов: текстовые файлы, небуферизированные бинарные файлы и буферизированные бинарные файлы."
        },
        {
          "text": "Какой модуль в Python 3 отвечает за работу с файловыми объектами?",
          "options": [
            "io",
            "file",
            "os",
            "sys"
          ],
          "correctAnswer": "io",
          "explanation": "Модуль io в Python 3 отвечает за работу с файловыми объектами и предоставляет соответствующие классы."
        },
        {
          "text": "Какое отличие между текстовыми и бинарными файлами в Python 2?",
          "options": [
            "На уровне типов данных нет отличия, только режим открытия влияет на преобразования концов строк",
            "Текстовые файлы всегда читаются как строки",
            "Бинарные файлы не могут быть открыты в текстовом режиме",
            "Текстовые файлы не могут содержать бинарные данные"
          ],
          "correctAnswer": "На уровне типов данных нет отличия, только режим открытия влияет на преобразования концов строк",
          "explanation": "В Python 2 нет отличия между текстовыми и бинарными файлами на уровне типов данных, режим открытия влияет только на преобразования концов строк."
        },
        {
          "text": "В чем отличие текстовых и бинарных файлов в Python?",
          "options": [
            "Текстовые файлы работают с str и выполняют преобразования, бинарные — с bytes и bytearray без изменений",
            "Текстовые файлы всегда содержат текст, бинарные — только числа",
            "Бинарные файлы не могут содержать текстовые данные",
            "Текстовые файлы не могут быть открыты в бинарном режиме"
          ],
          "correctAnswer": "Текстовые файлы работают с str и выполняют преобразования, бинарные — с bytes и bytearray без изменений",
          "explanation": "Текстовые файлы записывают и считывают данные типа str с преобразованиями, а бинарные файлы работают с bytes и bytearray без изменений."
        },
        {
          "text": "Какова сигнатура функции open в Python 3?",
          "options": [
            "open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)",
            "open(file, mode='r', buffering=-1)",
            "open(file, mode='r', encoding=None)",
            "open(file, mode='r', buffering=-1, encoding=None)"
          ],
          "correctAnswer": "open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)",
          "explanation": "Сигнатура функции open в Python 3 включает дополнительные параметры для кодировки, обработки ошибок и других настроек."
        },
        {
          "text": "Какой параметр является обязательным при использовании функции open?",
          "options": [
            "file",
            "mode",
            "encoding",
            "buffering"
          ],
          "correctAnswer": "file",
          "explanation": "Обязательным параметром при использовании функции open является только параметр file."
        },
        {
          "text": "Что означает режим 'w' при открытии файла?",
          "options": [
            "Запись, очищает файл, если уже существует",
            "Чтение файла",
            "Добавление данных в конец файла",
            "Исключительное создание файла"
          ],
          "correctAnswer": "Запись, очищает файл, если уже существует",
          "explanation": "Режим 'w' означает запись в файл и очищает его, если файл уже существует."
        },
        {
          "text": "Какой символ указывает на бинарный режим при открытии файла?",
          "options": [
            "b",
            "t",
            "r",
            "w"
          ],
          "correctAnswer": "b",
          "explanation": "Символ 'b' указывает на бинарный режим при открытии файла."
        },
        {
          "text": "Почему необходимо закрывать файлы в Python?",
          "options": [
            "Чтобы записать данные из буфера в файл и освободить ресурсы",
            "Чтобы предотвратить ошибки при чтении",
            "Чтобы избежать блокировки файла для других процессов",
            "Чтобы удалить файл"
          ],
          "correctAnswer": "Чтобы записать данные из буфера в файл и освободить ресурсы",
          "explanation": "Закрытие файла необходимо для записи данных из буфера в файл и освобождения ресурсов."
        },
        {
          "text": "Что происходит с данными, если файл не закрыть?",
          "options": [
            "Данные могут не записаться в файл",
            "Файл будет автоматически закрыт",
            "Данные будут потеряны",
            "Файл будет заблокирован для других процессов"
          ],
          "correctAnswer": "Данные могут не записаться в файл",
          "explanation": "Если файл не закрыть, данные, записанные в буфер, могут не попасть в файл."
        },
        {
          "text": "Какой метод используется для закрытия файла?",
          "options": [
            "close()",
            "flush()",
            "end()",
            "stop()"
          ],
          "correctAnswer": "close()",
          "explanation": "Метод close() используется для закрытия файла."
        },
        {
          "text": "Что происходит с открытыми файлами при завершении работы интерпретатора?",
          "options": [
            "Все открытые файлы автоматически закрываются",
            "Открытые файлы остаются открытыми",
            "Файлы закрываются только при вызове close()",
            "Файлы удаляются"
          ],
          "correctAnswer": "Все открытые файлы автоматически закрываются",
          "explanation": "Все открытые файлы автоматически закрываются при завершении работы интерпретатора."
        },
        {
          "text": "Что делает метод tell() в Python?",
          "options": [
            "Возвращает текущую позицию считывания/записи в файле",
            "Устанавливает позицию считывания/записи в файле",
            "Закрывает файл",
            "Открывает файл"
          ],
          "correctAnswer": "Возвращает текущую позицию считывания/записи в файле",
          "explanation": "Метод tell() возвращает текущую позицию считывания/записи в файле."
        },
        {
          "text": "Какой метод используется для установки позиции считывания/записи в файле?",
          "options": [
            "seek()",
            "tell()",
            "set_position()",
            "move()"
          ],
          "correctAnswer": "seek()",
          "explanation": "Метод seek(offset, whence) используется для установки позиции считывания/записи в файле."
        },
        {
          "text": "Что означает параметр whence в методе seek()?",
          "options": [
            "Точка, от которой считается отступ",
            "Размер буфера",
            "Тип файла",
            "Режим открытия файла"
          ],
          "correctAnswer": "Точка, от которой считается отступ",
          "explanation": "Параметр whence в методе seek() указывает точку, от которой считается отступ: начало файла, текущая позиция или конец файла."
        },
        {
          "text": "Какие значения может принимать whence в методе seek()?",
          "options": [
            "io.SEEK_SET, io.SEEK_CUR, io.SEEK_END",
            "0, 1, 2",
            "start, current, end",
            "begin, now, finish"
          ],
          "correctAnswer": "io.SEEK_SET, io.SEEK_CUR, io.SEEK_END",
          "explanation": "Параметр whence может принимать значения io.SEEK_SET (0), io.SEEK_CUR (1) и io.SEEK_END (2)."
        },
        {
          "text": "Что делают классы StringIO и BytesIO в Python?",
          "options": [
            "Представляют собой потоки для работы со строками и байтовыми строками в памяти",
            "Используются для работы с файлами на диске",
            "Представляют собой потоки для работы только с текстовыми файлами",
            "Используются для работы только с бинарными файлами"
          ],
          "correctAnswer": "Представляют собой потоки для работы со строками и байтовыми строками в памяти",
          "explanation": "Классы io.StringIO и io.BytesIO представляют собой потоки для считывания и записи в строки или байтовые строки в памяти."
        },
        {
          "text": "Для чего можно использовать StringIO и BytesIO?",
          "options": [
            "Чтобы использовать строки и байтовые строки в качестве текстовых и бинарных файлов",
            "Чтобы работать только с текстовыми файлами",
            "Чтобы работать только с бинарными файлами",
            "Чтобы сохранять данные на диск"
          ],
          "correctAnswer": "Чтобы использовать строки и байтовые строки в качестве текстовых и бинарных файлов",
          "explanation": "StringIO и BytesIO могут быть использованы для работы со строками и байтовыми строками как с текстовыми и бинарными файлами."
        },
        {
          "text": "Являются ли файловые объекты контекстными менеджерами в Python?",
          "options": [
            "Да, являются",
            "Нет, не являются",
            "Только текстовые файлы являются контекстными менеджерами",
            "Только бинарные файлы являются контекстными менеджерами"
          ],
          "correctAnswer": "Да, являются",
          "explanation": "Файловые объекты в Python являются контекстными менеджерами, что позволяет использовать их с оператором with."
        },
        {
          "text": "Что такое сериализация в Python?",
          "options": [
            "Процесс сохранения объектов в двоичном или строковом виде",
            "Процесс передачи данных по сети",
            "Процесс создания объектов из классов",
            "Процесс удаления объектов из памяти"
          ],
          "correctAnswer": "Процесс сохранения объектов в двоичном или строковом виде",
          "explanation": "Сериализация — это процесс сохранения объектов в двоичном или строковом виде для хранения, передачи и восстановления."
        },
        {
          "text": "Как называется обратный процесс сериализации?",
          "options": [
            "Десериализация",
            "Маршалинг",
            "Анмаршалинг",
            "Кодирование"
          ],
          "correctAnswer": "Десериализация",
          "explanation": "Обратный процесс сериализации называется десериализацией."
        },
        {
          "text": "Какие термины являются синонимами к сериализации?",
          "options": [
            "Маршалинг/анмаршалинг",
            "Кодирование/декодирование",
            "Сохранение/восстановление",
            "Передача/прием"
          ],
          "correctAnswer": "Маршалинг/анмаршалинг",
          "explanation": "Термины маршалинг и анмаршалинг являются синонимами к сериализации и десериализации."
        },
        {
          "text": "Что делает функция json.dumps?",
          "options": [
            "Сохраняет JSON-представление объекта в строку",
            "Сохраняет объект в текстовый файл",
            "Загружает объект из строки",
            "Загружает объект из текстового файла"
          ],
          "correctAnswer": "Сохраняет JSON-представление объекта в строку",
          "explanation": "Функция json.dumps сохраняет JSON-представление объекта в строку."
        },
        {
          "text": "Что делает функция json.dump?",
          "options": [
            "Сохраняет объект в текстовый файл",
            "Сохраняет объект в строку",
            "Загружает объект из строки",
            "Загружает объект из текстового файла"
          ],
          "correctAnswer": "Сохраняет объект в текстовый файл",
          "explanation": "Функция json.dump сохраняет JSON-представление объекта в текстовый файл."
        },
        {
          "text": "Что делает функция json.loads?",
          "options": [
            "Загружает объект из строки",
            "Загружает объект из текстового файла",
            "Сохраняет объект в строку",
            "Сохраняет объект в текстовый файл"
          ],
          "correctAnswer": "Загружает объект из строки",
          "explanation": "Функция json.loads загружает объект из строки."
        },
        {
          "text": "Что делает функция json.load?",
          "options": [
            "Загружает объект из текстового файла",
            "Загружает объект из строки",
            "Сохраняет объект в строку",
            "Сохраняет объект в текстовый файл"
          ],
          "correctAnswer": "Загружает объект из текстового файла",
          "explanation": "Функция json.load загружает объект из текстового файла."
        },
        {
          "text": "Что делать, если нужно сериализовать данные, которые не поддерживаются стандартным модулем json?",
          "options": [
            "Использовать pickle или расширить классы JSONEncoder и JSONDecoder",
            "Использовать только pickle",
            "Использовать только JSONEncoder",
            "Ничего не делать, все поддерживается"
          ],
          "correctAnswer": "Использовать pickle или расширить классы JSONEncoder и JSONDecoder",
          "explanation": "Если нужно сериализовать данные, которые не поддерживаются стандартным модулем json, можно использовать pickle или расширить классы JSONEncoder и JSONDecoder."
        },
        {
          "text": "Каковы функции модуля pickle и их аналогии в модуле JSON?",
          "options": [
            "dump, dumps, load и loads работают с байтовыми строками и бинарными файлами",
            "dump и load работают только с текстовыми файлами",
            "dumps и loads работают только с текстовыми строками",
            "pickle не имеет аналогов в JSON"
          ],
          "correctAnswer": "dump, dumps, load и loads работают с байтовыми строками и бинарными файлами",
          "explanation": "Функции dump, dumps, load и loads модуля pickle аналогичны функциям модуля JSON, но работают с байтовыми строками и бинарными файлами."
        },
        {
          "text": "Какой параметр можно задать в функциях модуля pickle?",
          "options": [
            "protocol",
            "encoding",
            "buffering",
            "mode"
          ],
          "correctAnswer": "protocol",
          "explanation": "Опциональный параметр protocol задаёт версию протокола в функциях модуля pickle."
        },
        {
          "text": "Какова последняя версия протокола в pickle?",
          "options": [
            "pickle.HIGHEST_PROTOCOL",
            "pickle.DEFAULT_PROTOCOL",
            "pickle.LOWEST_PROTOCOL",
            "pickle.CURRENT_PROTOCOL"
          ],
          "correctAnswer": "pickle.HIGHEST_PROTOCOL",
          "explanation": "Последнюю версию протокола можно получить как константу pickle.HIGHEST_PROTOCOL."
        },
        {
          "text": "Какая версия протокола была добавлена в Python 3.8?",
          "options": [
            "5",
            "4",
            "3",
            "2"
          ],
          "correctAnswer": "5",
          "explanation": "Версия протокола 5 была добавлена в Python 3.8 и добавляет поддержку данных out-of-band."
        },
        {
          "text": "Что такое пирамида тестирования?",
          "options": [
            "Модель, описывающая уровни тестирования в программном обеспечении",
            "Метод тестирования производительности",
            "Тип тестирования безопасности",
            "Стратегия управления проектами"
          ],
          "correctAnswer": "Модель, описывающая уровни тестирования в программном обеспечении",
          "explanation": "Пирамида тестирования — это модель, описывающая уровни тестирования в программном обеспечении, где больше всего тестов на нижнем уровне и меньше на верхнем."
        },
        {
          "text": "Что такое mocking в тестировании?",
          "options": [
            "Имитация объектов для тестирования функций без их реального выполнения",
            "Метод тестирования производительности",
            "Тип тестирования безопасности",
            "Стратегия управления проектами"
          ],
          "correctAnswer": "Имитация объектов для тестирования функций без их реального выполнения",
          "explanation": "Mocking — это процесс имитации объектов, позволяющий тестировать функции без выполнения их реальных зависимостей, таких как чтение с диска или из сети."
        },
        {
          "text": "Какой модуль в Python используется для mocking?",
          "options": [
            "unittest.mock",
            "mock",
            "pytest",
            "doctest"
          ],
          "correctAnswer": "unittest.mock",
          "explanation": "Модуль unittest.mock используется для создания макетов-пустышек в тестировании."
        },
        {
          "text": "Какой принцип работы mocking?",
          "options": [
            "Подмена объектов в других модулях без адаптации кода",
            "Изменение кода для тестирования",
            "Создание новых функций для тестирования",
            "Удаление зависимостей из кода"
          ],
          "correctAnswer": "Подмена объектов в других модулях без адаптации кода",
          "explanation": "Mock подменяет объекты в других модулях, позволяя тестировать функции без необходимости адаптировать код для тестов."
        },
        {
          "text": "Что делать, если тестируемая функция использует удалённое подключение к внешним сервисам?",
          "options": [
            "Замокать http-клиент или передать его как зависимость",
            "Игнорировать ошибки и продолжать тестирование",
            "Изменить код функции для тестирования",
            "Запускать тесты только в локальной среде"
          ],
          "correctAnswer": "Замокать http-клиент или передать его как зависимость",
          "explanation": "Если тестируемая функция использует удалённое подключение, нужно замокать http-клиент или передать его как зависимость, чтобы избежать вызова внешних ресурсов."
        },
        {
          "text": "Почему юнит-тесты не должны вызывать внешние ресурсы?",
          "options": [
            "Чтобы избежать зависимостей и нестабильности тестов",
            "Чтобы тесты выполнялись быстрее",
            "Чтобы избежать ошибок в коде",
            "Чтобы тесты были более читаемыми"
          ],
          "correctAnswer": "Чтобы избежать зависимостей и нестабильности тестов",
          "explanation": "Юнит-тесты не должны вызывать внешние ресурсы, чтобы избежать зависимостей и нестабильности тестов."
        },
        {
          "text": "Что делать, если тестируемая функция занимает много времени на выполнение?",
          "options": [
            "Заменить верхнюю границу цикла, замокать ресурсоёмкие функции и подготовить быстрые входные данные",
            "Игнорировать время выполнения и продолжать тестирование",
            "Разбить функцию на несколько частей",
            "Изменить логику функции"
          ],
          "correctAnswer": "Заменить верхнюю границу цикла, замокать ресурсоёмкие функции и подготовить быстрые входные данные",
          "explanation": "Если функция занимает много времени, можно заменить верхнюю границу цикла, замокать ресурсоёмкие функции и подготовить быстрые входные данные для теста."
        },
        {
          "text": "Что делать, если функция не соответствует условиям для оптимизации?",
          "options": [
            "Заняться её декомпозицией",
            "Игнорировать её",
            "Изменить её логику",
            "Уменьшить количество операций"
          ],
          "correctAnswer": "Заняться её декомпозицией",
          "explanation": "Если функция не соответствует условиям для оптимизации, следует заняться её декомпозицией."
        },
        {
          "text": "Что такое юнит-тесты?",
          "options": [
            "Тесты, проверяющие правильность работы отдельных модулей кода",
            "Тесты, проверяющие взаимодействие между модулями",
            "Тесты, проверяющие функциональность программного продукта",
            "Тесты, проверяющие производительность системы"
          ],
          "correctAnswer": "Тесты, проверяющие правильность работы отдельных модулей кода",
          "explanation": "Юнит-тесты проверяют, правильно ли работает каждый отдельный модуль (юнит) вашего кода."
        },
        {
          "text": "Что проверяют интеграционные тесты?",
          "options": [
            "Взаимодействие между двумя или более модулями вашего кода",
            "Правильность работы отдельных модулей",
            "Функциональность программного продукта",
            "Производительность системы"
          ],
          "correctAnswer": "Взаимодействие между двумя или более модулями вашего кода",
          "explanation": "Интеграционные тесты проверяют взаимодействие между двумя или более отдельными юнитами вашего кода."
        },
        {
          "text": "Какое тестирование проверяет функциональность программного продукта?",
          "options": [
            "Функциональное тестирование",
            "Юнит-тестирование",
            "Интеграционное тестирование",
            "Системное тестирование"
          ],
          "correctAnswer": "Функциональное тестирование",
          "explanation": "Функциональное тестирование проверяет функциональность программного продукта на индивидуальном уровне."
        },
        {
          "text": "Что такое регрессионное тестирование?",
          "options": [
            "Тестирование, которое пишется после обнаружения проблемы для предотвращения её повторения",
            "Тестирование производительности системы",
            "Тестирование взаимодействия между модулями",
            "Тестирование безопасности"
          ],
          "correctAnswer": "Тестирование, которое пишется после обнаружения проблемы для предотвращения её повторения",
          "explanation": "Регрессионные тесты проверяют набор сценариев, которые раньше работали и должны быть относительно стабильными."
        },
        {
          "text": "Что такое дымовое тестирование?",
          "options": [
            "Небольшие тесты, которые проверяются перед запуском системы",
            "Тесты, проверяющие производительность системы",
            "Тесты, проверяющие безопасность системы",
            "Тесты, проверяющие функциональность отдельных модулей"
          ],
          "correctAnswer": "Небольшие тесты, которые проверяются перед запуском системы",
          "explanation": "Дымовое тестирование — это частный случай интеграционного теста, который проверяет работоспособность системы перед её запуском."
        },
        {
          "text": "Чем интеграционное тестирование отличается от функционального?",
          "options": [
            "Интеграционное тестирование проверяет взаимодействие между модулями, а функциональное — функциональность системы",
            "Интеграционное тестирование — это тестирование черного ящика, а функциональное — белого ящика",
            "Интеграционное тестирование проводится до модульного, а функциональное — после",
            "Интеграционное тестирование не требует тестовых данных, а функциональное требует"
          ],
          "correctAnswer": "Интеграционное тестирование проверяет взаимодействие между модулями, а функциональное — функциональность системы",
          "explanation": "Интеграционное тестирование проверяет взаимодействие между модулями, а функциональное тестирование проверяет функциональность системы."
        },
        {
          "text": "Когда проводится интеграционное тестирование?",
          "options": [
            "После модульного тестирования",
            "Перед модульным тестированием",
            "Во время функционального тестирования",
            "После системного тестирования"
          ],
          "correctAnswer": "После модульного тестирования",
          "explanation": "Интеграционное тестирование проводится после модульного тестирования."
        },
        {
          "text": "Что такое функциональное тестирование?",
          "options": [
            "Метод тестирования черного ящика, проверяющий функциональность системы",
            "Метод тестирования белого ящика, проверяющий внутреннюю логику",
            "Тестирование производительности системы",
            "Тестирование безопасности системы"
          ],
          "correctAnswer": "Метод тестирования черного ящика, проверяющий функциональность системы",
          "explanation": "Функциональное тестирование — это метод тестирования черного ящика, который проверяет функциональность системы."
        },
        {
          "text": "Что такое функциональное программирование?",
          "options": [
            "Раздел дискретной математики и парадигма программирования, где вычисления трактуются как вычисление значений функций",
            "Метод программирования, основанный на изменении состояний",
            "Подход к программированию, использующий только циклы",
            "Стиль программирования, основанный на использовании объектов"
          ],
          "correctAnswer": "Раздел дискретной математики и парадигма программирования, где вычисления трактуются как вычисление значений функций",
          "explanation": "Функциональное программирование — это парадигма программирования, в которой процесс вычисления трактуется как вычисление значений функций."
        },
        {
          "text": "С чем противопоставляется функциональное программирование?",
          "options": [
            "Императивному программированию",
            "Объектно-ориентированному программированию",
            "Процедурному программированию",
            "Логическому программированию"
          ],
          "correctAnswer": "Императивному программированию",
          "explanation": "Функциональное программирование противопоставляется императивному программированию, которое описывает процесс вычислений как последовательное изменение состояний."
        },
        {
          "text": "Как Python поддерживает функциональное программирование?",
          "options": [
            "Частично поддерживает парадигму функционального программирования и позволяет писать код в функциональном стиле",
            "Полностью поддерживает функциональное программирование",
            "Не поддерживает функциональное программирование",
            "Поддерживает только лямбда-функции"
          ],
          "correctAnswer": "Частично поддерживает парадигму функционального программирования и позволяет писать код в функциональном стиле",
          "explanation": "Python частично поддерживает парадигму функционального программирования и позволяет писать код в функциональном стиле."
        },
        {
          "text": "Какие возможности функционального программирования присутствуют в Python?",
          "options": [
            "Списковые включения, лямбда-функции, функции высшего порядка",
            "Только лямбда-функции",
            "Только функции высшего порядка",
            "Только списковые включения"
          ],
          "correctAnswer": "Списковые включения, лямбда-функции, функции высшего порядка",
          "explanation": "В Python присутствуют возможности, характерные для функциональных языков, такие как списковые включения, лямбда-функции и функции высшего порядка."
        },
        {
          "text": "Что такое объект первого класса в программировании?",
          "options": [
            "Сущности, которые могут быть переданы как параметр, возвращены из функции и присвоены переменной",
            "Объекты, которые могут быть только сохранены в переменной",
            "Объекты, которые могут быть только переданы в функцию",
            "Объекты, которые не могут быть изменены"
          ],
          "correctAnswer": "Сущности, которые могут быть переданы как параметр, возвращены из функции и присвоены переменной",
          "explanation": "Объектами первого класса называются сущности, которые могут быть переданы как параметр, возвращены из функции и присвоены переменной."
        },
        {
          "text": "Какие характеристики имеет объект первого класса?",
          "options": [
            "Может быть сохранен в переменной, передан в функцию и возвращен из функции",
            "Может быть только сохранен в переменной",
            "Может быть только передан в функцию",
            "Не может быть создан во время выполнения программы"
          ],
          "correctAnswer": "Может быть сохранен в переменной, передан в функцию и возвращен из функции",
          "explanation": "Объект первого класса может быть сохранен в переменной, передан в функцию как аргумент и возвращен из функции как результат."
        },
        {
          "text": "Что является примером объекта первого класса в Python?",
          "options": [
            "Функции",
            "Целые числа",
            "Строки",
            "Списки"
          ],
          "correctAnswer": "Функции",
          "explanation": "В Python функции являются объектами первого класса, что позволяет им быть переданными как аргументы и возвращенными из других функций."
        },
        {
          "text": "Что такое функция высшего порядка?",
          "options": [
            "Функция, принимающая в качестве аргументов другие функции или возвращающая другую функцию",
            "Функция, которая не принимает аргументы",
            "Функция, которая возвращает только числа",
            "Функция, которая не может быть изменена"
          ],
          "correctAnswer": "Функция, принимающая в качестве аргументов другие функции или возвращающая другую функцию",
          "explanation": "Функция высшего порядка — это функция, которая принимает в качестве аргументов другие функции или возвращает другую функцию в качестве результата."
        },
        {
          "text": "Какова основная идея функций высшего порядка?",
          "options": [
            "Функции имеют тот же статус, что и другие объекты данных",
            "Функции могут быть только числовыми",
            "Функции не могут возвращать другие функции",
            "Функции не могут принимать аргументы"
          ],
          "correctAnswer": "Функции имеют тот же статус, что и другие объекты данных",
          "explanation": "Основная идея функций высшего порядка состоит в том, что функции имеют тот же статус, что и другие объекты данных."
        },
        {
          "text": "Что такое каррирование?",
          "options": [
            "Преобразование функции от многих аргументов в набор функций, каждая из которых принимает один аргумент",
            "Процесс объединения нескольких функций в одну",
            "Метод оптимизации производительности функций",
            "Способ обработки ошибок в функциях"
          ],
          "correctAnswer": "Преобразование функции от многих аргументов в набор функций, каждая из которых принимает один аргумент",
          "explanation": "Каррирование — это преобразование функции от многих аргументов в набор функций, каждая из которых является функцией от одного аргумента."
        },
        {
          "text": "Как работает каррирование на примере функции greet?",
          "options": [
            "Мы можем передать часть аргументов и получить функцию, ожидающую остальные аргументы",
            "Функция всегда принимает все аргументы сразу",
            "Каррирование не позволяет использовать функции с несколькими аргументами",
            "Функция не может быть вызвана без всех аргументов"
          ],
          "correctAnswer": "Мы можем передать часть аргументов и получить функцию, ожидающую остальные аргументы",
          "explanation": "Каррирование позволяет передать часть аргументов в функцию и получить обратно функцию, ожидающую остальные аргументы."
        },
        {
          "text": "Как выглядит пример каррирования с функцией greet_deeply_curried?",
          "options": [
            "Функция принимает несколько уровней аргументов и возвращает вложенные функции",
            "Функция принимает только один аргумент",
            "Функция не может быть вложенной",
            "Функция всегда возвращает одно значение"
          ],
          "correctAnswer": "Функция принимает несколько уровней аргументов и возвращает вложенные функции",
          "explanation": "Функция greet_deeply_curried принимает несколько уровней аргументов и возвращает вложенные функции, позволяя передавать аргументы поэтапно."
        },
        {
          "text": "Что делает функция map в Python?",
          "options": [
            "Применяет функцию к каждому элементу последовательности",
            "Фильтрует элементы последовательности",
            "Складывает элементы последовательности",
            "Возвращает количество элементов в последовательности"
          ],
          "correctAnswer": "Применяет функцию к каждому элементу последовательности",
          "explanation": "Функция map применяет заданную функцию к каждому элементу последовательности."
        },
        {
          "text": "Что делает функция filter в Python?",
          "options": [
            "Оставляет только те элементы последовательности, для которых заданная функция истинна",
            "Применяет функцию ко всем элементам последовательности",
            "Складывает элементы последовательности",
            "Возвращает количество элементов в последовательности"
          ],
          "correctAnswer": "Оставляет только те элементы последовательности, для которых заданная функция истинна",
          "explanation": "Функция filter оставляет только те элементы последовательности, для которых заданная функция возвращает True."
        },
        {
          "text": "Что делает функция reduce в Python?",
          "options": [
            "Вычисляет свёртку последовательности как результат последовательного применения функции",
            "Применяет функцию к каждому элементу последовательности",
            "Фильтрует элементы последовательности",
            "Возвращает количество элементов в последовательности"
          ],
          "correctAnswer": "Вычисляет свёртку последовательности как результат последовательного применения функции",
          "explanation": "Функция reduce принимает функцию от двух аргументов и последовательность, вычисляя свёртку последовательности."
        },
        {
          "text": "Где находится функция reduce в Python 3?",
          "options": [
            "В модуле functools",
            "Встроенная в язык",
            "В модуле itertools",
            "В модуле math"
          ],
          "correctAnswer": "В модуле functools",
          "explanation": "В Python 3 функция reduce находится в модуле functools."
        },
        {
          "text": "Что делает декоратор lru_cache из модуля functools?",
          "options": [
            "Кеширует значения функций, которые не меняют свой результат при неизменных аргументах",
            "Применяет функцию к каждому элементу последовательности",
            "Фильтрует элементы последовательности",
            "Вычисляет свёртку последовательности"
          ],
          "correctAnswer": "Кеширует значения функций, которые не меняют свой результат при неизменных аргументах",
          "explanation": "Декоратор lru_cache кеширует значения функций, что полезно для мемоизации и оптимизации рекурсивных функций."
        },
        {
          "text": "Что делает функция partial из модуля functools?",
          "options": [
            "Позволяет частично применять функцию, вызывая её с меньшим количеством аргументов",
            "Кеширует значения функций",
            "Фильтрует элементы последовательности",
            "Вычисляет свёртку последовательности"
          ],
          "correctAnswer": "Позволяет частично применять функцию, вызывая её с меньшим количеством аргументов",
          "explanation": "Функция partial позволяет вызвать функцию с меньшим количеством аргументов, чем она ожидает, и получить новую функцию с оставшимися параметрами."
        },
        {
          "text": "Что делает функция product из модуля itertools?",
          "options": [
            "Создает декартово произведение итераторов",
            "Генерирует перестановки",
            "Генерирует сочетания",
            "Соединяет несколько итераторов в один"
          ],
          "correctAnswer": "Создает декартово произведение итераторов",
          "explanation": "Функция product создает декартово произведение итераторов, что позволяет избегать вложенных циклов for."
        },
        {
          "text": "Что делает функция permutations из модуля itertools?",
          "options": [
            "Генерирует перестановки",
            "Генерирует сочетания",
            "Создает декартово произведение",
            "Соединяет несколько итераторов в один"
          ],
          "correctAnswer": "Генерирует перестановки",
          "explanation": "Функция permutations генерирует все возможные перестановки элементов итератора."
        },
        {
          "text": "Что делает функция combinations из модуля itertools?",
          "options": [
            "Генерирует сочетания",
            "Генерирует перестановки",
            "Создает декартово произведение",
            "Соединяет несколько итераторов в один"
          ],
          "correctAnswer": "Генерирует сочетания",
          "explanation": "Функция combinations генерирует все возможные сочетания элементов итератора заданной длины."
        },
        {
          "text": "Что делает функция chain из модуля itertools?",
          "options": [
            "Соединяет несколько итераторов в один",
            "Генерирует сочетания",
            "Генерирует перестановки",
            "Создает декартово произведение"
          ],
          "correctAnswer": "Соединяет несколько итераторов в один",
          "explanation": "Функция chain соединяет несколько итераторов в один, позволяя итерироваться по всем элементам последовательно."
        },
        {
          "text": "Что делает функция takewhile из модуля itertools?",
          "options": [
            "Получает значения последовательности, пока функция-предикат истинна",
            "Получает значения последовательности, начиная с первого ложного",
            "Генерирует сочетания",
            "Генерирует перестановки"
          ],
          "correctAnswer": "Получает значения последовательности, пока функция-предикат истинна",
          "explanation": "Функция takewhile получает значения последовательности, пока значение функции-предиката для её элементов истинно."
        },
        {
          "text": "Для чего нужен модуль operator в Python?",
          "options": [
            "Содержит функции, соответствующие стандартным операторам",
            "Содержит функции для работы с итераторами",
            "Содержит функции для работы с файлами",
            "Содержит функции для работы с сетью"
          ],
          "correctAnswer": "Содержит функции, соответствующие стандартным операторам",
          "explanation": "Модуль operator содержит функции, которые соответствуют стандартным операторам, позволяя использовать их вместо лямбда-функций."
        },
        {
          "text": "Какой пример использования функции из модуля operator?",
          "options": [
            "operator.add вместо lambda x, y: x + y",
            "operator.concat вместо lambda x, y: x + y",
            "operator.multiply вместо lambda x, y: x * y",
            "operator.subtract вместо lambda x, y: x - y"
          ],
          "correctAnswer": "operator.add вместо lambda x, y: x + y",
          "explanation": "Вместо использования lambda x, y: x + y можно использовать готовую функцию operator.add."
        },
        {
          "text": "Что такое GIL в Python?",
          "options": [
            "Глобальная блокировка интерпретатора, позволяющая выполнять только один поток в любой момент времени",
            "Механизм для управления памятью",
            "Интерфейс для работы с базами данных",
            "Система для управления файлами"
          ],
          "correctAnswer": "Глобальная блокировка интерпретатора, позволяющая выполнять только один поток в любой момент времени",
          "explanation": "GIL (Global Interpreter Lock) — это механизм, который гарантирует, что в любой момент времени может выполняться только один поток Python."
        },
        {
          "text": "Какие проблемы возникают из-за GIL?",
          "options": [
            "Снижает производительность при CPU-bound задачах и усложняет использование потоков",
            "Упрощает работу с многопоточностью",
            "Ускоряет выполнение всех задач",
            "Не имеет никаких проблем"
          ],
          "correctAnswer": "Снижает производительность при CPU-bound задачах и усложняет использование потоков",
          "explanation": "GIL делает бесполезной идею применять потоки для параллелизма в вычислительных задачах, так как они будут работать последовательно."
        },
        {
          "text": "Как GIL влияет на операции ввода-вывода?",
          "options": [
            "GIL освобождается при блокировке для операций ввода-вывода",
            "GIL всегда удерживается во время ввода-вывода",
            "GIL не влияет на ввод-вывод",
            "GIL освобождается только при завершении программы"
          ],
          "correctAnswer": "GIL освобождается при блокировке для операций ввода-вывода",
          "explanation": "Когда поток выполняет операции ввода-вывода, он освобождает GIL, позволяя другим потокам использовать процессор."
        },
        {
          "text": "Что такое asyncio в Python?",
          "options": [
            "Модуль для асинхронного программирования, позволяющий обрабатывать множество соединений без создания большого количества потоков",
            "Модуль для работы с потоками",
            "Модуль для работы с базами данных",
            "Модуль для работы с графикой"
          ],
          "correctAnswer": "Модуль для асинхронного программирования, позволяющий обрабатывать множество соединений без создания большого количества потоков",
          "explanation": "Asyncio — это модуль для асинхронного программирования, который позволяет эффективно обрабатывать множество соединений, используя сопрограммы."
        },
        {
          "text": "В каких ситуациях лучше использовать asyncio?",
          "options": [
            "Когда приложение тратит много времени на чтение/запись данных, а не на их обработку",
            "Когда приложение выполняет много вычислений",
            "Когда количество клиентов предсказуемо и невелико",
            "Когда приложение не зависит от внешних сервисов"
          ],
          "correctAnswer": "Когда приложение тратит много времени на чтение/запись данных, а не на их обработку",
          "explanation": "Asyncio подходит для приложений, которые большую часть времени тратят на чтение/запись данных, например, при работе с медленными запросами."
        },
        {
          "text": "Какое преимущество имеет использование asyncio по сравнению с потоками?",
          "options": [
            "Сопрограммы выполняют только полезную работу и переключение между ними происходит только при ожидании завершения внешней операции",
            "Сопрограммы могут выполнять вычисления быстрее, чем потоки",
            "Сопрограммы используют больше ресурсов, чем потоки",
            "Сопрограммы могут работать параллельно с потоками"
          ],
          "correctAnswer": "Сопрограммы выполняют только полезную работу и переключение между ними происходит только при ожидании завершения внешней операции",
          "explanation": "Сопрограммы в asyncio переключаются только тогда, когда они ожидают завершения внешней операции, что делает их более эффективными для I/O операций."
        },
        {
          "text": "Что такое ключевое слово async в Python?",
          "options": [
            "Указывает, что метод является асинхронным",
            "Указывает, что метод является синхронным",
            "Указывает, что метод возвращает значение",
            "Указывает, что метод не возвращает значение"
          ],
          "correctAnswer": "Указывает, что метод является асинхронным",
          "explanation": "Ключевое слово async перед определением функции указывает, что метод является асинхронным."
        },
        {
          "text": "Что делает ключевое слово await в Python?",
          "options": [
            "Ожидает завершения асинхронной операции",
            "Запускает новую асинхронную операцию",
            "Завершает выполнение функции",
            "Возвращает значение из функции"
          ],
          "correctAnswer": "Ожидает завершения асинхронной операции",
          "explanation": "Ключевое слово await используется для ожидания завершения асинхронной операции."
        },
        {
          "text": "Какова основная цель использования async/await?",
          "options": [
            "Не блокировать поток выполнения на время ожидания асинхронного события",
            "Ускорить выполнение синхронного кода",
            "Упростить работу с потоками",
            "Уменьшить использование памяти"
          ],
          "correctAnswer": "Не блокировать поток выполнения на время ожидания асинхронного события",
          "explanation": "Конструкция async/await позволяет не блокировать поток выполнения, ожидая завершения асинхронного события."
        },
        {
          "text": "Как async/await упрощает код?",
          "options": [
            "Делает код более простым и линейным",
            "Усложняет код",
            "Увеличивает количество строк кода",
            "Уменьшает читаемость кода"
          ],
          "correctAnswer": "Делает код более простым и линейным",
          "explanation": "Использование async/await делает код более простым и линейным, избегая блокирующих операций."
        },
        {
          "text": "Как в Python реализуется многопоточность?",
          "options": [
            "С помощью модуля threading",
            "С помощью модуля multiprocessing",
            "С помощью модуля asyncio",
            "С помощью модуля queue"
          ],
          "correctAnswer": "С помощью модуля threading",
          "explanation": "Модуль threading используется для реализации многопоточности в Python, используя нативные Posix-треды."
        },
        {
          "text": "Что такое нативные Posix-треды?",
          "options": [
            "Треды, исполняемые операционной системой",
            "Треды, исполняемые виртуальной машиной",
            "Треды, которые не могут быть использованы в Python",
            "Треды, которые работают только на Windows"
          ],
          "correctAnswer": "Треды, исполняемые операционной системой",
          "explanation": "Нативные Posix-треды исполняются операционной системой, а не виртуальной машиной Python."
        },
        {
          "text": "В чем главное отличие тредов от мультипроцессинга?",
          "options": [
            "В разделении памяти",
            "В скорости выполнения",
            "В количестве используемых ресурсов",
            "В способе обработки данных"
          ],
          "correctAnswer": "В разделении памяти",
          "explanation": "Главное отличие в том, что процессы имеют раздельные адресные пространства, а треды исполняются в совместном адресном пространстве."
        },
        {
          "text": "Какое из следующих утверждений верно для процессов?",
          "options": [
            "Процессы независимы друг от друга и имеют раздельные адресные пространства",
            "Процессы имеют общий доступ к памяти",
            "Процессы всегда работают быстрее, чем треды",
            "Процессы не могут использовать ресурсы друг друга"
          ],
          "correctAnswer": "Процессы независимы друг от друга и имеют раздельные адресные пространства",
          "explanation": "Процессы независимы друг от друга, имеют раздельные адресные пространства и ресурсы."
        },
        {
          "text": "Какое из следующих утверждений верно для тредов?",
          "options": [
            "Треды имеют общий доступ к памяти и переменным",
            "Треды всегда работают медленнее, чем процессы",
            "Треды имеют раздельные адресные пространства",
            "Треды не могут взаимодействовать друг с другом"
          ],
          "correctAnswer": "Треды имеют общий доступ к памяти и переменным",
          "explanation": "Треды исполняются в совместном адресном пространстве и имеют общий доступ к памяти и переменным."
        },
        {
          "text": "Какие задачи хорошо параллелятся?",
          "options": [
            "Задачи, порождающие долгий I/O",
            "Задачи, требующие интенсивных вычислений",
            "Задачи, которые не требуют ожидания",
            "Задачи, работающие с небольшими объемами данных"
          ],
          "correctAnswer": "Задачи, порождающие долгий I/O",
          "explanation": "Хорошо параллелятся задачи, которые порождают долгий I/O, так как треды могут переключаться во время ожидания."
        },
        {
          "text": "Почему задачи, обрабатывающие данные в тредах, могут замедлить программу?",
          "options": [
            "Потому что выполняется только один тред, и происходит переключение на другие треды",
            "Потому что треды не могут взаимодействовать друг с другом",
            "Потому что треды всегда работают медленнее, чем процессы",
            "Потому что треды не могут обрабатывать данные"
          ],
          "correctAnswer": "Потому что выполняется только один тред, и происходит переключение на другие треды",
          "explanation": "Если тред обрабатывает данные, выполняется только он один, что может замедлить программу из-за переключения на другие треды."
        },
        {
          "text": "Какие задачи плохо параллелятся?",
          "options": [
            "Задачи, требующие интенсивных вычислений",
            "Задачи, работающие с сетью",
            "Задачи, работающие с файлами",
            "Задачи, требующие ожидания"
          ],
          "correctAnswer": "Задачи, требующие интенсивных вычислений",
          "explanation": "Задачи, требующие интенсивных вычислений, плохо параллелятся, так как они могут блокировать GIL и не использовать преимущества многопоточности."
        },
        {
          "text": "Почему не стоит использовать треды для решения 100 уравнений?",
          "options": [
            "Потому что в этой задаче нет ввода-вывода, и треды будут тратить время на переключение",
            "Потому что треды всегда работают быстрее, чем процессы",
            "Потому что треды не могут выполнять математические операции",
            "Потому что треды не могут взаимодействовать друг с другом"
          ],
          "correctAnswer": "Потому что в этой задаче нет ввода-вывода, и треды будут тратить время на переключение",
          "explanation": "В задаче с математическими уравнениями нет ввода-вывода, поэтому использование тредов приведет к лишним затратам времени на переключение."
        },
        {
          "text": "Что лучше использовать для сложных математических задач?",
          "options": [
            "Отдельные процессы или фреймворк для распределенных задач, такие как Celery",
            "Треды",
            "Асинхронные функции",
            "Лямбда-функции"
          ],
          "correctAnswer": "Отдельные процессы или фреймворк для распределенных задач, такие как Celery",
          "explanation": "Сложные математические задачи лучше выносить в отдельные процессы или использовать фреймворк для распределенных задач, такие как Celery."
        },
        {
          "text": "Являются ли треды в Python нативными?",
          "options": [
            "Да, это нативные Posix-совместимые треды, исполняемые на уровне операционной системы",
            "Нет, это виртуальные треды, исполняемые интерпретатором",
            "Нет, это треды, которые не могут взаимодействовать с операционной системой",
            "Да, но они работают только на Windows"
          ],
          "correctAnswer": "Да, это нативные Posix-совместимые треды, исполняемые на уровне операционной системы",
          "explanation": "Треды в Python являются нативными Posix-совместимыми тредами, которые исполняются на уровне операционной системы."
        },
        {
          "text": "Что такое гринлеты?",
          "options": [
            "Легковесные треды внутри виртуальной машины, управляемые самой виртуальной машиной",
            "Треды, которые управляются операционной системой",
            "Треды, которые не могут взаимодействовать друг с другом",
            "Треды, которые всегда работают быстрее, чем обычные треды"
          ],
          "correctAnswer": "Легковесные треды внутри виртуальной машины, управляемые самой виртуальной машиной",
          "explanation": "Гринлеты — это легковесные треды внутри виртуальной машины, которые управляются самой виртуальной машиной."
        },
        {
          "text": "Какой модуль в Python использует гринлеты?",
          "options": [
            "Модуль greenlet",
            "Модуль threading",
            "Модуль multiprocessing",
            "Модуль asyncio"
          ],
          "correctAnswer": "Модуль greenlet",
          "explanation": "Модуль greenlet в Python реализует гринлеты, позволяя создавать легковесные треды."
        },
        {
          "text": "Какие языки программирования используют концепцию корутин, аналогичную гринлетам?",
          "options": [
            "Go и Lua",
            "C и C++",
            "Java и JavaScript",
            "Ruby и PHP"
          ],
          "correctAnswer": "Go и Lua",
          "explanation": "Корутину в языках Go и Lua можно считать аналогом гринлетов, так как они также представляют собой легковесные треды."
        },
        {
          "text": "Какой из следующих способов реализации шаблона Singleton является декоратором?",
          "options": [
            "Использование функции singleton",
            "Использование класса Singleton",
            "Использование метакласса",
            "Использование модуля"
          ],
          "correctAnswer": "Использование функции singleton",
          "explanation": "Декоратор singleton реализует шаблон Singleton, позволяя создавать только один экземпляр класса."
        },
        {
          "text": "Какой из следующих способов реализации Singleton является настоящим классом?",
          "options": [
            "Использование класса Singleton",
            "Использование функции singleton",
            "Использование метакласса",
            "Использование модуля"
          ],
          "correctAnswer": "Использование класса Singleton",
          "explanation": "Класс Singleton реализует шаблон Singleton и позволяет создавать только один экземпляр класса, оставаясь настоящим классом."
        },
        {
          "text": "Какой из следующих способов реализации Singleton использует метаклассы?",
          "options": [
            "Использование класса с метаклассом Singleton",
            "Использование функции singleton",
            "Использование класса Singleton",
            "Использование модуля"
          ],
          "correctAnswer": "Использование класса с метаклассом Singleton",
          "explanation": "Метакласс Singleton позволяет создавать только один экземпляр класса, используя механизм метаклассов."
        },
        {
          "text": "Какой из следующих способов реализации Singleton является самым простым?",
          "options": [
            "Использование модуля",
            "Использование класса Singleton",
            "Использование функции singleton",
            "Использование метакласса"
          ],
          "correctAnswer": "Использование модуля",
          "explanation": "Реализация Singleton через модуль является самой простой, так как не требует сложных конструкций."
        },
        {
          "text": "Какой инструмент используется для проверки кода на соответствие PEP8?",
          "options": [
            "Pycodestyle",
            "Pylint",
            "Flake8",
            "Vulture"
          ],
          "correctAnswer": "Pycodestyle",
          "explanation": "Pycodestyle — это утилита для анализа кода Python, проверяющая соответствие PEP8."
        },
        {
          "text": "Какой инструмент ищет 'мертвый' код в Python?",
          "options": [
            "Vulture",
            "Pylint",
            "Pycodestyle",
            "Flake8"
          ],
          "correctAnswer": "Vulture",
          "explanation": "Vulture — это утилита для поиска 'мертвого' кода в программах Python."
        },
        {
          "text": "Какой инструмент объединяет функциональность других инструментов анализа Python?",
          "options": [
            "Prospector",
            "Pylama",
            "Pylint",
            "Flake8"
          ],
          "correctAnswer": "Prospector",
          "explanation": "Prospector объединяет функциональность других инструментов анализа Python, таких как pylint, pep8, mccabe и другие."
        },
        {
          "text": "Какой инструмент автоматически исправляет код, не совместимый с PEP8?",
          "options": [
            "autopep8",
            "yapf",
            "black",
            "Pylint"
          ],
          "correctAnswer": "autopep8",
          "explanation": "autopep8 модифицирует код, не совместимый с PEP8, и использует pycodestyle для проверки соответствия."
        },
        {
          "text": "Какой инструмент является бескомпромиссным форматировщиком кода?",
          "options": [
            "black",
            "yapf",
            "autopep8",
            "Pylint"
          ],
          "correctAnswer": "black",
          "explanation": "black — это бескомпромиссный форматировщик, который работает быстро и экономит время программистов."
        },
        {
          "text": "Что такое list comprehension в Python?",
          "options": [
            "Выражение, заключенное в квадратные скобки, использующее for и in для построения списка",
            "Выражение, заключенное в фигурные скобки, использующее for и in для построения словаря",
            "Выражение, которое создает только один элемент",
            "Выражение, которое не использует циклы"
          ],
          "correctAnswer": "Выражение, заключенное в квадратные скобки, использующее for и in для построения списка",
          "explanation": "List comprehension — это выражение, заключенное в квадратные скобки, использующее ключевые слова for и in для построения списка."
        },
        {
          "text": "Что такое dict comprehension в Python?",
          "options": [
            "Выражение, заключенное в фигурные скобки, использующее for и in для построения словаря",
            "Выражение, заключенное в квадратные скобки, использующее for и in для построения списка",
            "Выражение, которое создает только один элемент",
            "Выражение, которое не использует циклы"
          ],
          "correctAnswer": "Выражение, заключенное в фигурные скобки, использующее for и in для построения словаря",
          "explanation": "Dict comprehension — это выражение, заключенное в фигурные скобки, использующее ключевые слова for и in для построения словаря."
        },
        {
          "text": "Что означает 'энергичный' в контексте включений?",
          "options": [
            "Итерируемый объект, который сразу строит все свои элементы",
            "Итерируемый объект, который строит элементы по одному",
            "Итерируемый объект, который не может быть изменен",
            "Итерируемый объект, который требует больше памяти"
          ],
          "correctAnswer": "Итерируемый объект, который сразу строит все свои элементы",
          "explanation": "'Энергичный' означает, что итерируемый объект сразу строит все свои элементы, в отличие от 'ленивого' подхода."
        },
        {
          "text": "Какое использование подчеркивания в Python обозначает игнорирование значения?",
          "options": [
            "Одинарное подчеркивание",
            "Двойное подчеркивание",
            "Двойное подчеркивание в начале",
            "Двойное подчеркивание в начале и конце"
          ],
          "correctAnswer": "Одинарное подчеркивание",
          "explanation": "Одинарное подчеркивание используется для игнорирования значения в Python."
        },
        {
          "text": "Что означает двойное подчеркивание в начале имени переменной?",
          "options": [
            "Это специальное значение функции или переменной",
            "Это обозначает, что переменная является приватной",
            "Это обозначает, что переменная является глобальной",
            "Это обозначает, что переменная не может быть изменена"
          ],
          "correctAnswer": "Это обозначает, что переменная является приватной",
          "explanation": "Двойное подчеркивание в начале имени переменной указывает на то, что переменная является приватной."
        },
        {
          "text": "Какое использование подчеркивания позволяет разделять символы числа?",
          "options": [
            "Одинарное подчеркивание",
            "Двойное подчеркивание",
            "Двойное подчеркивание в начале",
            "Двойное подчеркивание в начале и конце"
          ],
          "correctAnswer": "Одинарное подчеркивание",
          "explanation": "Одинарное подчеркивание может использоваться для разделения символов числа, например, `1_00 == 100`."
        },
        {
          "text": "Что делает метод deepcopy() в Python?",
          "options": [
            "Создает новую и отдельную копию всего объекта или списка",
            "Создает ссылку на существующий объект",
            "Копирует только верхний уровень объекта",
            "Создает копию объекта, но не копирует его элементы"
          ],
          "correctAnswer": "Создает новую и отдельную копию всего объекта или списка",
          "explanation": "Метод deepcopy() создает новую и отдельную копию всего объекта или списка со своим уникальным адресом памяти."
        },
        {
          "text": "Что делает метод copy() в Python?",
          "options": [
            "Создает отдельный новый объект, копируя ссылки на дочерние элементы",
            "Создает глубокую копию объекта",
            "Создает ссылку на существующий объект",
            "Копирует только верхний уровень объекта"
          ],
          "correctAnswer": "Создает отдельный новый объект, копируя ссылки на дочерние элементы",
          "explanation": "Метод copy() создает новый объект, но копирует только ссылки на дочерние элементы, а не их значения."
        },
        {
          "text": "Какое утверждение верно для поверхностного копирования?",
          "options": [
            "Изменения в исходном объекте будут отражены в скопированном объекте",
            "Скопированный объект полностью независим от исходного",
            "Поверхностное копирование не создает новый объект",
            "Поверхностное копирование всегда безопасно"
          ],
          "correctAnswer": "Изменения в исходном объекте будут отражены в скопированном объекте",
          "explanation": "При поверхностном копировании изменения в исходном объекте будут отражены в скопированном объекте, так как они ссылаются на одни и те же дочерние элементы."
        },
        {
          "text": "Что такое garbage collector (GC) в Python?",
          "options": [
            "Сборщик мусора, который удаляет циклические ссылки",
            "Инструмент для управления памятью",
            "Модуль для оптимизации кода",
            "Метод для ускорения выполнения программ"
          ],
          "correctAnswer": "Сборщик мусора, который удаляет циклические ссылки",
          "explanation": "GC (generational garbage collector) — это сборщик мусора, который создан для обнаружения и удаления циклических ссылок."
        },
        {
          "text": "Какой алгоритм используется в Python для управления памятью?",
          "options": [
            "Подсчет ссылок и поколенческий сборщик мусора",
            "Только подсчет ссылок",
            "Только поколенческий сборщик мусора",
            "Алгоритм сжатия памяти"
          ],
          "correctAnswer": "Подсчет ссылок и поколенческий сборщик мусора",
          "explanation": "Стандартный интерпретатор Python (CPython) использует алгоритм подсчета ссылок и поколенческий сборщик мусора."
        },
        {
          "text": "Как работает алгоритм подсчета ссылок?",
          "options": [
            "Считывает количество ссылок на объект и освобождает память, когда счетчик достигает нуля",
            "Удаляет объекты по времени их создания",
            "Сканирует память на наличие неиспользуемых объектов",
            "Перемещает объекты в другое место в памяти"
          ],
          "correctAnswer": "Считывает количество ссылок на объект и освобождает память, когда счетчик достигает нуля",
          "explanation": "Алгоритм подсчета ссылок отслеживает количество ссылок на объект и освобождает память, когда счетчик ссылок достигает нуля."
        },
        {
          "text": "Что происходит, когда несколько поколений преодолевают порог срабатывания сборщика мусора?",
          "options": [
            "Срабатывает процесс сборки мусора для наиболее старшего поколения",
            "Срабатывает процесс сборки мусора для всех поколений",
            "Сборщик мусора отключается",
            "Сборщик мусора работает в фоновом режиме"
          ],
          "correctAnswer": "Срабатывает процесс сборки мусора для наиболее старшего поколения",
          "explanation": "Если несколько поколений преодолевают порог, срабатывает процесс сборки мусора для наиболее старшего поколения."
        },
        {
          "text": "Что такое интроспекция в Python?",
          "options": [
            "Способность программы исследовать тип или свойства объекта во время работы",
            "Метод для создания объектов",
            "Способ проверки синтаксиса кода",
            "Способ оптимизации производительности"
          ],
          "correctAnswer": "Способность программы исследовать тип или свойства объекта во время работы",
          "explanation": "Интроспекция — это способность программы исследовать тип или свойства объекта во время выполнения."
        },
        {
          "text": "Какой метод в Python используется для получения списка атрибутов объекта?",
          "options": [
            "dir()",
            "type()",
            "instanceof()",
            "attributes()"
          ],
          "correctAnswer": "dir()",
          "explanation": "Метод dir() используется для вывода списка атрибутов объекта в Python."
        },
        {
          "text": "Какой пример кода демонстрирует интроспекцию в Java?",
          "options": [
            "if(obj instanceof Person)",
            "if(type(obj) == Person)",
            "if(obj is Person)",
            "if(obj.getClass() == Person.class)"
          ],
          "correctAnswer": "if(obj instanceof Person)",
          "explanation": "В Java используется оператор instanceof для проверки, является ли объект экземпляром класса."
        },
        {
          "text": "Какой язык программирования не поддерживает интроспекцию?",
          "options": [
            "Python",
            "Java",
            "C++",
            "Ассемблер"
          ],
          "correctAnswer": "Ассемблер",
          "explanation": "Ассемблер не поддерживает интроспекцию, в отличие от языков, таких как Python, Java и C++."
        },
        {
          "text": "Что такое рефлексия в программировании?",
          "options": [
            "Способность программы изучать и модифицировать свою структуру и поведение во время выполнения",
            "Способность программы проверять типы данных во время компиляции",
            "Способность программы оптимизировать производительность",
            "Способность программы управлять памятью"
          ],
          "correctAnswer": "Способность программы изучать и модифицировать свою структуру и поведение во время выполнения",
          "explanation": "Рефлексия — это способность программы изучать и модифицировать свою структуру и поведение во время выполнения."
        },
        {
          "text": "Какой метод в Python используется для вызова метода объекта с использованием рефлексии?",
          "options": [
            "getattr()",
            "setattr()",
            "dir()",
            "type()"
          ],
          "correctAnswer": "getattr()",
          "explanation": "Метод getattr() используется для получения атрибута объекта по имени во время выполнения."
        },
        {
          "text": "В каких языках программирования рефлексия труднее реализовать?",
          "options": [
            "В статически типизированных языках",
            "В динамически типизированных языках",
            "В языках с автоматическим управлением памятью",
            "В языках с низким уровнем"
          ],
          "correctAnswer": "В статически типизированных языках",
          "explanation": "Рефлексия труднее реализовать в статически типизированных языках, так как ошибки типизации возникают во время компиляции."
        },
        {
          "text": "Какой язык не поддерживает рефлексию?",
          "options": [
            "C++",
            "Java",
            "C#",
            "Python"
          ],
          "correctAnswer": "C++",
          "explanation": "C++ поддерживает только интроспекцию, но не рефлексию."
        }
      ]
    },
    {
      "id": "django",
      "name": "Django",
      "description": "Вопросы по Django.",
      "questions": [
        {
          "text": "Что такое Middleware и для чего он нужен?",
          "options": [
            "Объект, который изменяет входящий запрос или исходящий ответ",
            "Объект, который обрабатывает только входящие запросы",
            "Объект, который отвечает за работу с базой данных",
            "Объект, который управляет сессиями пользователей"
          ],
          "correctAnswer": "Объект, который изменяет входящий запрос или исходящий ответ",
          "explanation": "Middleware обрабатывает все запросы приложения, изменяя их или добавляя заголовки."
        },
        {
          "text": "Назовите основные мидлвари и их назначение.",
          "options": [
            "SessionMiddleware, CsrfViewMiddleware, AuthenticationMiddleware, MessageMiddleware",
            "Only SessionMiddleware",
            "Only CsrfViewMiddleware",
            "Only AuthenticationMiddleware"
          ],
          "correctAnswer": "SessionMiddleware, CsrfViewMiddleware, AuthenticationMiddleware, MessageMiddleware",
          "explanation": "Основные мидлвари включают поддержку сессий, проверку CSRF, авторизацию пользователей и передачу сообщений."
        },
        {
          "text": "Опишите алгоритм работы CSRF middleware.",
          "options": [
            "Генерация токена и проверка его на совпадение",
            "Создание сессии для каждого пользователя",
            "Проверка всех запросов на наличие ошибок",
            "Отправка уведомлений пользователям"
          ],
          "correctAnswer": "Генерация токена и проверка его на совпадение",
          "explanation": "CSRF middleware генерирует уникальный токен для каждого запроса и проверяет его при отправке формы."
        },
        {
          "text": "Что такое сигналы в Django?",
          "options": [
            "События, которые оповещают приложение о произошедших действиях",
            "Методы для работы с базой данных",
            "Функции для обработки запросов",
            "Классы для создания моделей"
          ],
          "correctAnswer": "События, которые оповещают приложение о произошедших действиях",
          "explanation": "Сигналы позволяют различным частям приложения реагировать на события, такие как начало и окончание запроса."
        },
        {
          "text": "Как реализуется связь m2m на уровне базы данных?",
          "options": [
            "Создается таблица-мост с ключами на обе модели",
            "Создается отдельная таблица для каждой модели",
            "Связь реализуется через внешние ключи",
            "Связь не поддерживается в Django"
          ],
          "correctAnswer": "Создается таблица-мост с ключами на обе модели",
          "explanation": "Связь многие ко многим реализуется через таблицу-мост, которая хранит ключи на обе модели."
        },
        {
          "text": "Чем лучше отправлять форму — GET или POST?",
          "options": [
            "GET, так как он быстрее",
            "POST, так как он безопаснее для передачи данных",
            "Оба метода одинаковы",
            "GET, так как он проще в реализации"
          ],
          "correctAnswer": "POST, так как он безопаснее для передачи данных",
          "explanation": "POST-запросы не кешируются и не сохраняются в истории браузера, что делает их более безопасными для передачи конфиденциальной информации."
        },
        {
          "text": "Как работает Serializer в Django REST Framework?",
          "options": [
            "Преобразует данные в формат, который можно передать через API",
            "Создает новые модели в базе данных",
            "Обрабатывает запросы к базе данных",
            "Управляет сессиями пользователей"
          ],
          "correctAnswer": "Преобразует данные в формат, который можно передать через API",
          "explanation": "Serializer преобразует данные из модели Django в формат JSON для передачи через API и обратно."
        },
        {
          "text": "Что такое Meta в классах Django?",
          "options": [
            "Класс, который управляет метаданными модели",
            "Класс, который отвечает за обработку запросов",
            "Класс, который создает другие классы",
            "Класс, который управляет сессиями"
          ],
          "correctAnswer": "Класс, который управляет метаданными модели",
          "explanation": "Meta используется для определения параметров модели, таких как имя таблицы и порядок сортировки."
        },
        {
          "text": "За что отвечает Meta в сериализаторе?",
          "options": [
            "Определяет модель и поля, которые будут включены",
            "Управляет сессиями пользователей",
            "Создает новые экземпляры модели",
            "Обрабатывает запросы к базе данных"
          ],
          "correctAnswer": "Определяет модель и поля, которые будут включены",
          "explanation": "Meta в сериализаторе позволяет указать, какие поля модели будут сериализованы и какие будут исключены."
        },
        {
          "text": "Какая разница в быстродействии между Django и Flask?",
          "options": [
            "Django быстрее, так как он более оптимизирован",
            "Flask быстрее, так как он легче и проще",
            "Оба фреймворка имеют одинаковую производительность",
            "Django всегда медленнее, чем Flask"
          ],
          "correctAnswer": "Flask быстрее, так как он легче и проще",
          "explanation": "Flask предоставляет больше гибкости и меньше накладных расходов, что делает его более быстрым для небольших приложений."
        }
      ]
    },
    {
      "id": "web_development",
      "name": "Веб-разработка",
      "description": "Вопросы по веб-разработке.",
      "questions": [
        {
          "text": "Что такое CGI?",
          "options": [
            "Common Gateway Interface",
            "Common Graphics Interface",
            "Common General Interface",
            "Common Gateway Integration"
          ],
          "correctAnswer": "Common Gateway Interface",
          "explanation": "CGI — это соглашение о том, как веб-сервер взаимодействует с программой, написанной на каком-то языке."
        },
        {
          "text": "Каковы плюсы CGI?",
          "options": [
            "Протокол не накладывает условия на язык, простота, отсутствие состояния",
            "Высокая скорость обработки запросов",
            "Поддержка всех языков программирования",
            "Безопасность данных"
          ],
          "correctAnswer": "Протокол не накладывает условия на язык, простота, отсутствие состояния",
          "explanation": "Плюсы CGI включают в себя отсутствие ограничений на язык, простоту протокола и отсутствие состояния программы."
        },
        {
          "text": "Каковы минусы CGI?",
          "options": [
            "Медленный запуск процесса на каждый запрос",
            "Сложность в отладке",
            "Отсутствие поддержки языков",
            "Невозможность работы с данными"
          ],
          "correctAnswer": "Медленный запуск процесса на каждый запрос",
          "explanation": "Минусы CGI включают медленный запуск процесса операционной системы на каждый запрос и медленную передачу данных через stdout."
        },
        {
          "text": "Какая разница между аутентификацией и авторизацией?",
          "options": [
            "Аутентификация определяет, кто вы, авторизация определяет, что вы можете делать",
            "Аутентификация и авторизация - это одно и то же",
            "Аутентификация - это проверка пароля, авторизация - это проверка имени",
            "Аутентификация происходит после авторизации"
          ],
          "correctAnswer": "Аутентификация определяет, кто вы, авторизация определяет, что вы можете делать",
          "explanation": "Аутентификация проверяет личность пользователя, а авторизация определяет его права доступа."
        },
        {
          "text": "Что такое идентификация?",
          "options": [
            "Процесс проверки полномочий пользователя",
            "Процесс присвоения идентификатора субъектам и объектам",
            "Процесс проверки пароля",
            "Процесс предоставления доступа к ресурсам"
          ],
          "correctAnswer": "Процесс присвоения идентификатора субъектам и объектам",
          "explanation": "Идентификация - это процесс присвоения идентификатора и сравнение его с перечнем присвоенных идентификаторов."
        },
        {
          "text": "Каковы три основные процедуры аутентификации и авторизации?",
          "options": [
            "Идентификация, аутентификация, авторизация",
            "Аутентификация, авторизация, проверка пароля",
            "Идентификация, проверка пароля, предоставление доступа",
            "Аутентификация, идентификация, проверка прав"
          ],
          "correctAnswer": "Идентификация, аутентификация, авторизация",
          "explanation": "Процессы взаимосвязаны: сначала идентификация, затем аутентификация и, наконец, авторизация."
        },
        {
          "text": "Что такое XSS?",
          "options": [
            "Межсайтовые запросы",
            "Межсайтовый скриптинг",
            "Межсайтовая безопасность",
            "Межсайтовая сессия"
          ],
          "correctAnswer": "Межсайтовый скриптинг",
          "explanation": "XSS (Cross-Site Scripting) — это уязвимость, позволяющая злоумышленникам внедрять скрипты на веб-страницы."
        },
        {
          "text": "Как можно защитить приложение от XSS?",
          "options": [
            "Экранирование небезопасных символов и санация HTML-тегов",
            "Использование HTTPS",
            "Регулярные обновления системы",
            "Ограничение доступа к API"
          ],
          "correctAnswer": "Экранирование небезопасных символов и санация HTML-тегов",
          "explanation": "Защита от XSS включает экранирование небезопасных символов и очистку HTML-тегов перед их отображением."
        },
        {
          "text": "Какой пример XSS уязвимости?",
          "options": [
            "Внедрение скрипта в комментарий",
            "Отправка формы без проверки",
            "Использование устаревших библиотек",
            "Отсутствие HTTPS"
          ],
          "correctAnswer": "Внедрение скрипта в комментарий",
          "explanation": "Примером XSS является внедрение JavaScript-кода в комментарий, который затем исполняется браузером других пользователей."
        },
        {
          "text": "Что такое REST?",
          "options": [
            "Протокол для обмена сообщениями",
            "Архитектурный стиль для проектирования веб-сервисов",
            "Стандарт для работы с базами данных",
            "Метод аутентификации"
          ],
          "correctAnswer": "Архитектурный стиль для проектирования веб-сервисов",
          "explanation": "REST (Representational State Transfer) — это архитектурный стиль, который определяет, как строить веб-сервисы."
        },
        {
          "text": "Каковы основные методы HTTP, используемые в REST?",
          "options": [
            "GET, POST, PUT, DELETE, PATCH, HEAD",
            "GET, POST, SOAP, DELETE",
            "PUT, PATCH, DELETE, OPTIONS",
            "GET, POST, PUT, SOAP"
          ],
          "correctAnswer": "GET, POST, PUT, DELETE, PATCH, HEAD",
          "explanation": "Основные методы HTTP, используемые в REST, включают GET, POST, PUT, DELETE, PATCH и HEAD."
        },
        {
          "text": "Каковы архитектурные ограничения REST?",
          "options": [
            "Единообразие интерфейса, клиент-сервер, отсутствие состояния, кэширование, слои, код по требованию",
            "Только клиент-сервер и кэширование",
            "Только отсутствие состояния и кэширование",
            "Нет никаких ограничений"
          ],
          "correctAnswer": "Единообразие интерфейса, клиент-сервер, отсутствие состояния, кэширование, слои, код по требованию",
          "explanation": "REST определяет шесть архитектурных ограничений, которые помогают создать настоящий RESTful API."
        },
        {
          "text": "Что такое SOAP?",
          "options": [
            "Протокол для обмена структурированными сообщениями",
            "Метод аутентификации",
            "Формат данных для веб-сервисов",
            "Архитектурный стиль для проектирования веб-сервисов"
          ],
          "correctAnswer": "Протокол для обмена структурированными сообщениями",
          "explanation": "SOAP (Simple Object Access Protocol) — это протокол для обмена структурированными сообщениями в распределённых вычислительных средах."
        },
        {
          "text": "В чем разница между REST и SOAP?",
          "options": [
            "REST поддерживает различные форматы, SOAP - только XML",
            "REST работает только по HTTP, SOAP - по любым протоколам",
            "REST работает с ресурсами, SOAP - с операциями",
            "Все вышеперечисленное"
          ],
          "correctAnswer": "Все вышеперечисленное",
          "explanation": "REST и SOAP имеют множество различий, включая поддержку форматов, протоколов и подход к работе с ресурсами."
        },
        {
          "text": "Что такое SOAP?",
          "options": [
            "Протокол обмена структурированными сообщениями",
            "Метод аутентификации",
            "Формат данных для веб-сервисов",
            "Архитектурный стиль для проектирования веб-сервисов"
          ],
          "correctAnswer": "Протокол обмена структурированными сообщениями",
          "explanation": "SOAP (Simple Object Access Protocol) — это протокол для обмена структурированными сообщениями в распределённых вычислительных средах."
        },
        {
          "text": "Какова основная цель SOAP?",
          "options": [
            "Обмен произвольными сообщениями в формате XML",
            "Создание веб-страниц",
            "Управление базами данных",
            "Аутентификация пользователей"
          ],
          "correctAnswer": "Обмен произвольными сообщениями в формате XML",
          "explanation": "SOAP изначально предназначался для реализации удалённого вызова процедур, но теперь используется для обмена произвольными сообщениями в формате XML."
        },
        {
          "text": "С какими протоколами может использоваться SOAP?",
          "options": [
            "HTTP, HTTPS, SMTP, FTP",
            "Только HTTP",
            "Только FTP",
            "Только HTTPS"
          ],
          "correctAnswer": "HTTP, HTTPS, SMTP, FTP",
          "explanation": "SOAP может использоваться с любым протоколом прикладного уровня, включая HTTP, HTTPS, SMTP и FTP."
        },
        {
          "text": "В чем разница между REST и SOAP веб-сервисами?",
          "options": [
            "REST поддерживает различные форматы, SOAP - только XML",
            "REST работает только по HTTP, SOAP - по любым протоколам",
            "REST работает с ресурсами, SOAP - с операциями",
            "Все вышеперечисленное"
          ],
          "correctAnswer": "Все вышеперечисленное",
          "explanation": "REST и SOAP имеют множество различий, включая поддержку форматов, протоколов и подход к работе с ресурсами."
        },
        {
          "text": "Какой из следующих форматов поддерживает REST?",
          "options": [
            "Только XML",
            "Только JSON",
            "Только текст",
            "JSON, XML, текст"
          ],
          "correctAnswer": "JSON, XML, текст",
          "explanation": "REST поддерживает различные форматы, включая JSON, XML и текст."
        },
        {
          "text": "Какой из следующих протоколов не поддерживает SOAP?",
          "options": [
            "HTTP",
            "HTTPS",
            "FTP",
            "REST"
          ],
          "correctAnswer": "REST",
          "explanation": "SOAP может работать с различными протоколами, но REST не является протоколом, а архитектурным стилем."
        },
        {
          "text": "Можно ли отправлять SOAP сообщения с вложением?",
          "options": [
            "Да, это возможно",
            "Нет, это невозможно",
            "Только текстовые сообщения",
            "Только изображения"
          ],
          "correctAnswer": "Да, это возможно",
          "explanation": "SOAP сообщения могут содержать вложения различных форматов, включая PDF и изображения, с использованием расширения MIME."
        },
        {
          "text": "Какой формат вложений поддерживает SOAP?",
          "options": [
            "Только текст",
            "Только изображения",
            "PDF, изображения и другие двоичные данные",
            "Только XML"
          ],
          "correctAnswer": "PDF, изображения и другие двоичные данные",
          "explanation": "SOAP поддерживает вложения различных форматов, включая PDF и изображения, с использованием расширения MIME."
        },
        {
          "text": "Как бы вы решили, какой из REST или SOAP веб-сервисов использовать?",
          "options": [
            "REST для простоты, SOAP для стандарта",
            "SOAP для простоты, REST для стандарта",
            "Оба одинаковы",
            "Ни один из них не подходит"
          ],
          "correctAnswer": "REST для простоты, SOAP для стандарта",
          "explanation": "REST предлагает скорость и расширяемость, в то время как SOAP предоставляет больше возможностей по безопасности и транзакционной безопасности."
        },
        {
          "text": "Каковы основные преимущества REST?",
          "options": [
            "Скорость, расширяемость, поддержка многих форматов",
            "Безопасность и транзакционная безопасность",
            "Только поддержка XML",
            "Только работа по HTTP"
          ],
          "correctAnswer": "Скорость, расширяемость, поддержка многих форматов",
          "explanation": "REST предлагает высокую скорость, расширяемость и поддержку различных форматов данных."
        },
        {
          "text": "Каковы основные преимущества SOAP?",
          "options": [
            "Скорость и простота",
            "Безопасность (WS-security) и транзакционная безопасность (ACID)",
            "Поддержка только JSON",
            "Работа только по HTTP"
          ],
          "correctAnswer": "Безопасность (WS-security) и транзакционная безопасность (ACID)",
          "explanation": "SOAP предлагает более высокие уровни безопасности и поддержку транзакционной безопасности."
        }
      ]
    },
    {
      "id": "http",
      "name": "HTTP",
      "description": "Вопросы по протоколу HTTP.",
      "questions": [
        {
          "text": "Как устроен протокол HTTP?",
          "options": [
            "Это текстовый протокол, работающий поверх TCP/IP",
            "Это бинарный протокол, работающий поверх UDP",
            "Это протокол, работающий только с текстовыми данными",
            "Это протокол, который не использует заголовки"
          ],
          "correctAnswer": "Это текстовый протокол, работающий поверх TCP/IP",
          "explanation": "HTTP — это текстовый протокол, который работает поверх TCP/IP и состоит из запроса и ответа."
        },
        {
          "text": "Что включает в себя стартовая строка запроса HTTP?",
          "options": [
            "Метод, путь и версия протокола",
            "Только метод и путь",
            "Только путь и версия",
            "Метод и заголовки"
          ],
          "correctAnswer": "Метод, путь и версия протокола",
          "explanation": "Стартовая строка запроса состоит из метода, пути и версии протокола, например, `GET /index.html HTTP/1.1`."
        },
        {
          "text": "Что такое заголовки в HTTP?",
          "options": [
            "Набор пар ключ-значение, передающих метаданные запроса",
            "Тело ответа",
            "Стартовая строка ответа",
            "Метод запроса"
          ],
          "correctAnswer": "Набор пар ключ-значение, передающих метаданные запроса",
          "explanation": "Заголовки в HTTP — это набор пар ключ-значение, которые передают метаданные запроса, такие как `User-Agent` и `Content-Type`."
        },
        {
          "text": "Как отделяется тело ответа от заголовков в HTTP?",
          "options": [
            "С помощью пустой строки",
            "С помощью двоеточия",
            "С помощью запятой",
            "С помощью пробела"
          ],
          "correctAnswer": "С помощью пустой строки",
          "explanation": "Тело ответа отделяется от заголовков пустой строкой."
        },
        {
          "text": "Как выглядит raw запрос к главной странице Яндекса?",
          "options": [
            "GET / HTTP/1.1\nHost: ya.ru",
            "POST / HTTP/1.1\nHost: ya.ru",
            "GET ya.ru HTTP/1.1",
            "HEAD / HTTP/1.1\nHost: ya.ru"
          ],
          "correctAnswer": "GET / HTTP/1.1\nHost: ya.ru",
          "explanation": "Raw запрос к главной странице Яндекса выглядит как `GET / HTTP/1.1` с заголовком `Host: ya.ru`."
        },
        {
          "text": "Что означает метод GET в HTTP?",
          "options": [
            "Получить данные с сервера",
            "Отправить данные на сервер",
            "Удалить данные с сервера",
            "Обновить данные на сервере"
          ],
          "correctAnswer": "Получить данные с сервера",
          "explanation": "Метод GET используется для получения данных с сервера."
        },
        {
          "text": "Какой заголовок обязателен в HTTP запросе?",
          "options": [
            "User-Agent",
            "Host",
            "Content-Type",
            "Authorization"
          ],
          "correctAnswer": "Host",
          "explanation": "Заголовок `Host` должен быть всегда присутствовать в HTTP запросе."
        },
        {
          "text": "Как клиенту понять, удался запрос или нет?",
          "options": [
            "Проверить статус ответа",
            "Проверить заголовки ответа",
            "Проверить тело ответа",
            "Проверить время ответа"
          ],
          "correctAnswer": "Проверить статус ответа",
          "explanation": "Клиент может понять, удался ли запрос, проверив статус ответа, который делится на группы с различной семантикой."
        },
        {
          "text": "Что означает статус 2xx в HTTP?",
          "options": [
            "Запрос прошел успешно",
            "Ошибка по вине пользователя",
            "Ошибка по вине сервера",
            "Перенаправление на другой ресурс"
          ],
          "correctAnswer": "Запрос прошел успешно",
          "explanation": "Статусы 2xx указывают на то, что запрос был успешно обработан."
        },
        {
          "text": "Какой статус указывает на ошибку по вине пользователя?",
          "options": [
            "1xx",
            "2xx",
            "3xx",
            "4xx"
          ],
          "correctAnswer": "4xx",
          "explanation": "Статусы 4xx указывают на ошибки, произошедшие по вине пользователя, например, отсутствие прав доступа."
        },
        {
          "text": "Какой статус указывает на ошибку по вине сервера?",
          "options": [
            "3xx",
            "4xx",
            "5xx",
            "2xx"
          ],
          "correctAnswer": "5xx",
          "explanation": "Статусы 5xx указывают на ошибки, произошедшие по вине сервера, такие как ошибки в коде или конфигурации."
        },
        {
          "text": "Что нужно отправить браузеру, чтобы перенаправить на другую страницу?",
          "options": [
            "Статус 200 и заголовок Location",
            "Статус 301 или 302 и заголовок Location",
            "Только заголовок Location",
            "Статус 404 и заголовок Location"
          ],
          "correctAnswer": "Статус 301 или 302 и заголовок Location",
          "explanation": "Минимальный ответ для перенаправления должен содержать статус 301 или 302 и заголовок Location с адресом нового ресурса."
        },
        {
          "text": "Что указывает заголовок Location в HTTP ответе?",
          "options": [
            "Адрес ресурса, на который следует перейти",
            "Тип контента",
            "Статус ответа",
            "Время ответа"
          ],
          "correctAnswer": "Адрес ресурса, на который следует перейти",
          "explanation": "Заголовок Location указывает адрес ресурса, на который браузер должен перенаправить пользователя."
        },
        {
          "text": "Что можно разместить в теле ответа при перенаправлении?",
          "options": [
            "HTML со ссылкой на новый ресурс",
            "Только текст",
            "JSON данные",
            "Ничего, тело должно быть пустым"
          ],
          "correctAnswer": "HTML со ссылкой на новый ресурс",
          "explanation": "В теле ответа можно разместить HTML со ссылкой на новый ресурс для пользователей старых браузеров."
        },
        {
          "text": "Как управлять кешированием в HTTP?",
          "options": [
            "С помощью заголовков Cache и Cache-Control",
            "С помощью заголовков Content-Type",
            "С помощью заголовков User-Agent",
            "Кеширование невозможно в HTTP"
          ],
          "correctAnswer": "С помощью заголовков Cache и Cache-Control",
          "explanation": "Заголовки Cache и Cache-Control регулируют время жизни, политику обновления и поведение прокси-сервера."
        },
        {
          "text": "Что делают заголовки Last-Modified и If-Modified-Since?",
          "options": [
            "Регулируют кеширование по времени",
            "Указывают тип контента",
            "Определяют статус ответа",
            "Управляют авторизацией"
          ],
          "correctAnswer": "Регулируют кеширование по времени",
          "explanation": "Эти заголовки задают кеширование в зависимости от даты обновления документа."
        },
        {
          "text": "Что такое Etag в HTTP?",
          "options": [
            "Заголовок для кеширования документа по его уникальному хешу",
            "Заголовок для указания типа контента",
            "Заголовок для управления сессиями",
            "Заголовок для авторизации"
          ],
          "correctAnswer": "Заголовок для кеширования документа по его уникальному хешу",
          "explanation": "Etag используется для кеширования документа, позволяя серверу определить, изменился ли документ."
        },
        {
          "text": "Как кэшируются файлы на уровне протокола?",
          "options": [
            "С помощью заголовка Etag и MD5-хеша файла",
            "С помощью заголовка Cache-Control",
            "С помощью заголовка Last-Modified",
            "Кэширование невозможно на уровне протокола"
          ],
          "correctAnswer": "С помощью заголовка Etag и MD5-хеша файла",
          "explanation": "Когда Nginx отдает статичный файл, он добавляет заголовок Etag, который содержит MD5-хеш файла."
        },
        {
          "text": "Что происходит, если хеш файла не совпадает при запросе?",
          "options": [
            "Сервер отвечает с кодом 200 и отправляет актуальный файл",
            "Сервер отвечает с кодом 304 Not Modified",
            "Сервер игнорирует запрос",
            "Сервер отправляет ошибку 404"
          ],
          "correctAnswer": "Сервер отвечает с кодом 200 и отправляет актуальный файл",
          "explanation": "Если хеши не совпадают, сервер отвечает с кодом 200 и отправляет актуальный файл с новым хешем."
        },
        {
          "text": "Что происходит, если хеши равны при запросе файла?",
          "options": [
            "Сервер отвечает с кодом 200 и отправляет актуальный файл",
            "Сервер отвечает с кодом 304 Not Modified с пустым телом",
            "Сервер отправляет ошибку 404",
            "Сервер игнорирует запрос"
          ],
          "correctAnswer": "Сервер отвечает с кодом 304 Not Modified с пустым телом",
          "explanation": "Если хеши равны, сервер отвечает с кодом 304 Not Modified, и браузер использует локальную копию файла."
        },
        {
          "text": "Что такое HTTP?",
          "options": [
            "Протокол передачи гипертекста",
            "Протокол передачи данных",
            "Протокол для обмена сообщениями",
            "Все вышеперечисленное"
          ],
          "correctAnswer": "Все вышеперечисленное",
          "explanation": "HTTP (HyperText Transfer Protocol) — это широко распространённый протокол передачи данных, предназначенный для передачи гипертекстовых документов."
        },
        {
          "text": "На каком уровне модели OSI находится протокол HTTP?",
          "options": [
            "На прикладном (7-м) уровне",
            "На транспортном (4-м) уровне",
            "На сетевом (3-м) уровне",
            "На канальном (2-м) уровне"
          ],
          "correctAnswer": "На прикладном (7-м) уровне",
          "explanation": "HTTP является протоколом прикладного уровня в соответствии со спецификацией OSI."
        },
        {
          "text": "Какова основная задача протокола HTTP?",
          "options": [
            "Обмен данными между клиентом и сервером",
            "Передача файлов",
            "Управление сессиями",
            "Шифрование данных"
          ],
          "correctAnswer": "Обмен данными между клиентом и сервером",
          "explanation": "Основная задача HTTP — обмен данными между клиентским приложением (например, веб-браузером) и веб-сервером."
        },
        {
          "text": "Какую версию протокола описывает спецификация RFC 2616?",
          "options": [
            "HTTP 1.0",
            "HTTP 1.1",
            "HTTP 2.0",
            "HTTP 3.0"
          ],
          "correctAnswer": "HTTP 1.1",
          "explanation": "Спецификация RFC 2616 описывает актуальную на данный момент версию протокола HTTP 1.1."
        }
      ]
    },
    {
      "id": "oop",
      "name": "ООП",
      "description": "Вопросы по объектно-ориентированному программированию.",
      "questions": [
        {
          "text": "Что такое инкапсуляция?",
          "options": [
            "Сокрытие данных и методов в объекте",
            "Объединение данных и методов в единый объект",
            "Процесс создания объектов",
            "Наследование свойств от родительского класса"
          ],
          "correctAnswer": "Объединение данных и методов в единый объект",
          "explanation": "Инкапсуляция — это механизм, позволяющий объединить данные и методы, работающие с этими данными, в единый объект и скрыть детали реализации от пользователя."
        },
        {
          "text": "Какова основная цель инкапсуляции?",
          "options": [
            "Сокрытие данных",
            "Сбор знаний о сущности в одном месте",
            "Упрощение кода",
            "Увеличение производительности"
          ],
          "correctAnswer": "Сбор знаний о сущности в одном месте",
          "explanation": "Основное назначение инкапсуляции — собрать в одном месте знания, относящиеся к устройству некой сущности и правилам обращения с ней."
        },
        {
          "text": "Как инкапсуляция помогает избежать размазывания знаний?",
          "options": [
            "Скрывает детали реализации",
            "Упрощает код",
            "Увеличивает скорость выполнения",
            "Снижает количество ошибок"
          ],
          "correctAnswer": "Скрывает детали реализации",
          "explanation": "Инкапсуляция помогает собрать все знания о реализации в одном месте, что предотвращает размазывание этих знаний по всему коду."
        },
        {
          "text": "Что такое сокрытие данных?",
          "options": [
            "Сокрытие методов от пользователя",
            "Защита данных от несанкционированного доступа",
            "Удаление данных из объекта",
            "Сокрытие объектов в памяти"
          ],
          "correctAnswer": "Защита данных от несанкционированного доступа",
          "explanation": "Сокрытие данных — это процесс, при котором данные защищаются от несанкционированного доступа, что является частью инкапсуляции."
        },
        {
          "text": "Что такое наследование в ООП?",
          "options": [
            "Механизм, позволяющий описывать новый класс на основе существующего",
            "Процесс создания объектов",
            "Способ сокрытия данных",
            "Метод для работы с массивами"
          ],
          "correctAnswer": "Механизм, позволяющий описывать новый класс на основе существующего",
          "explanation": "Наследование — это механизм языка, который позволяет создавать новый класс на основе уже существующего."
        },
        {
          "text": "Почему наследование может быть вредным в ООП?",
          "options": [
            "Потому что оно приводит к сильному связыванию",
            "Потому что оно усложняет код",
            "Потому что оно не поддерживает полиморфизм",
            "Потому что оно не позволяет создавать объекты"
          ],
          "correctAnswer": "Потому что оно приводит к сильному связыванию",
          "explanation": "В 'истинном' ООП наследование может быть причиной сильного связывания, что делает код менее гибким."
        },
        {
          "text": "Что предпочтительнее использовать вместо наследования?",
          "options": [
            "Композицию",
            "Абстракцию",
            "Инкапсуляцию",
            "Полиморфизм"
          ],
          "correctAnswer": "Композицию",
          "explanation": "Композиция предпочтительнее наследования, так как она обеспечивает большую гибкость и уменьшает связывание."
        },
        {
          "text": "Что такое полиморфизм в ООП?",
          "options": [
            "Способность объектов разных классов обрабатывать данные разных типов",
            "Способность одного класса наследовать свойства другого",
            "Способность класса скрывать свои данные",
            "Способность класса создавать экземпляры"
          ],
          "correctAnswer": "Способность объектов разных классов обрабатывать данные разных типов",
          "explanation": "Полиморфизм — это возможность схожим типам данных, которые заданы иерархией наследования, иметь различные реализации."
        },
        {
          "text": "Какие формы полиморфизма существуют?",
          "options": [
            "Специальный, параметрический, полиморфизм подтипов",
            "Наследование, инкапсуляция, абстракция",
            "Перегрузка, переопределение, композиция",
            "Только перегрузка методов"
          ],
          "correctAnswer": "Специальный, параметрический, полиморфизм подтипов",
          "explanation": "Полиморфизм имеет несколько форм: специальный (Ad-Hoc), параметрический и полиморфизм подтипов."
        },
        {
          "text": "Что такое полиморфизм подтипов?",
          "options": [
            "Способность функции обрабатывать данные разных типов",
            "Способность объектов одного класса иметь разные реализации",
            "Способность класса наследовать свойства другого класса",
            "Способность метода изменять свое поведение в зависимости от типа данных"
          ],
          "correctAnswer": "Способность объектов одного класса иметь разные реализации",
          "explanation": "Полиморфизм подтипов достигается с помощью механизмов наследования и апкаста, позволяя объектам одного класса иметь разные реализации."
        },
        {
          "text": "Что такое абстракция в ООП?",
          "options": [
            "Выделение важных характеристик объекта",
            "Сокрытие данных и методов",
            "Создание экземпляров классов",
            "Наследование свойств от родительского класса"
          ],
          "correctAnswer": "Выделение важных характеристик объекта",
          "explanation": "Абстракция — это процесс выделения важных характеристик объекта, позволяющий определить минимально необходимый набор этих характеристик для решения задачи."
        },
        {
          "text": "С чем часто путают абстракцию?",
          "options": [
            "С наследованием",
            "С инкапсуляцией",
            "С полиморфизмом",
            "С композицией"
          ],
          "correctAnswer": "С инкапсуляцией",
          "explanation": "Абстракцию часто путают с инкапсуляцией, так как обе концепции влияют на формирование публичного интерфейса типа."
        },
        {
          "text": "Какова основная цель абстракции?",
          "options": [
            "Сокрытие данных",
            "Определение минимально необходимого набора характеристик",
            "Создание интерфейсов",
            "Упрощение кода"
          ],
          "correctAnswer": "Определение минимально необходимого набора характеристик",
          "explanation": "Цель абстракции — выделить важные характеристики объекта, необходимые для решения поставленной задачи."
        }
      ]
    },
    {
      "id": "programming_principles",
      "name": "Принципы программирования",
      "description": "Вопросы по основным принципам программирования.",
      "questions": [
        {
          "text": "Что означает принцип KISS?",
          "options": [
            "Keep It Simple, Stupid",
            "Keep It Short and Simple",
            "Keep It Smart and Simple",
            "Keep It Simple and Safe"
          ],
          "correctAnswer": "Keep It Simple, Stupid",
          "explanation": "Принцип KISS (Keep It Simple, Stupid) призывает к тому, чтобы код оставался как можно более простым."
        },
        {
          "text": "Какой подход нарушает принцип KISS?",
          "options": [
            "Использование простых и понятных решений",
            "Написание сложных и хитроумных функций",
            "Оптимизация кода для повышения производительности",
            "Соблюдение стандартов кодирования"
          ],
          "correctAnswer": "Написание сложных и хитроумных функций",
          "explanation": "Нарушение принципа KISS происходит, когда код становится сложным и трудным для понимания, например, написание отдельной функции только для сложения."
        },
        {
          "text": "Почему важно следовать принципу KISS?",
          "options": [
            "Чтобы код был более эффективным",
            "Чтобы код был проще для понимания и поддержки",
            "Чтобы избежать использования комментариев",
            "Чтобы код был более сложным"
          ],
          "correctAnswer": "Чтобы код был проще для понимания и поддержки",
          "explanation": "Следование принципу KISS помогает сделать код более простым и понятным, что облегчает его поддержку."
        },
        {
          "text": "Что означает принцип DRY?",
          "options": [
            "Don't Repeat Yourself",
            "Do Repeat Yourself",
            "Don't Run Yourself",
            "Do Run Yourself"
          ],
          "correctAnswer": "Don't Repeat Yourself",
          "explanation": "Принцип DRY (Don't Repeat Yourself) напоминает о том, что повторяющееся поведение в коде следует обособлять для многократного использования."
        },
        {
          "text": "Почему важно следовать принципу DRY?",
          "options": [
            "Чтобы уменьшить размер программы",
            "Чтобы избежать рассинхронизации и багов",
            "Чтобы сделать код более сложным",
            "Чтобы увеличить количество повторяющегося кода"
          ],
          "correctAnswer": "Чтобы избежать рассинхронизации и багов",
          "explanation": "Следование принципу DRY помогает избежать дублирования кода, что может привести к ошибкам и увеличению размера программы."
        },
        {
          "text": "Как можно реализовать принцип DRY в коде?",
          "options": [
            "Выделяя повторяющиеся фрагменты в отдельные функции",
            "Копируя и вставляя код в разных местах",
            "Игнорируя повторяющийся код",
            "Создавая больше классов"
          ],
          "correctAnswer": "Выделяя повторяющиеся фрагменты в отдельные функции",
          "explanation": "Реализация принципа DRY включает выделение повторяющихся фрагментов кода в отдельные функции для многократного использования."
        },
        {
          "text": "Что означает принцип YAGNI?",
          "options": [
            "You Aren't Gonna Need It",
            "You Are Gonna Need It",
            "You Always Get New Ideas",
            "You Are Gonna Neglect It"
          ],
          "correctAnswer": "You Aren't Gonna Need It",
          "explanation": "Принцип YAGNI (You Aren't Gonna Need It) говорит о том, что не следует оставлять в коде ненужные точки расширения."
        },
        {
          "text": "Почему нежелательно оставлять точки расширения в коде?",
          "options": [
            "Они увеличивают размер кодовой базы и вносят ненужную сложность",
            "Они делают код более простым",
            "Они необходимы для тестирования",
            "Они улучшают производительность"
          ],
          "correctAnswer": "Они увеличивают размер кодовой базы и вносят ненужную сложность",
          "explanation": "Точки расширения могут усложнить код и увеличить его размер, что нежелательно."
        },
        {
          "text": "Когда следует игнорировать принцип YAGNI?",
          "options": [
            "Когда речь идет о заказанном функционале",
            "Когда код уже написан",
            "Когда проект завершен",
            "Когда нет времени на изменения"
          ],
          "correctAnswer": "Когда речь идет о заказанном функционале",
          "explanation": "Принцип YAGNI не применяется, если функционал уже заказан и необходим для проекта."
        },
        {
          "text": "Что означает аббревиатура SOLID?",
          "options": [
            "Принципы объектно-ориентированного программирования",
            "Принципы структурного программирования",
            "Принципы функционального программирования",
            "Принципы модульного программирования"
          ],
          "correctAnswer": "Принципы объектно-ориентированного программирования",
          "explanation": "SOLID — это аббревиатура от пяти принципов, способствующих созданию хорошего объектно-ориентированного кода."
        },
        {
          "text": "Какой принцип SOLID гласит, что каждый класс должен решать лишь одну задачу?",
          "options": [
            "Open-Closed Principle",
            "Single Responsibility Principle",
            "Liskov Substitution Principle",
            "Dependency Inversion Principle"
          ],
          "correctAnswer": "Single Responsibility Principle",
          "explanation": "Принцип единственной ответственности (Single Responsibility Principle) утверждает, что каждый класс должен решать лишь одну задачу."
        },
        {
          "text": "Какой принцип SOLID говорит о том, что программные сущности должны быть открыты для расширения, но не для модификации?",
          "options": [
            "Interface Segregation Principle",
            "Open-Closed Principle",
            "Dependency Inversion Principle",
            "Liskov Substitution Principle"
          ],
          "correctAnswer": "Open-Closed Principle",
          "explanation": "Принцип открытости-закрытости (Open-Closed Principle) гласит, что программные сущности должны быть открыты для расширения, но не для модификации."
        },
        {
          "text": "Какой принцип SOLID требует, чтобы подклассы могли служить заменой для своих суперклассов?",
          "options": [
            "Single Responsibility Principle",
            "Liskov Substitution Principle",
            "Dependency Inversion Principle",
            "Open-Closed Principle"
          ],
          "correctAnswer": "Liskov Substitution Principle",
          "explanation": "Принцип подстановки Барбары Лисков (Liskov Substitution Principle) требует, чтобы подклассы могли служить заменой для своих суперклассов."
        },
        {
          "text": "Какой принцип SOLID говорит о создании узкоспециализированных интерфейсов?",
          "options": [
            "Dependency Inversion Principle",
            "Interface Segregation Principle",
            "Single Responsibility Principle",
            "Open-Closed Principle"
          ],
          "correctAnswer": "Interface Segregation Principle",
          "explanation": "Принцип разделения интерфейса (Interface Segregation Principle) говорит о создании узкоспециализированных интерфейсов, предназначенных для конкретного клиента."
        },
        {
          "text": "Какой принцип SOLID утверждает, что объектом зависимости должна быть абстракция?",
          "options": [
            "Dependency Inversion Principle",
            "Single Responsibility Principle",
            "Open-Closed Principle",
            "Liskov Substitution Principle"
          ],
          "correctAnswer": "Dependency Inversion Principle",
          "explanation": "Принцип инверсии зависимостей (Dependency Inversion Principle) утверждает, что объектом зависимости должна быть абстракция, а не что-то конкретное."
        }
      ]
    },
    {
      "id": "general_questions",
      "name": "Общие вопросы",
      "description": "Вопросы по общим концепциям программирования.",
      "questions": [
        {
          "text": "Что такое связанность модулей (coupling)?",
          "options": [
            "Степень независимости модулей",
            "Степень зависимости модулей",
            "Степень сложности кода",
            "Степень производительности системы"
          ],
          "correctAnswer": "Степень зависимости модулей",
          "explanation": "Связанность модулей (coupling) характеризует степень зависимости модулей друг от друга."
        },
        {
          "text": "Какова цель минимизации связанности модулей?",
          "options": [
            "Увеличение производительности",
            "Упрощение кода",
            "Снижение зависимости между модулями",
            "Увеличение сложности системы"
          ],
          "correctAnswer": "Снижение зависимости между модулями",
          "explanation": "При проектировании систем необходимо стремиться к минимизации зависимости между модулями."
        },
        {
          "text": "Что такое связность (cohesion)?",
          "options": [
            "Степень независимости модулей",
            "Степень сложности кода",
            "Целостность и «плотность» модуля",
            "Степень производительности системы"
          ],
          "correctAnswer": "Целостность и «плотность» модуля",
          "explanation": "Связность (cohesion) характеризует целостность и «плотность» модуля, т.е. насколько модуль является простым с точки зрения его использования."
        },
        {
          "text": "Какой пример модуля имеет максимальную связность?",
          "options": [
            "Модуль проверки орфографии",
            "Модуль для работы с базами данных",
            "Модуль для обработки изображений",
            "Модуль для управления пользователями"
          ],
          "correctAnswer": "Модуль проверки орфографии",
          "explanation": "Примером модуля с максимальной связностью является модуль проверки орфографии, который выполняет одну единственную функцию."
        },
        {
          "text": "Что такое LRU кэш?",
          "options": [
            "Алгоритм, который вытесняет наименее недавно использованные значения",
            "Алгоритм, который хранит все значения в памяти",
            "Алгоритм, который использует наибольшее количество ресурсов",
            "Алгоритм, который всегда сохраняет последние значения"
          ],
          "correctAnswer": "Алгоритм, который вытесняет наименее недавно использованные значения",
          "explanation": "LRU (least recently used) — это алгоритм, при котором вытесняются значения, которые дольше всего не запрашивались."
        },
        {
          "text": "Как работает алгоритм LRU?",
          "options": [
            "Хранит время последнего запроса к значению",
            "Удаляет все значения из кэша",
            "Сохраняет только самые новые значения",
            "Не требует хранения времени запросов"
          ],
          "correctAnswer": "Хранит время последнего запроса к значению",
          "explanation": "Для работы алгоритма LRU необходимо хранить время последнего запроса к каждому значению."
        },
        {
          "text": "Что происходит, когда число закэшированных значений превосходит N в LRU кэше?",
          "options": [
            "Вытесняется значение, которое дольше всего не запрашивалось",
            "Все значения остаются в кэше",
            "Новые значения не могут быть добавлены",
            "Кэш очищается полностью"
          ],
          "correctAnswer": "Вытесняется значение, которое дольше всего не запрашивалось",
          "explanation": "Когда число закэшированных значений превышает N, вытесняется значение, которое дольше всего не запрашивалось."
        },
        {
          "text": "Что такое очереди сообщений (MQ)?",
          "options": [
            "Структура данных для хранения сообщений",
            "Связующее звено между различными процессами",
            "Метод обработки данных",
            "Протокол передачи данных"
          ],
          "correctAnswer": "Связующее звено между различными процессами",
          "explanation": "Очереди сообщений (MQ) являются связующим звеном между различными процессами в приложениях и обеспечивают надежный интерфейс взаимодействия."
        },
        {
          "text": "Какова основная дисциплина доступа к элементам в очереди?",
          "options": [
            "Первый пришёл — первый вышел (FIFO)",
            "Последний пришёл — первый вышел (LIFO)",
            "Случайный доступ",
            "Доступ по индексу"
          ],
          "correctAnswer": "Первый пришёл — первый вышел (FIFO)",
          "explanation": "Очередь — это структура данных с дисциплиной доступа «первый пришёл — первый вышел»."
        },
        {
          "text": "Какую функцию выполняют очереди сообщений в архитектуре приложений?",
          "options": [
            "Создают неявные интерфейсы обмена данными",
            "Увеличивают сложность системы",
            "Уменьшают производительность",
            "Сохраняют все данные в памяти"
          ],
          "correctAnswer": "Создают неявные интерфейсы обмена данными",
          "explanation": "Очереди сообщений создают неявные интерфейсы обмена данными, позволяя процессам быть независимыми друг от друга."
        },
        {
          "text": "Как очереди сообщений помогают в случае пиковой нагрузки?",
          "options": [
            "Служат буфером для накопления данных",
            "Удаляют старые сообщения",
            "Увеличивают скорость обработки",
            "Снижают объем данных"
          ],
          "correctAnswer": "Служат буфером для накопления данных",
          "explanation": "Очереди сообщений могут выполнять роль буфера для накопления данных в случае пиковой нагрузки, смягчая нагрузку на систему."
        },
        {
          "text": "Какую гарантию предоставляет использование очередей сообщений?",
          "options": [
            "Гарантированная доставка сообщений",
            "Гарантированная потеря сообщений",
            "Гарантированное удаление сообщений",
            "Гарантированная задержка сообщений"
          ],
          "correctAnswer": "Гарантированная доставка сообщений",
          "explanation": "Использование очереди сообщений гарантирует, что сообщение будет доставлено и обработано в любом случае."
        },
        {
          "text": "Какие готовые реализации MQ вы знаете?",
          "options": [
            "RabbitMQ, ActiveMQ, Kafka, Redis, ZeroMQ, RocketMQ",
            "MySQL, PostgreSQL, MongoDB",
            "Django, Flask, Express",
            "HTML, CSS, JavaScript"
          ],
          "correctAnswer": "RabbitMQ, ActiveMQ, Kafka, Redis, ZeroMQ, RocketMQ",
          "explanation": "Существуют различные реализации MQ, такие как RabbitMQ, ActiveMQ, Kafka, Redis, ZeroMQ и RocketMQ."
        },
        {
          "text": "Какой из следующих вариантов является реализацией очереди сообщений?",
          "options": [
            "RabbitMQ",
            "HTML",
            "CSS",
            "Java"
          ],
          "correctAnswer": "RabbitMQ",
          "explanation": "RabbitMQ — это реализация очереди сообщений, которая поддерживает различные протоколы обмена сообщениями."
        },
        {
          "text": "Какой из следующих инструментов используется для обработки потоков данных?",
          "options": [
            "Kafka",
            "Photoshop",
            "Excel",
            "Notepad"
          ],
          "correctAnswer": "Kafka",
          "explanation": "Kafka — это система для обработки потоков данных и обмена сообщениями."
        },
        {
          "text": "Что такое RPC?",
          "options": [
            "Удалённый вызов процедур",
            "Локальный вызов процедур",
            "Синхронный вызов функций",
            "Асинхронный вызов функций"
          ],
          "correctAnswer": "Удалённый вызов процедур",
          "explanation": "RPC (Remote Procedure Call) — это класс технологий, позволяющих программам вызывать функции в другом адресном пространстве."
        },
        {
          "text": "Какие протоколы обычно используются на транспортном уровне для RPC?",
          "options": [
            "TCP и UDP",
            "HTTP и FTP",
            "SMTP и IMAP",
            "SSH и Telnet"
          ],
          "correctAnswer": "TCP и UDP",
          "explanation": "На транспортном уровне RPC обычно использует протоколы TCP и UDP."
        },
        {
          "text": "Каковы характерные черты вызова удалённых процедур?",
          "options": [
            "Асимметричность и синхронность",
            "Симметричность и асинхронность",
            "Локальность и синхронность",
            "Асинхронность и многопоточность"
          ],
          "correctAnswer": "Асимметричность и синхронность",
          "explanation": "Характерными чертами RPC являются асимметричность и синхронность, где одна сторона является инициатором."
        },
        {
          "text": "Что такое gRPC?",
          "options": [
            "Фреймворк для удалённого вызова процедур от Google",
            "Протокол передачи данных",
            "Система управления базами данных",
            "Язык программирования"
          ],
          "correctAnswer": "Фреймворк для удалённого вызова процедур от Google",
          "explanation": "gRPC — это высокопроизводительный фреймворк, разработанный компанией Google для вызова удалённых процедур (RPC), работающий поверх HTTP/2."
        },
        {
          "text": "Какой протокол использует gRPC для передачи данных?",
          "options": [
            "HTTP/1.1",
            "HTTP/2",
            "TCP",
            "UDP"
          ],
          "correctAnswer": "HTTP/2",
          "explanation": "gRPC работает поверх HTTP/2, что обеспечивает высокую производительность и множество возможностей."
        },
        {
          "text": "Какой инструмент gRPC использует для описания типов данных и сериализации?",
          "options": [
            "JSON",
            "XML",
            "Protobuf",
            "YAML"
          ],
          "correctAnswer": "Protobuf",
          "explanation": "gRPC использует Protobuf в качестве инструмента описания типов данных и сериализации."
        },
        {
          "text": "Какое преимущество предоставляет gRPC в сравнении с REST?",
          "options": [
            "Гарантированная доставка сообщений",
            "Поддержка асинхронной обработки",
            "Быстрая работа с данными",
            "Поддержка только одного языка программирования"
          ],
          "correctAnswer": "Быстрая работа с данными",
          "explanation": "gRPC обеспечивает высокую производительность, что позволяет быстрее обрабатывать данные по сравнению с REST."
        },
        {
          "text": "Сколько языков программирования поддерживает gRPC?",
          "options": [
            "5",
            "9",
            "10",
            "15"
          ],
          "correctAnswer": "9",
          "explanation": "gRPC поддерживает 9 языков программирования, включая C, C++, Java, Go, Node.js, Python, Ruby, Objective-C, PHP и C#."
        }
      ]
    },
    {
      "id": "frontend",
      "name": "Frontend",
      "description": "Вопросы по фронтенд-разработке.",
      "questions": [
        {
          "text": "Что такое куки?",
          "options": [
            "Информация, сохраняемая на компьютере веб-сайтом",
            "Тип базы данных",
            "Файл на сервере",
            "Скрипт на стороне сервера"
          ],
          "correctAnswer": "Информация, сохраняемая на компьютере веб-сайтом",
          "explanation": "Куки — это информация, сохраняемая на компьютере веб-сайтом, которая позволяет запоминать настройки и предпочтения пользователя."
        },
        {
          "text": "Зачем используются куки?",
          "options": [
            "Для хранения настроек веб-сайта",
            "Для увеличения скорости загрузки",
            "Для защиты данных",
            "Для создания баз данных"
          ],
          "correctAnswer": "Для хранения настроек веб-сайта",
          "explanation": "Куки часто хранят настройки для веб-сайта, такие как предпочитаемый язык или местоположение."
        },
        {
          "text": "Где хранятся куки?",
          "options": [
            "На сервере",
            "В браузере",
            "В базе данных",
            "На компьютере пользователя"
          ],
          "correctAnswer": "В браузере",
          "explanation": "Куки хранятся в браузере пользователя."
        },
        {
          "text": "Как можно работать с куками в Django?",
          "options": [
            "Используя request.COOKIES и response.set_cookie",
            "Используя document.cookie",
            "Используя localStorage",
            "Используя sessionStorage"
          ],
          "correctAnswer": "Используя request.COOKIES и response.set_cookie",
          "explanation": "В Django можно работать с куками через request.COOKIES и response.set_cookie."
        },
        {
          "text": "Как можно работать с куками в JavaScript?",
          "options": [
            "Используя document.cookie",
            "Используя request.COOKIES",
            "Используя localStorage",
            "Используя sessionStorage"
          ],
          "correctAnswer": "Используя document.cookie",
          "explanation": "В JavaScript куки можно обрабатывать с помощью document.cookie, если не установлен флаг HTTPONLY."
        },
        {
          "text": "Может ли сервер изменить (добавить, удалить) куки?",
          "options": [
            "Да, сервер может изменить куки",
            "Нет, куки могут изменяться только клиентом",
            "Сервер может только удалять куки",
            "Сервер не имеет доступа к кукам"
          ],
          "correctAnswer": "Да, сервер может изменить куки",
          "explanation": "Сервер может изменить значение куки, отправляя новые строки Set-Cookie: name=newvalue, после чего браузер заменяет старое куки с тем же name на новое значение."
        },
        {
          "text": "Что такое JWT (JSON Web Token)?",
          "options": [
            "Стандартизированный формат упаковки данных для безопасной передачи",
            "Формат изображения",
            "Тип базы данных",
            "Протокол передачи данных"
          ],
          "correctAnswer": "Стандартизированный формат упаковки данных для безопасной передачи",
          "explanation": "JWT (JSON Web Token) представляет собой стандартизированный формат упаковки данных, используемый для безопасной передачи информации между двумя сторонами."
        },
        {
          "text": "Какую структуру информации определяет JWT?",
          "options": [
            "Сериализованную и десериализованную",
            "Только сериализованную",
            "Только десериализованную",
            "Текстовую и бинарную"
          ],
          "correctAnswer": "Сериализованную и десериализованную",
          "explanation": "JWT определяет структуру информации, представленную в сериализованной и десериализованной формах."
        },
        {
          "text": "Для чего используется сериализованная форма JWT?",
          "options": [
            "Для передачи данных с запросами и ответами",
            "Для хранения данных",
            "Для шифрования данных",
            "Для создания баз данных"
          ],
          "correctAnswer": "Для передачи данных с запросами и ответами",
          "explanation": "Сериализованная форма JWT используется непосредственно для передачи данных с запросами и ответами."
        }
      ]
    },
    {
      "id": "sdlc",
      "name": "SDLC",
      "description": "Вопросы по жизненному циклу разработки программного обеспечения.",
      "questions": [
        {
          "text": "Что такое Agile?",
          "options": [
            "Методология разработки программного обеспечения",
            "Тип базы данных",
            "Язык программирования",
            "Система управления проектами"
          ],
          "correctAnswer": "Методология разработки программного обеспечения",
          "explanation": "Agile — это методология разработки программного обеспечения, которая акцентирует внимание на гибкости и адаптивности в процессе разработки."
        },
        {
          "text": "Что такое Scrum?",
          "options": [
            "Методология управления проектами в Agile",
            "Тип программного обеспечения",
            "Язык программирования",
            "Система контроля версий"
          ],
          "correctAnswer": "Методология управления проектами в Agile",
          "explanation": "Scrum — это методология управления проектами, которая используется в рамках Agile для организации работы команд."
        },
        {
          "text": "Какова основная цель Agile/Scrum?",
          "options": [
            "Увеличение гибкости и скорости разработки",
            "Снижение затрат на проект",
            "Увеличение количества документации",
            "Снижение качества продукта"
          ],
          "correctAnswer": "Увеличение гибкости и скорости разработки",
          "explanation": "Основная цель Agile/Scrum — увеличить гибкость и скорость разработки, позволяя командам быстро адаптироваться к изменениям."
        },
        {
          "text": "Что такое непрерывная интеграция (CI)?",
          "options": [
            "Процесс автоматического развертывания в продакшен",
            "Процесс автоматизации сборки и тестирования кода",
            "Процесс управления проектами",
            "Процесс документирования кода"
          ],
          "correctAnswer": "Процесс автоматизации сборки и тестирования кода",
          "explanation": "Непрерывная интеграция (CI) заключается в автоматизации сборки и тестирования кода после каждого слияния изменений в центральный репозиторий."
        },
        {
          "text": "Что такое непрерывная доставка (CD)?",
          "options": [
            "Автоматизация процесса релиза ПО",
            "Процесс тестирования кода",
            "Процесс управления версиями",
            "Процесс документирования"
          ],
          "correctAnswer": "Автоматизация процесса релиза ПО",
          "explanation": "Непрерывная доставка (CD) — это практика автоматизации всего процесса релиза программного обеспечения."
        },
        {
          "text": "Какова основная разница между непрерывной доставкой и непрерывным развертыванием?",
          "options": [
            "Непрерывная доставка требует ручного развертывания, а непрерывное развертывание — автоматического",
            "Непрерывная доставка не требует тестирования, а непрерывное развертывание требует",
            "Непрерывная доставка — это только для веб-приложений, а непрерывное развертывание — для мобильных",
            "Непрерывная доставка не требует CI, а непрерывное развертывание требует"
          ],
          "correctAnswer": "Непрерывная доставка требует ручного развертывания, а непрерывное развертывание — автоматического",
          "explanation": "Непрерывная доставка включает ручное развертывание, тогда как непрерывное развертывание автоматически развертывает изменения в продакшен."
        },
        {
          "text": "Какова основная цель непрерывного развертывания?",
          "options": [
            "Автоматизация всех процессов разработки",
            "Полностью автоматизированное развертывание в продакшен",
            "Увеличение времени на тестирование",
            "Снижение качества кода"
          ],
          "correctAnswer": "Полностью автоматизированное развертывание в продакшен",
          "explanation": "Непрерывное развертывание предполагает автоматическое развертывание всех изменений в продакшен без явного одобрения разработчика."
        },
        {
          "text": "В чем основная разница между Scrum и Kanban?",
          "options": [
            "В длине итераций",
            "В количестве участников команды",
            "В используемых инструментах",
            "В типах документации"
          ],
          "correctAnswer": "В длине итераций",
          "explanation": "Основная разница между Scrum и Kanban заключается в длине итераций: в Scrum итерации составляют 2-3 недели, в Kanban задачи можно менять каждый день."
        },
        {
          "text": "Каковы итерации в Scrum?",
          "options": [
            "Долгосрочные",
            "Короткие, обычно 2-3 недели",
            "Неопределенные",
            "Каждый день"
          ],
          "correctAnswer": "Короткие, обычно 2-3 недели",
          "explanation": "В Scrum итерации, называемые спринтами, обычно составляют 2-3 недели."
        },
        {
          "text": "Как в Scrum оцениваются задачи?",
          "options": [
            "В Story points или часах",
            "В процентах",
            "Не оцениваются",
            "В днях"
          ],
          "correctAnswer": "В Story points или часах",
          "explanation": "В Scrum задачи принято оценивать в Story points или в часах, что позволяет сформировать спринт."
        },
        {
          "text": "Как в Kanban оцениваются задачи?",
          "options": [
            "Не оцениваются, это опционально",
            "В Story points",
            "В часах",
            "В процентах"
          ],
          "correctAnswer": "Не оцениваются, это опционально",
          "explanation": "В Kanban не принято делать оценку задач, это опционально и зависит от команды."
        },
        {
          "text": "Какова цель Scrum?",
          "options": [
            "Закончить спринт",
            "Завершить задачу",
            "Увеличить скорость работы команды",
            "Собрать больше информации"
          ],
          "correctAnswer": "Закончить спринт",
          "explanation": "В Scrum основная цель — закончить спринт, в то время как в Kanban — завершить задачу."
        },
        {
          "text": "Что такое технический долг (Code Debt)?",
          "options": [
            "Осознанное компромиссное решение в разработке",
            "Ошибка в коде",
            "Неправильная архитектура",
            "Отсутствие документации"
          ],
          "correctAnswer": "Осознанное компромиссное решение в разработке",
          "explanation": "Технический долг — это осознанное компромиссное решение, когда разработчики понимают преимущества быстрого, но не идеального решения."
        },
        {
          "text": "Каковы основные стратегии управления техническим долгом?",
          "options": [
            "Переписывание кода с нуля, рефакторинг, смирение с долгом",
            "Игнорирование кода, добавление новых функций",
            "Увеличение команды разработчиков",
            "Сокращение времени на тестирование"
          ],
          "correctAnswer": "Переписывание кода с нуля, рефакторинг, смирение с долгом",
          "explanation": "Основные стратегии управления техническим долгом включают переписывание кода с нуля, постепенный рефакторинг и смирение с долгом."
        },
        {
          "text": "Как можно уменьшить технический долг на этапе создания продукта?",
          "options": [
            "Создавать одноразовые прототипы и четко определять завершенность задач",
            "Игнорировать тестирование",
            "Сокращать время разработки",
            "Увеличивать количество функций"
          ],
          "correctAnswer": "Создавать одноразовые прототипы и четко определять завершенность задач",
          "explanation": "Уменьшить технический долг можно, создавая одноразовые прототипы и устанавливая четкие метрики качества."
        },
        {
          "text": "Что такое 'definition of done' в контексте управления техническим долгом?",
          "options": [
            "Определение завершенности задачи с учетом качества",
            "Список всех функций приложения",
            "Документация по проекту",
            "Список ошибок в коде"
          ],
          "correctAnswer": "Определение завершенности задачи с учетом качества",
          "explanation": "'Definition of done' — это четкое определение завершенности задачи, включая метрики качества, что помогает избежать накопления технического долга."
        }
      ]
    },
    {
      "id": "vcs",
      "name": "VCS",
      "description": "Вопросы по системам контроля версий.",
      "questions": [
        {
          "text": "Что такое Git Flow?",
          "options": [
            "Методология работы с Git, использующая несколько веток",
            "Тип базы данных",
            "Язык программирования",
            "Система управления проектами"
          ],
          "correctAnswer": "Методология работы с Git, использующая несколько веток",
          "explanation": "Git Flow — это методология работы с Git, которая использует несколько веток для управления разработкой и релизами."
        },
        {
          "text": "Каковы основные ветки в Git Flow?",
          "options": [
            "Master, Development, Feature, Release, Hotfix",
            "Main, Feature, Bugfix",
            "Master, Feature, Release",
            "Development, Testing, Production"
          ],
          "correctAnswer": "Master, Development, Feature, Release, Hotfix",
          "explanation": "Основные ветки в Git Flow включают master, development, feature, release и hotfix."
        },
        {
          "text": "Что такое Feature Branch в Git Flow?",
          "options": [
            "Ветка для разработки новых функций",
            "Ветка для исправления ошибок",
            "Ветка для релизов",
            "Ветка для тестирования"
          ],
          "correctAnswer": "Ветка для разработки новых функций",
          "explanation": "Feature Branch — это ветка, в которой разрабатываются новые функции отдельно от основной ветки."
        },
        {
          "text": "Когда создается Release Branch в Git Flow?",
          "options": [
            "Когда development наберет достаточно фич для релиза",
            "Когда нужно исправить ошибку",
            "Когда начинается новая разработка",
            "Когда заканчивается проект"
          ],
          "correctAnswer": "Когда development наберет достаточно фич для релиза",
          "explanation": "Release Branch создается, когда в ветке development накопилось достаточно функций для нового релиза."
        },
        {
          "text": "Что такое Hotfix Branch в Git Flow?",
          "options": [
            "Ветка для быстрого исправления релизов",
            "Ветка для разработки новых функций",
            "Ветка для тестирования",
            "Ветка для документации"
          ],
          "correctAnswer": "Ветка для быстрого исправления релизов",
          "explanation": "Hotfix Branch используется для быстрого патчинга релизов и создается из master."
        },
        {
          "text": "Что такое Git Rebase?",
          "options": [
            "Метод слияния веток, который изменяет историю коммитов",
            "Способ создания новой ветки",
            "Команда для удаления коммитов",
            "Способ создания резервной копии"
          ],
          "correctAnswer": "Метод слияния веток, который изменяет историю коммитов",
          "explanation": "Git Rebase позволяет перемещать ваши локальные коммиты после всех коммитов в другой ветке, изменяя их хэши."
        },
        {
          "text": "Когда следует использовать git rebase?",
          "options": [
            "Когда нужно объединить несколько коммитов в один",
            "Когда нужно удалить коммиты",
            "Когда нужно создать новую ветку",
            "Когда нужно сделать резервную копию"
          ],
          "correctAnswer": "Когда нужно объединить несколько коммитов в один",
          "explanation": "Git Rebase используется для объединения нескольких коммитов в один, чтобы упростить историю изменений."
        },
        {
          "text": "Что происходит с хэшами коммитов при использовании git rebase?",
          "options": [
            "Хэши коммитов остаются неизменными",
            "Хэши коммитов изменяются",
            "Хэши коммитов удаляются",
            "Хэши коммитов дублируются"
          ],
          "correctAnswer": "Хэши коммитов изменяются",
          "explanation": "При использовании git rebase хэши ваших коммитов изменяются, так как они перемещаются в новую позицию в истории."
        },
        {
          "text": "Что такое 'squash' в контексте git rebase?",
          "options": [
            "Объединение нескольких коммитов в один",
            "Удаление коммитов",
            "Создание новой ветки",
            "Изменение комментариев коммитов"
          ],
          "correctAnswer": "Объединение нескольких коммитов в один",
          "explanation": "'Squash' позволяет объединить несколько коммитов в один, сохраняя только один комментарий."
        },
        {
          "text": "Что нужно сделать после редактирования коммитов с помощью git rebase?",
          "options": [
            "Выполнить push с опцией -f",
            "Удалить ветку",
            "Создать новую ветку",
            "Сделать merge"
          ],
          "correctAnswer": "Выполнить push с опцией -f",
          "explanation": "После редактирования коммитов с помощью git rebase необходимо выполнить push с опцией -f, так как история коммитов была изменена."
        },
        {
          "text": "Что такое git cherry-pick?",
          "options": [
            "Команда для переноса отдельных коммитов между ветками",
            "Команда для слияния веток",
            "Команда для удаления коммитов",
            "Команда для создания новой ветки"
          ],
          "correctAnswer": "Команда для переноса отдельных коммитов между ветками",
          "explanation": "Команда `git cherry-pick` используется для переноса отдельных коммитов из одного места репозитория в другое, обычно между ветками."
        },
        {
          "text": "Как используется команда git cherry-pick?",
          "options": [
            "git cherry-pick <commit-hash>",
            "git cherry-pick <branch-name>",
            "git cherry-pick <file-name>",
            "git cherry-pick <tag-name>"
          ],
          "correctAnswer": "git cherry-pick <commit-hash>",
          "explanation": "Команда `git cherry-pick` используется с указанием хэша коммита, который нужно перенести."
        },
        {
          "text": "В чем отличие git cherry-pick от git merge?",
          "options": [
            "Cherry-pick переносит отдельные коммиты, а merge — целые цепочки коммитов",
            "Cherry-pick объединяет ветки, а merge — создает новые",
            "Cherry-pick удаляет коммиты, а merge — сохраняет их",
            "Cherry-pick работает только с локальными ветками, а merge — с удаленными"
          ],
          "correctAnswer": "Cherry-pick переносит отдельные коммиты, а merge — целые цепочки коммитов",
          "explanation": "Команда `git cherry-pick` переносит отдельные коммиты, в то время как `git merge` объединяет целые цепочки коммитов."
        },
        {
          "text": "Что такое force push в Git?",
          "options": [
            "Команда для принудительной отправки изменений в удаленный репозиторий",
            "Команда для удаления ветки",
            "Команда для создания новой ветки",
            "Команда для слияния веток"
          ],
          "correctAnswer": "Команда для принудительной отправки изменений в удаленный репозиторий",
          "explanation": "Force push используется для принудительной отправки изменений в удаленный репозиторий, даже если это перезаписывает историю."
        },
        {
          "text": "Когда необходимо использовать git push --force?",
          "options": [
            "Когда вы изменили историю коммитов",
            "Когда вы хотите создать новую ветку",
            "Когда вы хотите удалить коммиты",
            "Когда вы хотите объединить ветки"
          ],
          "correctAnswer": "Когда вы изменили историю коммитов",
          "explanation": "git push --force необходимо использовать, если вы изменили историю коммитов, например, исправили имя автора или отменили последний коммит."
        },
        {
          "text": "Какой более безопасный вариант команды для принудительного пуша?",
          "options": [
            "git push --force-with-lease",
            "git push --force",
            "git push --all",
            "git push --tags"
          ],
          "correctAnswer": "git push --force-with-lease",
          "explanation": "git push --force-with-lease более безопасен, так как он предотвращает перезапись чужих коммитов, если они были добавлены после последнего получения изменений."
        },
        {
          "text": "Что произойдет, если использовать git push --force без предостережений?",
          "options": [
            "Можно перезаписать чужие изменения",
            "Команда не выполнится",
            "Создастся новая ветка",
            "Удалит все коммиты"
          ],
          "correctAnswer": "Можно перезаписать чужие изменения",
          "explanation": "Использование git push --force может привести к перезаписи чужих изменений, если кто-то другой уже запушил свои коммиты."
        },
        {
          "text": "Что такое pre-commit check в Git?",
          "options": [
            "Сценарий, выполняемый перед созданием коммита",
            "Команда для удаления коммитов",
            "Команда для слияния веток",
            "Сценарий, выполняемый после создания коммита"
          ],
          "correctAnswer": "Сценарий, выполняемый перед созданием коммита",
          "explanation": "Pre-commit check — это сценарий, который выполняется перед созданием коммита для проверки кода на валидность и других условий."
        },
        {
          "text": "Для чего можно использовать pre-commit check?",
          "options": [
            "Для проверки кода на валидность и выполнения юнит-тестов",
            "Для создания новой ветки",
            "Для удаления старых коммитов",
            "Для слияния веток"
          ],
          "correctAnswer": "Для проверки кода на валидность и выполнения юнит-тестов",
          "explanation": "Pre-commit check можно использовать для проверки кода на валидность, выполнения юнит-тестов и прерывания операции коммита в случае ошибок."
        },
        {
          "text": "Какие типы перехватчиков (hooks) существуют в Git?",
          "options": [
            "На стороне клиента и на стороне сервера",
            "Только на стороне клиента",
            "Только на стороне сервера",
            "Только для коммитов"
          ],
          "correctAnswer": "На стороне клиента и на стороне сервера",
          "explanation": "В Git существуют перехватчики на стороне клиента для операций, таких как создание коммита, и на стороне сервера для операций, таких как прием отправленных коммитов."
        },
        {
          "text": "Что может произойти, если pre-commit check обнаружит ошибки?",
          "options": [
            "Операция коммита будет прервана",
            "Коммит будет создан с ошибками",
            "Ошибки будут проигнорированы",
            "Коммит будет автоматически исправлен"
          ],
          "correctAnswer": "Операция коммита будет прервана",
          "explanation": "Если pre-commit check обнаружит ошибки, операция коммита будет прервана, и будет отображен журнал для разбора ошибок."
        }
      ]
    },
    {
      "id": "databases",
      "name": "Базы данных",
      "description": "Вопросы по базам данных и транзакциям.",
      "questions": [
        {
          "text": "Что такое транзакция в контексте баз данных?",
          "options": [
            "Рабочая единица работы с базой данных",
            "Тип базы данных",
            "Команда для удаления данных",
            "Процесс создания базы данных"
          ],
          "correctAnswer": "Рабочая единица работы с базой данных",
          "explanation": "Транзакция — это последовательность операций, выполняемых в логическом порядке пользователем или программой, работающей с базой данных."
        },
        {
          "text": "Каковы основные свойства транзакции, описываемые аббревиатурой ACID?",
          "options": [
            "Атомарность, Согласованность, Изолированность, Долговечность",
            "Анализ, Синхронизация, Изоляция, Долговечность",
            "Атомарность, Согласованность, Интеграция, Долговечность",
            "Анализ, Согласованность, Изолированность, Долговечность"
          ],
          "correctAnswer": "Атомарность, Согласованность, Изолированность, Долговечность",
          "explanation": "Основные свойства транзакции описываются аббревиатурой ACID: Атомарность, Согласованность, Изолированность, Долговечность."
        },
        {
          "text": "Что означает атомарность транзакции?",
          "options": [
            "Транзакция фиксируется только целиком",
            "Транзакция может быть частично выполнена",
            "Транзакция не может быть отменена",
            "Транзакция выполняется в фоновом режиме"
          ],
          "correctAnswer": "Транзакция фиксируется только целиком",
          "explanation": "Атомарность гарантирует, что любая транзакция будет зафиксирована только целиком; если одна из операций не выполнена, вся транзакция будет отменена."
        },
        {
          "text": "Что означает согласованность в контексте транзакций?",
          "options": [
            "Завершенная транзакция фиксирует только допустимые результаты",
            "Транзакция может быть выполнена в любое время",
            "Транзакция не зависит от других",
            "Транзакция может быть отменена"
          ],
          "correctAnswer": "Завершенная транзакция фиксирует только допустимые результаты",
          "explanation": "Согласованность означает, что любая завершенная транзакция фиксирует только допустимые результаты, поддерживая баланс системы."
        },
        {
          "text": "Что такое долговечность в контексте транзакций?",
          "options": [
            "Изменения не должны быть отменены из-за сбоя системы",
            "Транзакция может быть отменена",
            "Транзакция выполняется в фоновом режиме",
            "Транзакция может быть выполнена несколько раз"
          ],
          "correctAnswer": "Изменения не должны быть отменены из-за сбоя системы",
          "explanation": "Долговечность гарантирует, что если мы получили подтверждение о выполнении транзакции, изменения не должны быть отменены из-за сбоя системы."
        },
        {
          "text": "Какие команды управления транзакциями вы знаете?",
          "options": [
            "COMMIT, ROLLBACK, SAVEPOINT, SET TRANSACTION",
            "INSERT, UPDATE, DELETE",
            "CREATE, ALTER, DROP",
            "SELECT, FROM, WHERE"
          ],
          "correctAnswer": "COMMIT, ROLLBACK, SAVEPOINT, SET TRANSACTION",
          "explanation": "Для управления транзакциями используются команды: COMMIT (сохраняет изменения), ROLLBACK (отменяет изменения), SAVEPOINT (создает точку отката) и SET TRANSACTION (размещает имя транзакции)."
        },
        {
          "text": "Что делает команда COMMIT?",
          "options": [
            "Сохраняет изменения в базе данных",
            "Отменяет изменения",
            "Создает точку отката",
            "Изменяет имя транзакции"
          ],
          "correctAnswer": "Сохраняет изменения в базе данных",
          "explanation": "Команда COMMIT сохраняет все изменения, сделанные в текущей транзакции."
        },
        {
          "text": "Что делает команда ROLLBACK?",
          "options": [
            "Сохраняет изменения",
            "Отменяет изменения",
            "Создает точку отката",
            "Изменяет имя транзакции"
          ],
          "correctAnswer": "Отменяет изменения",
          "explanation": "Команда ROLLBACK отменяет все изменения, сделанные в текущей транзакции."
        },
        {
          "text": "Что такое SAVEPOINT?",
          "options": [
            "Создает точку, к которой можно откатиться",
            "Сохраняет изменения",
            "Отменяет изменения",
            "Изменяет имя транзакции"
          ],
          "correctAnswer": "Создает точку, к которой можно откатиться",
          "explanation": "SAVEPOINT создает точку в транзакции, к которой можно откатиться, если это необходимо."
        },
        {
          "text": "Для каких команд можно использовать команды управления транзакциями?",
          "options": [
            "Только для DML команд: INSERT, UPDATE, DELETE",
            "Для всех команд SQL",
            "Только для DDL команд",
            "Только для SELECT команд"
          ],
          "correctAnswer": "Только для DML команд: INSERT, UPDATE, DELETE",
          "explanation": "Команды управления транзакциями используются только для DML команд: INSERT, UPDATE, DELETE."
        },
        {
          "text": "Что такое уровни изолированности транзакций?",
          "options": [
            "Способы управления конкурентным доступом к данным",
            "Типы баз данных",
            "Методы создания таблиц",
            "Способы удаления данных"
          ],
          "correctAnswer": "Способы управления конкурентным доступом к данным",
          "explanation": "Уровни изолированности транзакций определяют, как транзакции взаимодействуют друг с другом и как они видят данные, измененные другими транзакциями."
        },
        {
          "text": "Какой уровень изолированности предотвращает 'грязные' операции чтения?",
          "options": [
            "Чтение зафиксированных данных (Read Committed)",
            "Изоляция снимков состояния",
            "Сериализуемость",
            "Чтение незакрепленных данных"
          ],
          "correctAnswer": "Чтение зафиксированных данных (Read Committed)",
          "explanation": "Уровень изоляции 'Чтение зафиксированных данных' предотвращает 'грязные' операции чтения, позволяя видеть только зафиксированные данные."
        },
        {
          "text": "Что такое сериализуемость в контексте изолированности транзакций?",
          "options": [
            "Самый сильный уровень изолированности, который гарантирует последовательное выполнение транзакций",
            "Уровень, который позволяет транзакциям выполняться параллельно",
            "Уровень, который предотвращает все операции записи",
            "Уровень, который не требует блокировок"
          ],
          "correctAnswer": "Самый сильный уровень изолированности, который гарантирует последовательное выполнение транзакций",
          "explanation": "Сериализуемость гарантирует, что результат выполнения транзакций будет таким же, как если бы они выполнялись последовательно."
        },
        {
          "text": "Какой метод обеспечивает сериализуемость, но может иметь плохие показатели производительности?",
          "options": [
            "Двухфазная блокировка",
            "Сериализуемая изоляция снимков состояния",
            "Оптимистический подход",
            "Чтение зафиксированных данных"
          ],
          "correctAnswer": "Двухфазная блокировка",
          "explanation": "Двухфазная блокировка была стандартным способом обеспечения сериализуемости, но многие приложения стараются ее не использовать из-за плохих показателей производительности."
        },
        {
          "text": "Что такое изоляция снимков состояния?",
          "options": [
            "Каждая транзакция читает данные из согласованного снимка состояния БД",
            "Транзакция выполняется без блокировок",
            "Транзакция может быть отменена",
            "Транзакция выполняется в фоновом режиме"
          ],
          "correctAnswer": "Каждая транзакция читает данные из согласованного снимка состояния БД",
          "explanation": "Изоляция снимков состояния позволяет каждой транзакции видеть данные, которые были зафиксированы на момент ее начала, предотвращая асимметрию чтения."
        },
        {
          "text": "Что такое вложенные транзакции?",
          "options": [
            "Транзакции, инициируемые из тела уже активной транзакции",
            "Транзакции, которые выполняются параллельно",
            "Транзакции, которые не могут быть отменены",
            "Транзакции, которые выполняются только в фоновом режиме"
          ],
          "correctAnswer": "Транзакции, инициируемые из тела уже активной транзакции",
          "explanation": "Вложенные транзакции — это транзакции, выполнение которых инициируется из тела уже активной транзакции."
        },
        {
          "text": "Что происходит при завершении транзакции верхнего уровня, если вложенная транзакция завершена неудачно?",
          "options": [
            "Все транзакции верхнего уровня будут отменены",
            "Только вложенная транзакция будет отменена",
            "Транзакция верхнего уровня будет зафиксирована",
            "Ничего не произойдет"
          ],
          "correctAnswer": "Все транзакции верхнего уровня будут отменены",
          "explanation": "Если вложенная транзакция завершена неудачно, то все транзакции верхнего уровня, включая транзакцию первого уровня, будут отменены."
        },
        {
          "text": "Как работает команда COMMIT TRANSACTION в контексте вложенных транзакций?",
          "options": [
            "Она завершает только последнюю начатую транзакцию",
            "Она завершает все транзакции",
            "Она завершает транзакцию верхнего уровня",
            "Она не имеет эффекта"
          ],
          "correctAnswer": "Она завершает только последнюю начатую транзакцию",
          "explanation": "Каждая команда COMMIT TRANSACTION работает только с последней начатой транзакцией, завершая наиболее 'глубокую' вложенную транзакцию."
        },
        {
          "text": "Что произойдет, если несколько вложенных транзакций завершатся успешно, но одна из транзакций среднего уровня завершится неудачно?",
          "options": [
            "Произойдет откат всех транзакций всех уровней",
            "Только неудачная транзакция будет отменена",
            "Все транзакции будут зафиксированы",
            "Ничего не произойдет"
          ],
          "correctAnswer": "Произойдет откат всех транзакций всех уровней",
          "explanation": "Если одна из транзакций среднего уровня завершится неудачно, произойдет откат всех транзакций всех уровней, включая успешно завершенные."
        },
        {
          "text": "Что такое курсор в контексте баз данных?",
          "options": [
            "Указатель на ряд данных в базе данных",
            "Тип базы данных",
            "Команда для удаления данных",
            "Процесс создания таблицы"
          ],
          "correctAnswer": "Указатель на ряд данных в базе данных",
          "explanation": "Курсор — это указатель на ряд данных в реляционной базе данных, который позволяет обрабатывать записи по одной."
        },
        {
          "text": "Для чего обычно используются курсоры?",
          "options": [
            "Для выбора подмножества информации из базы данных",
            "Для создания новых таблиц",
            "Для удаления всех записей",
            "Для изменения структуры базы данных"
          ],
          "correctAnswer": "Для выбора подмножества информации из базы данных",
          "explanation": "Курсоры используются для выбора из базы данных некоторого подмножества хранимой в ней информации."
        },
        {
          "text": "Какова основная проблема использования курсоров?",
          "options": [
            "Скорость выполнения операций ниже, чем у стандартных команд SQL",
            "Курсоры не могут быть использованы в SQL",
            "Курсоры не позволяют выбирать данные",
            "Курсоры требуют больше памяти"
          ],
          "correctAnswer": "Скорость выполнения операций ниже, чем у стандартных команд SQL",
          "explanation": "Курсоры имеют более низкую скорость выполнения операций обработки данных по сравнению со стандартными командами SQL."
        },
        {
          "text": "Что происходит, если курсор неявно создается сервером базы данных?",
          "options": [
            "Он автоматически управляется сервером",
            "Программист должен его определить",
            "Он не может быть использован",
            "Он требует дополнительных команд"
          ],
          "correctAnswer": "Он автоматически управляется сервером",
          "explanation": "Некоторые курсоры создаются неявно сервером базы данных и управляются им."
        },
        {
          "text": "Какой подход рекомендуется вместо использования курсоров?",
          "options": [
            "Использовать стандартные команды обработки данных: SELECT, UPDATE, INSERT, DELETE",
            "Использовать только курсоры",
            "Использовать только команды удаления",
            "Использовать только команды создания таблиц"
          ],
          "correctAnswer": "Использовать стандартные команды обработки данных: SELECT, UPDATE, INSERT, DELETE",
          "explanation": "Рекомендуется избегать использования курсоров и работать со стандартными командами обработки данных."
        },
        {
          "text": "Какая разница между PostgreSQL и MySQL?",
          "options": [
            "PostgreSQL поддерживает больше стандартов SQL, чем MySQL",
            "MySQL всегда быстрее PostgreSQL",
            "PostgreSQL не поддерживает индексы",
            "MySQL не поддерживает транзакции"
          ],
          "correctAnswer": "PostgreSQL поддерживает больше стандартов SQL, чем MySQL",
          "explanation": "PostgreSQL поддерживает все новые стандарты SQL, в то время как MySQL не поддерживает все функции и возможности SQL."
        },
        {
          "text": "Какой движок используется в MySQL для хранения данных?",
          "options": [
            "Различные движки, такие как InnoDB и MyISAM",
            "Только один движок",
            "Нет движка",
            "Только PostgreSQL"
          ],
          "correctAnswer": "Различные движки, такие как InnoDB и MyISAM",
          "explanation": "MySQL использует различные движки для хранения данных, такие как MyISAM, InnoDB, MEMORY и другие."
        },
        {
          "text": "Как PostgreSQL обрабатывает данные при выполнении запроса?",
          "options": [
            "Хранит весь ответ в памяти сервера, а клиент получает указатель",
            "Загружает весь ответ в память клиента",
            "Не обрабатывает данные",
            "Сохраняет данные на диск"
          ],
          "correctAnswer": "Хранит весь ответ в памяти сервера, а клиент получает только указатель на данные.",
          "explanation": "PostgreSQL хранит весь ответ в памяти сервера, а клиент получает только указатель на данные."
        },
        {
          "text": "Какой из этих типов данных поддерживает PostgreSQL, но не поддерживает MySQL?",
          "options": [
            "Регулярные выражения",
            "Целые числа",
            "Строки",
            "Дата и время"
          ],
          "correctAnswer": "Регулярные выражения",
          "explanation": "PostgreSQL поддерживает регулярные выражения в запросах, чего нет в MySQL."
        },
        {
          "text": "Какой из этих вариантов верен относительно производительности MySQL и PostgreSQL?",
          "options": [
            "MySQL быстрее при использовании первичных ключей",
            "PostgreSQL всегда быстрее MySQL",
            "Они имеют одинаковую производительность",
            "MySQL медленнее, чем PostgreSQL"
          ],
          "correctAnswer": "MySQL быстрее при использовании первичных ключей",
          "explanation": "MySQL был ориентирован на большую производительность, особенно при использовании первичных ключей."
        },
        {
          "text": "Что такое VACUUM в PostgreSQL?",
          "options": [
            "Команда для высвобождения пространства, занимаемого 'мёртвыми' кортежами",
            "Команда для создания резервной копии базы данных",
            "Команда для удаления таблиц",
            "Команда для обновления данных"
          ],
          "correctAnswer": "Команда для высвобождения пространства, занимаемого 'мёртвыми' кортежами",
          "explanation": "VACUUM высвобождает пространство, занимаемое 'мёртвыми' кортежами, которые не удаляются физически из таблицы при обычных операциях."
        },
        {
          "text": "Когда необходимо выполнять команду VACUUM?",
          "options": [
            "Периодически, особенно для часто изменяемых таблиц",
            "Каждый раз после обновления данных",
            "Только при создании новой таблицы",
            "Никогда, это не требуется"
          ],
          "correctAnswer": "Периодически, особенно для часто изменяемых таблиц",
          "explanation": "Необходимо периодически выполнять VACUUM, особенно для таблиц, которые часто изменяются."
        },
        {
          "text": "Что такое EXPLAIN в PostgreSQL?",
          "options": [
            "Команда для вывода информации о выполнении запроса",
            "Команда для удаления данных",
            "Команда для создания индексов",
            "Команда для обновления данных"
          ],
          "correctAnswer": "Команда для вывода информации о выполнении запроса",
          "explanation": "EXPLAIN выводит информацию, необходимую для понимания, что делает ядро при каждом конкретном запросе."
        },
        {
          "text": "В чем разница между EXPLAIN и EXPLAIN ANALYZE?",
          "options": [
            "EXPLAIN ANALYZE выполняет запрос и выводит его результаты",
            "EXPLAIN не выводит информацию о запросе",
            "EXPLAIN ANALYZE используется только для SELECT запросов",
            "EXPLAIN и EXPLAIN ANALYZE идентичны"
          ],
          "correctAnswer": "EXPLAIN ANALYZE выполняет запрос и выводит его результаты",
          "explanation": "EXPLAIN ANALYZE выполняет объясняемое выражение, даже если это insert, update или delete, в отличие от EXPLAIN, который только выводит информацию."
        },
        {
          "text": "Какие виды JOIN'ов вы знаете?",
          "options": [
            "INNER JOIN, LEFT OUTER JOIN, RIGHT OUTER JOIN, FULL OUTER JOIN, CROSS JOIN",
            "INNER JOIN, OUTER JOIN, NATURAL JOIN",
            "LEFT JOIN, RIGHT JOIN, FULL JOIN",
            "JOIN, LEFT JOIN, RIGHT JOIN"
          ],
          "correctAnswer": "INNER JOIN, LEFT OUTER JOIN, RIGHT OUTER JOIN, FULL OUTER JOIN, CROSS JOIN",
          "explanation": "Существуют различные виды JOIN'ов, включая INNER JOIN, LEFT OUTER JOIN, RIGHT OUTER JOIN, FULL OUTER JOIN и CROSS JOIN."
        },
        {
          "text": "Что делает INNER JOIN?",
          "options": [
            "Возвращает строки, которые имеют соответствия в обеих таблицах",
            "Возвращает все строки из первой таблицы",
            "Возвращает все строки из второй таблицы",
            "Возвращает все строки, даже если нет соответствий"
          ],
          "correctAnswer": "Возвращает строки, которые имеют соответствия в обеих таблицах",
          "explanation": "INNER JOIN возвращает строки, которые имеют соответствия в обеих таблицах."
        },
        {
          "text": "Какой результат дает LEFT OUTER JOIN?",
          "options": [
            "Все строки из первой таблицы и соответствующие строки из второй таблицы",
            "Только строки, которые имеют соответствия в обеих таблицах",
            "Все строки из второй таблицы",
            "Только строки, которые не имеют соответствий"
          ],
          "correctAnswer": "Все строки из первой таблицы и соответствующие строки из второй таблицы",
          "explanation": "LEFT OUTER JOIN возвращает все строки из первой таблицы и соответствующие строки из второй таблицы, а если соответствий нет, то вставляются NULL."
        },
        {
          "text": "Что делает FULL OUTER JOIN?",
          "options": [
            "Возвращает все строки из обеих таблиц, включая строки без соответствий",
            "Возвращает только строки с соответствиями",
            "Возвращает только строки из первой таблицы",
            "Возвращает только строки из второй таблицы"
          ],
          "correctAnswer": "Возвращает все строки из обеих таблиц, включая строки без соответствий",
          "explanation": "FULL OUTER JOIN возвращает все строки из обеих таблиц, включая строки, которые не имеют соответствий."
        },
        {
          "text": "Что такое CROSS JOIN?",
          "options": [
            "Декартово произведение двух таблиц",
            "Соединение таблиц по ключевым полям",
            "Соединение таблиц с использованием NATURAL",
            "Соединение таблиц с использованием USING"
          ],
          "correctAnswer": "Декартово произведение двух таблиц",
          "explanation": "CROSS JOIN возвращает декартово произведение двух таблиц, то есть все возможные комбинации строк из обеих таблиц."
        }
      ]
    }
  ]
} 